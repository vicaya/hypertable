/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */
package org.hypertable.thriftgen;

import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.EnumMap;
import java.util.Set;
import java.util.HashSet;
import java.util.EnumSet;
import java.util.Collections;
import java.util.BitSet;
import java.nio.ByteBuffer;
import java.util.Arrays;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.thrift.*;
import org.apache.thrift.async.*;
import org.apache.thrift.meta_data.*;
import org.apache.thrift.transport.*;
import org.apache.thrift.protocol.*;

public class ClientService {

  /**
   * The client service mimics the C++ client API, with table, scanner and
   * mutator interface flattened.
   */
  public interface Iface {

    /**
     * Create a namespace
     * 
     * @param ns - namespace name
     * 
     * @param ns
     */
    public void create_namespace(String ns) throws ClientException, TException;

    /**
     * Create a table
     * 
     * @param ns - namespace id
     * @param table_name - table name
     * @param schema - schema of the table (in xml)
     * 
     * @param ns
     * @param table_name
     * @param schema
     */
    public void create_table(long ns, String table_name, String schema) throws ClientException, TException;

    /**
     * Open a namespace
     * 
     * @param ns - namespace
     * @return value is guaranteed to be non-zero and unique
     * 
     * @param ns
     */
    public long open_namespace(String ns) throws ClientException, TException;

    /**
     * Close a namespace
     * 
     * @param ns - namespace
     * 
     * @param ns
     */
    public void close_namespace(long ns) throws ClientException, TException;

    /**
     * Open a future object
     * @param queue_size - num of results the future object can enqueue without blocking threads
     * 
     * @param queue_size
     */
    public long open_future(int queue_size) throws ClientException, TException;

    /**
     * Fetch asynchronous results
     * @param ff - Future object which has the asynchronous results
     * @return - result from async scanner/mutator
     * 
     * @param ff
     */
    public Result get_future_result(long ff) throws ClientException, TException;

    /**
     * Fetch asynchronous results
     * @param ff - Future object which has the asynchronous results
     * @return - result from async scanner/mutator
     * 
     * @param ff
     */
    public ResultAsArrays get_future_result_as_arrays(long ff) throws ClientException, TException;

    /**
     * Fetch asynchronous results
     * @param ff - Future object which has the asynchronous results
     * @return - result from async scanner/mutator
     * 
     * @param ff
     */
    public ResultSerialized get_future_result_serialized(long ff) throws ClientException, TException;

    /**
     * Close a future object
     * @param ff - the future object to be closed
     * 
     * @param ff
     */
    public void close_future(long ff) throws ClientException, TException;

    /**
     * Open a table scanner
     * @param ns - namespace id
     * @param table_name - table name
     * @param scan_spec - scan specification
     * @param retry_table_not_found - whether to retry upon errors caused by
     *        drop/create tables with the same name
     * 
     * @param ns
     * @param table_name
     * @param scan_spec
     * @param retry_table_not_found
     */
    public long open_scanner(long ns, String table_name, ScanSpec scan_spec, boolean retry_table_not_found) throws ClientException, TException;

    /**
     * Open an asynchronous table scanner
     * @param ns - namespace id
     * @param table_name - table name
     * @param future - callback object
     * @param scan_spec - scan specification
     * @param retry_table_not_found - whether to retry upon errors caused by
     *        drop/create tables with the same name
     * 
     * @param ns
     * @param table_name
     * @param future
     * @param scan_spec
     * @param retry_table_not_found
     */
    public long open_scanner_async(long ns, String table_name, long future, ScanSpec scan_spec, boolean retry_table_not_found) throws ClientException, TException;

    /**
     * Close a table scanner
     * 
     * @param scanner - scanner id to close
     * 
     * @param scanner
     */
    public void close_scanner(long scanner) throws ClientException, TException;

    /**
     * Close a table scanner
     * 
     * @param scanner - scanner id to close
     * 
     * @param scanner
     */
    public void close_scanner_async(long scanner) throws ClientException, TException;

    /**
     * Iterate over cells of a scanner
     * 
     * @param scanner - scanner id
     * 
     * @param scanner
     */
    public List<Cell> next_cells(long scanner) throws ClientException, TException;

    public List<List<String>> next_cells_as_arrays(long scanner) throws ClientException, TException;

    /**
     * Alternative interface returning buffer of serialized cells
     * 
     * @param scanner
     */
    public ByteBuffer next_cells_serialized(long scanner) throws TException;

    /**
     * Iterate over rows of a scanner
     * 
     * @param scanner - scanner id
     * 
     * @param scanner
     */
    public List<Cell> next_row(long scanner) throws ClientException, TException;

    /**
     * Alternative interface using array as cell
     * 
     * @param scanner
     */
    public List<List<String>> next_row_as_arrays(long scanner) throws ClientException, TException;

    /**
     * Alternate interface returning a buffer of serialized cells for iterating by row
     * for a given scanner
     * 
     * @param scanner - scanner id
     * 
     * @param scanner
     */
    public ByteBuffer next_row_serialized(long scanner) throws ClientException, TException;

    /**
     * Get a row (convenience method for random access a row)
     * 
     * @param ns - namespace id
     * 
     * @param table_name - table name
     * 
     * @param row - row key
     * 
     * @return a list of cells (with row_keys unset)
     * 
     * @param ns
     * @param table_name
     * @param row
     */
    public List<Cell> get_row(long ns, String table_name, String row) throws ClientException, TException;

    /**
     * Alternative interface using array as cell
     * 
     * @param ns
     * @param name
     * @param row
     */
    public List<List<String>> get_row_as_arrays(long ns, String name, String row) throws ClientException, TException;

    /**
     * Alternative interface returning buffer of serialized cells
     * 
     * @param ns
     * @param table_name
     * @param row
     */
    public ByteBuffer get_row_serialized(long ns, String table_name, String row) throws ClientException, TException;

    /**
     * Get a cell (convenience method for random access a cell)
     * 
     * @param ns - namespace id
     * 
     * @param table_name - table name
     * 
     * @param row - row key
     * 
     * @param column - column name
     * 
     * @return value (byte sequence)
     * 
     * @param ns
     * @param table_name
     * @param row
     * @param column
     */
    public ByteBuffer get_cell(long ns, String table_name, String row, String column) throws ClientException, TException;

    /**
     * Get cells (convenience method for access small amount of cells)
     * 
     * @param ns - namespace id
     *  
     * @param table_name - table name
     * 
     * @param scan_spec - scan specification
     * 
     * @return a list of cells (a cell with no row key set is assumed to have
     *         the same row key as the previous cell)
     * 
     * @param ns
     * @param table_name
     * @param scan_spec
     */
    public List<Cell> get_cells(long ns, String table_name, ScanSpec scan_spec) throws ClientException, TException;

    /**
     * Alternative interface using array as cell
     * 
     * @param ns
     * @param name
     * @param scan_spec
     */
    public List<List<String>> get_cells_as_arrays(long ns, String name, ScanSpec scan_spec) throws ClientException, TException;

    /**
     * Alternative interface returning buffer of serialized cells
     * 
     * @param ns
     * @param name
     * @param scan_spec
     */
    public ByteBuffer get_cells_serialized(long ns, String name, ScanSpec scan_spec) throws ClientException, TException;

    /**
     * Create a shared mutator with specified MutateSpec.
     * Delete and recreate it if the mutator exists.
     * 
     * @param ns - namespace id
     *  
     * @param table_name - table name
     * 
     * @param mutate_spec - mutator specification
     * 
     * 
     * @param ns
     * @param table_name
     * @param mutate_spec
     */
    public void refresh_shared_mutator(long ns, String table_name, MutateSpec mutate_spec) throws ClientException, TException;

    /**
     * Open a shared periodic mutator which causes cells to be written asyncronously.
     * Users beware: calling this method merely writes
     * cells to a local buffer and does not guarantee that the cells have been persisted.
     * If you want guaranteed durability, use the open_mutator+set_cells* interface instead.
     * 
     * @param ns - namespace id
     * 
     * @param table_name - table name
     * 
     * @param mutate_spec - mutator specification
     * 
     * @param cells - set of cells to be written
     * 
     * @param ns
     * @param table_name
     * @param mutate_spec
     * @param cells
     */
    public void offer_cells(long ns, String table_name, MutateSpec mutate_spec, List<Cell> cells) throws ClientException, TException;

    /**
     * Alternative to offer_cell interface using array as cell
     * 
     * @param ns
     * @param table_name
     * @param mutate_spec
     * @param cells
     */
    public void offer_cells_as_arrays(long ns, String table_name, MutateSpec mutate_spec, List<List<String>> cells) throws ClientException, TException;

    /**
     * Open a shared periodic mutator which causes cells to be written asyncronously.
     * Users beware: calling this method merely writes
     * cells to a local buffer and does not guarantee that the cells have been persisted.
     * If you want guaranteed durability, use the open_mutator+set_cells* interface instead.
     * 
     * @param ns - namespace id
     * 
     * @param table_name - table name
     * 
     * @param mutate_spec - mutator specification
     * 
     * @param cell - cell to be written
     * 
     * @param ns
     * @param table_name
     * @param mutate_spec
     * @param cell
     */
    public void offer_cell(long ns, String table_name, MutateSpec mutate_spec, Cell cell) throws ClientException, TException;

    /**
     * Alternative to offer_cell interface using array as cell
     * 
     * @param ns
     * @param table_name
     * @param mutate_spec
     * @param cell
     */
    public void offer_cell_as_array(long ns, String table_name, MutateSpec mutate_spec, List<String> cell) throws ClientException, TException;

    /**
     * Open a table mutator
     * 
     * @param ns - namespace id
     * 
     * @param table_name - table name
     * 
     * @param flags - mutator flags
     * 
     * @param flush_interval - auto-flush interval in milliseconds; 0 disables it.
     * 
     * @return mutator id
     * 
     * @param ns
     * @param table_name
     * @param flags
     * @param flush_interval
     */
    public long open_mutator(long ns, String table_name, int flags, int flush_interval) throws ClientException, TException;

    /**
     * Close a table mutator
     * 
     * @param mutator - mutator id to close
     * 
     * @param mutator
     * @param flush
     */
    public void close_mutator(long mutator, boolean flush) throws ClientException, TException;

    /**
     * Set a cell in the table
     * 
     * @param mutator - mutator id
     * 
     * @param cell - the cell to set
     * 
     * @param mutator
     * @param cell
     */
    public void set_cell(long mutator, Cell cell) throws ClientException, TException;

    /**
     * Alternative interface using array as cell
     * 
     * @param mutator
     * @param cell
     */
    public void set_cell_as_array(long mutator, List<String> cell) throws ClientException, TException;

    /**
     * Put a list of cells into a table
     * 
     * @param mutator - mutator id
     * 
     * @param cells - a list of cells (a cell with no row key set is assumed
     *        to have the same row key as the previous cell)
     * 
     * @param mutator
     * @param cells
     */
    public void set_cells(long mutator, List<Cell> cells) throws ClientException, TException;

    /**
     * Alternative interface using array as cell
     * 
     * @param mutator
     * @param cells
     */
    public void set_cells_as_arrays(long mutator, List<List<String>> cells) throws ClientException, TException;

    /**
     * Alternative interface using buffer of serialized cells
     * 
     * @param mutator
     * @param cells
     * @param flush
     */
    public void set_cells_serialized(long mutator, ByteBuffer cells, boolean flush) throws ClientException, TException;

    /**
     * Flush mutator buffers
     * 
     * @param mutator
     */
    public void flush_mutator(long mutator) throws ClientException, TException;

    /**
     * Check if the namespace exists
     * 
     * @param ns - namespace name
     * 
     * @return true if ns exists, false ow
     * 
     * @param ns
     */
    public boolean exists_namespace(String ns) throws ClientException, TException;

    /**
     * Check if the table exists
     * 
     * @param ns - namespace id
     * 
     * @param name - table name
     * 
     * @return true if table exists, false ow
     * 
     * @param ns
     * @param name
     */
    public boolean exists_table(long ns, String name) throws ClientException, TException;

    /**
     * Get the id of a table
     * 
     * @param ns - namespace id
     * 
     * @param table_name - table name
     * 
     * @return table id string
     * 
     * @param ns
     * @param table_name
     */
    public String get_table_id(long ns, String table_name) throws ClientException, TException;

    /**
     * Get the schema of a table as a string (that can be used with create_table)
     * 
     * @param ns - namespace id
     * 
     * @param table_name - table name
     * 
     * @return schema string (in xml)
     * 
     * @param ns
     * @param table_name
     */
    public String get_schema_str(long ns, String table_name) throws ClientException, TException;

    /**
     * Get the schema of a table as a string (that can be used with create_table)
     *   
     * @param ns - namespace id
     * 
     * @param table_name - table name
     * 
     * @return schema object describing a table
     * 
     * @param ns
     * @param table_name
     */
    public Schema get_schema(long ns, String table_name) throws ClientException, TException;

    /**
     * Get a list of table names in the namespace
     * 
     * @param ns - namespace id
     * 
     * @return a list of table names
     * 
     * @param ns
     */
    public List<String> get_tables(long ns) throws ClientException, TException;

    /**
     * Get a list of namespaces and table names table names in the namespace
     * 
     * @param ns - namespace
     * 
     * @return a list of table names
     * 
     * @param ns
     */
    public List<NamespaceListing> get_listing(long ns) throws ClientException, TException;

    /**
     * Get a list of table splits
     * 
     * @param ns - namespace id
     * 
     * @param table_name - table name
     * 
     * @return a list of table names
     * 
     * @param ns
     * @param table_name
     */
    public List<TableSplit> get_table_splits(long ns, String table_name) throws ClientException, TException;

    /**
     * Drop a namespace
     * 
     * @param ns - namespace name
     * 
     * @param if_exists - if true, don't barf if the table doesn't exist
     * 
     * @param ns
     * @param if_exists
     */
    public void drop_namespace(String ns, boolean if_exists) throws ClientException, TException;

    /**
     * Rename a table
     * 
     * @param ns - namespace id
     * 
     * @param name - current table name
     * 
     * @param new_name - new table name
     * 
     * @param ns
     * @param name
     * @param new_name
     */
    public void rename_table(long ns, String name, String new_name) throws ClientException, TException;

    /**
     * Drop a table
     * 
     * @param ns - namespace id
     * 
     * @param name - table name
     * 
     * @param if_exists - if true, don't barf if the table doesn't exist
     * 
     * @param ns
     * @param name
     * @param if_exists
     */
    public void drop_table(long ns, String name, boolean if_exists) throws ClientException, TException;

  }

  public interface AsyncIface {

    public void create_namespace(String ns, AsyncMethodCallback<AsyncClient.create_namespace_call> resultHandler) throws TException;

    public void create_table(long ns, String table_name, String schema, AsyncMethodCallback<AsyncClient.create_table_call> resultHandler) throws TException;

    public void open_namespace(String ns, AsyncMethodCallback<AsyncClient.open_namespace_call> resultHandler) throws TException;

    public void close_namespace(long ns, AsyncMethodCallback<AsyncClient.close_namespace_call> resultHandler) throws TException;

    public void open_future(int queue_size, AsyncMethodCallback<AsyncClient.open_future_call> resultHandler) throws TException;

    public void get_future_result(long ff, AsyncMethodCallback<AsyncClient.get_future_result_call> resultHandler) throws TException;

    public void get_future_result_as_arrays(long ff, AsyncMethodCallback<AsyncClient.get_future_result_as_arrays_call> resultHandler) throws TException;

    public void get_future_result_serialized(long ff, AsyncMethodCallback<AsyncClient.get_future_result_serialized_call> resultHandler) throws TException;

    public void close_future(long ff, AsyncMethodCallback<AsyncClient.close_future_call> resultHandler) throws TException;

    public void open_scanner(long ns, String table_name, ScanSpec scan_spec, boolean retry_table_not_found, AsyncMethodCallback<AsyncClient.open_scanner_call> resultHandler) throws TException;

    public void open_scanner_async(long ns, String table_name, long future, ScanSpec scan_spec, boolean retry_table_not_found, AsyncMethodCallback<AsyncClient.open_scanner_async_call> resultHandler) throws TException;

    public void close_scanner(long scanner, AsyncMethodCallback<AsyncClient.close_scanner_call> resultHandler) throws TException;

    public void close_scanner_async(long scanner, AsyncMethodCallback<AsyncClient.close_scanner_async_call> resultHandler) throws TException;

    public void next_cells(long scanner, AsyncMethodCallback<AsyncClient.next_cells_call> resultHandler) throws TException;

    public void next_cells_as_arrays(long scanner, AsyncMethodCallback<AsyncClient.next_cells_as_arrays_call> resultHandler) throws TException;

    public void next_cells_serialized(long scanner, AsyncMethodCallback<AsyncClient.next_cells_serialized_call> resultHandler) throws TException;

    public void next_row(long scanner, AsyncMethodCallback<AsyncClient.next_row_call> resultHandler) throws TException;

    public void next_row_as_arrays(long scanner, AsyncMethodCallback<AsyncClient.next_row_as_arrays_call> resultHandler) throws TException;

    public void next_row_serialized(long scanner, AsyncMethodCallback<AsyncClient.next_row_serialized_call> resultHandler) throws TException;

    public void get_row(long ns, String table_name, String row, AsyncMethodCallback<AsyncClient.get_row_call> resultHandler) throws TException;

    public void get_row_as_arrays(long ns, String name, String row, AsyncMethodCallback<AsyncClient.get_row_as_arrays_call> resultHandler) throws TException;

    public void get_row_serialized(long ns, String table_name, String row, AsyncMethodCallback<AsyncClient.get_row_serialized_call> resultHandler) throws TException;

    public void get_cell(long ns, String table_name, String row, String column, AsyncMethodCallback<AsyncClient.get_cell_call> resultHandler) throws TException;

    public void get_cells(long ns, String table_name, ScanSpec scan_spec, AsyncMethodCallback<AsyncClient.get_cells_call> resultHandler) throws TException;

    public void get_cells_as_arrays(long ns, String name, ScanSpec scan_spec, AsyncMethodCallback<AsyncClient.get_cells_as_arrays_call> resultHandler) throws TException;

    public void get_cells_serialized(long ns, String name, ScanSpec scan_spec, AsyncMethodCallback<AsyncClient.get_cells_serialized_call> resultHandler) throws TException;

    public void refresh_shared_mutator(long ns, String table_name, MutateSpec mutate_spec, AsyncMethodCallback<AsyncClient.refresh_shared_mutator_call> resultHandler) throws TException;

    public void offer_cells(long ns, String table_name, MutateSpec mutate_spec, List<Cell> cells, AsyncMethodCallback<AsyncClient.offer_cells_call> resultHandler) throws TException;

    public void offer_cells_as_arrays(long ns, String table_name, MutateSpec mutate_spec, List<List<String>> cells, AsyncMethodCallback<AsyncClient.offer_cells_as_arrays_call> resultHandler) throws TException;

    public void offer_cell(long ns, String table_name, MutateSpec mutate_spec, Cell cell, AsyncMethodCallback<AsyncClient.offer_cell_call> resultHandler) throws TException;

    public void offer_cell_as_array(long ns, String table_name, MutateSpec mutate_spec, List<String> cell, AsyncMethodCallback<AsyncClient.offer_cell_as_array_call> resultHandler) throws TException;

    public void open_mutator(long ns, String table_name, int flags, int flush_interval, AsyncMethodCallback<AsyncClient.open_mutator_call> resultHandler) throws TException;

    public void close_mutator(long mutator, boolean flush, AsyncMethodCallback<AsyncClient.close_mutator_call> resultHandler) throws TException;

    public void set_cell(long mutator, Cell cell, AsyncMethodCallback<AsyncClient.set_cell_call> resultHandler) throws TException;

    public void set_cell_as_array(long mutator, List<String> cell, AsyncMethodCallback<AsyncClient.set_cell_as_array_call> resultHandler) throws TException;

    public void set_cells(long mutator, List<Cell> cells, AsyncMethodCallback<AsyncClient.set_cells_call> resultHandler) throws TException;

    public void set_cells_as_arrays(long mutator, List<List<String>> cells, AsyncMethodCallback<AsyncClient.set_cells_as_arrays_call> resultHandler) throws TException;

    public void set_cells_serialized(long mutator, ByteBuffer cells, boolean flush, AsyncMethodCallback<AsyncClient.set_cells_serialized_call> resultHandler) throws TException;

    public void flush_mutator(long mutator, AsyncMethodCallback<AsyncClient.flush_mutator_call> resultHandler) throws TException;

    public void exists_namespace(String ns, AsyncMethodCallback<AsyncClient.exists_namespace_call> resultHandler) throws TException;

    public void exists_table(long ns, String name, AsyncMethodCallback<AsyncClient.exists_table_call> resultHandler) throws TException;

    public void get_table_id(long ns, String table_name, AsyncMethodCallback<AsyncClient.get_table_id_call> resultHandler) throws TException;

    public void get_schema_str(long ns, String table_name, AsyncMethodCallback<AsyncClient.get_schema_str_call> resultHandler) throws TException;

    public void get_schema(long ns, String table_name, AsyncMethodCallback<AsyncClient.get_schema_call> resultHandler) throws TException;

    public void get_tables(long ns, AsyncMethodCallback<AsyncClient.get_tables_call> resultHandler) throws TException;

    public void get_listing(long ns, AsyncMethodCallback<AsyncClient.get_listing_call> resultHandler) throws TException;

    public void get_table_splits(long ns, String table_name, AsyncMethodCallback<AsyncClient.get_table_splits_call> resultHandler) throws TException;

    public void drop_namespace(String ns, boolean if_exists, AsyncMethodCallback<AsyncClient.drop_namespace_call> resultHandler) throws TException;

    public void rename_table(long ns, String name, String new_name, AsyncMethodCallback<AsyncClient.rename_table_call> resultHandler) throws TException;

    public void drop_table(long ns, String name, boolean if_exists, AsyncMethodCallback<AsyncClient.drop_table_call> resultHandler) throws TException;

  }

  public static class Client implements TServiceClient, Iface {
    public static class Factory implements TServiceClientFactory<Client> {
      public Factory() {}
      public Client getClient(TProtocol prot) {
        return new Client(prot);
      }
      public Client getClient(TProtocol iprot, TProtocol oprot) {
        return new Client(iprot, oprot);
      }
    }

    public Client(TProtocol prot)
    {
      this(prot, prot);
    }

    public Client(TProtocol iprot, TProtocol oprot)
    {
      iprot_ = iprot;
      oprot_ = oprot;
    }

    protected TProtocol iprot_;
    protected TProtocol oprot_;

    protected int seqid_;

    public TProtocol getInputProtocol()
    {
      return this.iprot_;
    }

    public TProtocol getOutputProtocol()
    {
      return this.oprot_;
    }

    public void create_namespace(String ns) throws ClientException, TException
    {
      send_create_namespace(ns);
      recv_create_namespace();
    }

    public void send_create_namespace(String ns) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("create_namespace", TMessageType.CALL, ++seqid_));
      create_namespace_args args = new create_namespace_args();
      args.setNs(ns);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_create_namespace() throws ClientException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "create_namespace failed: out of sequence response");
      }
      create_namespace_result result = new create_namespace_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.e != null) {
        throw result.e;
      }
      return;
    }

    public void create_table(long ns, String table_name, String schema) throws ClientException, TException
    {
      send_create_table(ns, table_name, schema);
      recv_create_table();
    }

    public void send_create_table(long ns, String table_name, String schema) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("create_table", TMessageType.CALL, ++seqid_));
      create_table_args args = new create_table_args();
      args.setNs(ns);
      args.setTable_name(table_name);
      args.setSchema(schema);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_create_table() throws ClientException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "create_table failed: out of sequence response");
      }
      create_table_result result = new create_table_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.e != null) {
        throw result.e;
      }
      return;
    }

    public long open_namespace(String ns) throws ClientException, TException
    {
      send_open_namespace(ns);
      return recv_open_namespace();
    }

    public void send_open_namespace(String ns) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("open_namespace", TMessageType.CALL, ++seqid_));
      open_namespace_args args = new open_namespace_args();
      args.setNs(ns);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public long recv_open_namespace() throws ClientException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "open_namespace failed: out of sequence response");
      }
      open_namespace_result result = new open_namespace_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.e != null) {
        throw result.e;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "open_namespace failed: unknown result");
    }

    public void close_namespace(long ns) throws ClientException, TException
    {
      send_close_namespace(ns);
      recv_close_namespace();
    }

    public void send_close_namespace(long ns) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("close_namespace", TMessageType.CALL, ++seqid_));
      close_namespace_args args = new close_namespace_args();
      args.setNs(ns);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_close_namespace() throws ClientException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "close_namespace failed: out of sequence response");
      }
      close_namespace_result result = new close_namespace_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.e != null) {
        throw result.e;
      }
      return;
    }

    public long open_future(int queue_size) throws ClientException, TException
    {
      send_open_future(queue_size);
      return recv_open_future();
    }

    public void send_open_future(int queue_size) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("open_future", TMessageType.CALL, ++seqid_));
      open_future_args args = new open_future_args();
      args.setQueue_size(queue_size);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public long recv_open_future() throws ClientException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "open_future failed: out of sequence response");
      }
      open_future_result result = new open_future_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.e != null) {
        throw result.e;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "open_future failed: unknown result");
    }

    public Result get_future_result(long ff) throws ClientException, TException
    {
      send_get_future_result(ff);
      return recv_get_future_result();
    }

    public void send_get_future_result(long ff) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("get_future_result", TMessageType.CALL, ++seqid_));
      get_future_result_args args = new get_future_result_args();
      args.setFf(ff);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public Result recv_get_future_result() throws ClientException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "get_future_result failed: out of sequence response");
      }
      get_future_result_result result = new get_future_result_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.e != null) {
        throw result.e;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_future_result failed: unknown result");
    }

    public ResultAsArrays get_future_result_as_arrays(long ff) throws ClientException, TException
    {
      send_get_future_result_as_arrays(ff);
      return recv_get_future_result_as_arrays();
    }

    public void send_get_future_result_as_arrays(long ff) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("get_future_result_as_arrays", TMessageType.CALL, ++seqid_));
      get_future_result_as_arrays_args args = new get_future_result_as_arrays_args();
      args.setFf(ff);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public ResultAsArrays recv_get_future_result_as_arrays() throws ClientException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "get_future_result_as_arrays failed: out of sequence response");
      }
      get_future_result_as_arrays_result result = new get_future_result_as_arrays_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.e != null) {
        throw result.e;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_future_result_as_arrays failed: unknown result");
    }

    public ResultSerialized get_future_result_serialized(long ff) throws ClientException, TException
    {
      send_get_future_result_serialized(ff);
      return recv_get_future_result_serialized();
    }

    public void send_get_future_result_serialized(long ff) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("get_future_result_serialized", TMessageType.CALL, ++seqid_));
      get_future_result_serialized_args args = new get_future_result_serialized_args();
      args.setFf(ff);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public ResultSerialized recv_get_future_result_serialized() throws ClientException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "get_future_result_serialized failed: out of sequence response");
      }
      get_future_result_serialized_result result = new get_future_result_serialized_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.e != null) {
        throw result.e;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_future_result_serialized failed: unknown result");
    }

    public void close_future(long ff) throws ClientException, TException
    {
      send_close_future(ff);
      recv_close_future();
    }

    public void send_close_future(long ff) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("close_future", TMessageType.CALL, ++seqid_));
      close_future_args args = new close_future_args();
      args.setFf(ff);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_close_future() throws ClientException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "close_future failed: out of sequence response");
      }
      close_future_result result = new close_future_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.e != null) {
        throw result.e;
      }
      return;
    }

    public long open_scanner(long ns, String table_name, ScanSpec scan_spec, boolean retry_table_not_found) throws ClientException, TException
    {
      send_open_scanner(ns, table_name, scan_spec, retry_table_not_found);
      return recv_open_scanner();
    }

    public void send_open_scanner(long ns, String table_name, ScanSpec scan_spec, boolean retry_table_not_found) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("open_scanner", TMessageType.CALL, ++seqid_));
      open_scanner_args args = new open_scanner_args();
      args.setNs(ns);
      args.setTable_name(table_name);
      args.setScan_spec(scan_spec);
      args.setRetry_table_not_found(retry_table_not_found);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public long recv_open_scanner() throws ClientException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "open_scanner failed: out of sequence response");
      }
      open_scanner_result result = new open_scanner_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.e != null) {
        throw result.e;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "open_scanner failed: unknown result");
    }

    public long open_scanner_async(long ns, String table_name, long future, ScanSpec scan_spec, boolean retry_table_not_found) throws ClientException, TException
    {
      send_open_scanner_async(ns, table_name, future, scan_spec, retry_table_not_found);
      return recv_open_scanner_async();
    }

    public void send_open_scanner_async(long ns, String table_name, long future, ScanSpec scan_spec, boolean retry_table_not_found) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("open_scanner_async", TMessageType.CALL, ++seqid_));
      open_scanner_async_args args = new open_scanner_async_args();
      args.setNs(ns);
      args.setTable_name(table_name);
      args.setFuture(future);
      args.setScan_spec(scan_spec);
      args.setRetry_table_not_found(retry_table_not_found);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public long recv_open_scanner_async() throws ClientException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "open_scanner_async failed: out of sequence response");
      }
      open_scanner_async_result result = new open_scanner_async_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.e != null) {
        throw result.e;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "open_scanner_async failed: unknown result");
    }

    public void close_scanner(long scanner) throws ClientException, TException
    {
      send_close_scanner(scanner);
      recv_close_scanner();
    }

    public void send_close_scanner(long scanner) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("close_scanner", TMessageType.CALL, ++seqid_));
      close_scanner_args args = new close_scanner_args();
      args.setScanner(scanner);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_close_scanner() throws ClientException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "close_scanner failed: out of sequence response");
      }
      close_scanner_result result = new close_scanner_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.e != null) {
        throw result.e;
      }
      return;
    }

    public void close_scanner_async(long scanner) throws ClientException, TException
    {
      send_close_scanner_async(scanner);
      recv_close_scanner_async();
    }

    public void send_close_scanner_async(long scanner) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("close_scanner_async", TMessageType.CALL, ++seqid_));
      close_scanner_async_args args = new close_scanner_async_args();
      args.setScanner(scanner);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_close_scanner_async() throws ClientException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "close_scanner_async failed: out of sequence response");
      }
      close_scanner_async_result result = new close_scanner_async_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.e != null) {
        throw result.e;
      }
      return;
    }

    public List<Cell> next_cells(long scanner) throws ClientException, TException
    {
      send_next_cells(scanner);
      return recv_next_cells();
    }

    public void send_next_cells(long scanner) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("next_cells", TMessageType.CALL, ++seqid_));
      next_cells_args args = new next_cells_args();
      args.setScanner(scanner);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<Cell> recv_next_cells() throws ClientException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "next_cells failed: out of sequence response");
      }
      next_cells_result result = new next_cells_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.e != null) {
        throw result.e;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "next_cells failed: unknown result");
    }

    public List<List<String>> next_cells_as_arrays(long scanner) throws ClientException, TException
    {
      send_next_cells_as_arrays(scanner);
      return recv_next_cells_as_arrays();
    }

    public void send_next_cells_as_arrays(long scanner) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("next_cells_as_arrays", TMessageType.CALL, ++seqid_));
      next_cells_as_arrays_args args = new next_cells_as_arrays_args();
      args.setScanner(scanner);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<List<String>> recv_next_cells_as_arrays() throws ClientException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "next_cells_as_arrays failed: out of sequence response");
      }
      next_cells_as_arrays_result result = new next_cells_as_arrays_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.e != null) {
        throw result.e;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "next_cells_as_arrays failed: unknown result");
    }

    public ByteBuffer next_cells_serialized(long scanner) throws TException
    {
      send_next_cells_serialized(scanner);
      return recv_next_cells_serialized();
    }

    public void send_next_cells_serialized(long scanner) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("next_cells_serialized", TMessageType.CALL, ++seqid_));
      next_cells_serialized_args args = new next_cells_serialized_args();
      args.setScanner(scanner);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public ByteBuffer recv_next_cells_serialized() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "next_cells_serialized failed: out of sequence response");
      }
      next_cells_serialized_result result = new next_cells_serialized_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "next_cells_serialized failed: unknown result");
    }

    public List<Cell> next_row(long scanner) throws ClientException, TException
    {
      send_next_row(scanner);
      return recv_next_row();
    }

    public void send_next_row(long scanner) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("next_row", TMessageType.CALL, ++seqid_));
      next_row_args args = new next_row_args();
      args.setScanner(scanner);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<Cell> recv_next_row() throws ClientException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "next_row failed: out of sequence response");
      }
      next_row_result result = new next_row_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.e != null) {
        throw result.e;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "next_row failed: unknown result");
    }

    public List<List<String>> next_row_as_arrays(long scanner) throws ClientException, TException
    {
      send_next_row_as_arrays(scanner);
      return recv_next_row_as_arrays();
    }

    public void send_next_row_as_arrays(long scanner) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("next_row_as_arrays", TMessageType.CALL, ++seqid_));
      next_row_as_arrays_args args = new next_row_as_arrays_args();
      args.setScanner(scanner);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<List<String>> recv_next_row_as_arrays() throws ClientException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "next_row_as_arrays failed: out of sequence response");
      }
      next_row_as_arrays_result result = new next_row_as_arrays_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.e != null) {
        throw result.e;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "next_row_as_arrays failed: unknown result");
    }

    public ByteBuffer next_row_serialized(long scanner) throws ClientException, TException
    {
      send_next_row_serialized(scanner);
      return recv_next_row_serialized();
    }

    public void send_next_row_serialized(long scanner) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("next_row_serialized", TMessageType.CALL, ++seqid_));
      next_row_serialized_args args = new next_row_serialized_args();
      args.setScanner(scanner);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public ByteBuffer recv_next_row_serialized() throws ClientException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "next_row_serialized failed: out of sequence response");
      }
      next_row_serialized_result result = new next_row_serialized_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.e != null) {
        throw result.e;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "next_row_serialized failed: unknown result");
    }

    public List<Cell> get_row(long ns, String table_name, String row) throws ClientException, TException
    {
      send_get_row(ns, table_name, row);
      return recv_get_row();
    }

    public void send_get_row(long ns, String table_name, String row) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("get_row", TMessageType.CALL, ++seqid_));
      get_row_args args = new get_row_args();
      args.setNs(ns);
      args.setTable_name(table_name);
      args.setRow(row);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<Cell> recv_get_row() throws ClientException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "get_row failed: out of sequence response");
      }
      get_row_result result = new get_row_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.e != null) {
        throw result.e;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_row failed: unknown result");
    }

    public List<List<String>> get_row_as_arrays(long ns, String name, String row) throws ClientException, TException
    {
      send_get_row_as_arrays(ns, name, row);
      return recv_get_row_as_arrays();
    }

    public void send_get_row_as_arrays(long ns, String name, String row) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("get_row_as_arrays", TMessageType.CALL, ++seqid_));
      get_row_as_arrays_args args = new get_row_as_arrays_args();
      args.setNs(ns);
      args.setName(name);
      args.setRow(row);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<List<String>> recv_get_row_as_arrays() throws ClientException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "get_row_as_arrays failed: out of sequence response");
      }
      get_row_as_arrays_result result = new get_row_as_arrays_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.e != null) {
        throw result.e;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_row_as_arrays failed: unknown result");
    }

    public ByteBuffer get_row_serialized(long ns, String table_name, String row) throws ClientException, TException
    {
      send_get_row_serialized(ns, table_name, row);
      return recv_get_row_serialized();
    }

    public void send_get_row_serialized(long ns, String table_name, String row) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("get_row_serialized", TMessageType.CALL, ++seqid_));
      get_row_serialized_args args = new get_row_serialized_args();
      args.setNs(ns);
      args.setTable_name(table_name);
      args.setRow(row);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public ByteBuffer recv_get_row_serialized() throws ClientException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "get_row_serialized failed: out of sequence response");
      }
      get_row_serialized_result result = new get_row_serialized_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.e != null) {
        throw result.e;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_row_serialized failed: unknown result");
    }

    public ByteBuffer get_cell(long ns, String table_name, String row, String column) throws ClientException, TException
    {
      send_get_cell(ns, table_name, row, column);
      return recv_get_cell();
    }

    public void send_get_cell(long ns, String table_name, String row, String column) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("get_cell", TMessageType.CALL, ++seqid_));
      get_cell_args args = new get_cell_args();
      args.setNs(ns);
      args.setTable_name(table_name);
      args.setRow(row);
      args.setColumn(column);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public ByteBuffer recv_get_cell() throws ClientException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "get_cell failed: out of sequence response");
      }
      get_cell_result result = new get_cell_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.e != null) {
        throw result.e;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_cell failed: unknown result");
    }

    public List<Cell> get_cells(long ns, String table_name, ScanSpec scan_spec) throws ClientException, TException
    {
      send_get_cells(ns, table_name, scan_spec);
      return recv_get_cells();
    }

    public void send_get_cells(long ns, String table_name, ScanSpec scan_spec) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("get_cells", TMessageType.CALL, ++seqid_));
      get_cells_args args = new get_cells_args();
      args.setNs(ns);
      args.setTable_name(table_name);
      args.setScan_spec(scan_spec);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<Cell> recv_get_cells() throws ClientException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "get_cells failed: out of sequence response");
      }
      get_cells_result result = new get_cells_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.e != null) {
        throw result.e;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_cells failed: unknown result");
    }

    public List<List<String>> get_cells_as_arrays(long ns, String name, ScanSpec scan_spec) throws ClientException, TException
    {
      send_get_cells_as_arrays(ns, name, scan_spec);
      return recv_get_cells_as_arrays();
    }

    public void send_get_cells_as_arrays(long ns, String name, ScanSpec scan_spec) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("get_cells_as_arrays", TMessageType.CALL, ++seqid_));
      get_cells_as_arrays_args args = new get_cells_as_arrays_args();
      args.setNs(ns);
      args.setName(name);
      args.setScan_spec(scan_spec);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<List<String>> recv_get_cells_as_arrays() throws ClientException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "get_cells_as_arrays failed: out of sequence response");
      }
      get_cells_as_arrays_result result = new get_cells_as_arrays_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.e != null) {
        throw result.e;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_cells_as_arrays failed: unknown result");
    }

    public ByteBuffer get_cells_serialized(long ns, String name, ScanSpec scan_spec) throws ClientException, TException
    {
      send_get_cells_serialized(ns, name, scan_spec);
      return recv_get_cells_serialized();
    }

    public void send_get_cells_serialized(long ns, String name, ScanSpec scan_spec) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("get_cells_serialized", TMessageType.CALL, ++seqid_));
      get_cells_serialized_args args = new get_cells_serialized_args();
      args.setNs(ns);
      args.setName(name);
      args.setScan_spec(scan_spec);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public ByteBuffer recv_get_cells_serialized() throws ClientException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "get_cells_serialized failed: out of sequence response");
      }
      get_cells_serialized_result result = new get_cells_serialized_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.e != null) {
        throw result.e;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_cells_serialized failed: unknown result");
    }

    public void refresh_shared_mutator(long ns, String table_name, MutateSpec mutate_spec) throws ClientException, TException
    {
      send_refresh_shared_mutator(ns, table_name, mutate_spec);
      recv_refresh_shared_mutator();
    }

    public void send_refresh_shared_mutator(long ns, String table_name, MutateSpec mutate_spec) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("refresh_shared_mutator", TMessageType.CALL, ++seqid_));
      refresh_shared_mutator_args args = new refresh_shared_mutator_args();
      args.setNs(ns);
      args.setTable_name(table_name);
      args.setMutate_spec(mutate_spec);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_refresh_shared_mutator() throws ClientException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "refresh_shared_mutator failed: out of sequence response");
      }
      refresh_shared_mutator_result result = new refresh_shared_mutator_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.e != null) {
        throw result.e;
      }
      return;
    }

    public void offer_cells(long ns, String table_name, MutateSpec mutate_spec, List<Cell> cells) throws ClientException, TException
    {
      send_offer_cells(ns, table_name, mutate_spec, cells);
      recv_offer_cells();
    }

    public void send_offer_cells(long ns, String table_name, MutateSpec mutate_spec, List<Cell> cells) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("offer_cells", TMessageType.CALL, ++seqid_));
      offer_cells_args args = new offer_cells_args();
      args.setNs(ns);
      args.setTable_name(table_name);
      args.setMutate_spec(mutate_spec);
      args.setCells(cells);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_offer_cells() throws ClientException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "offer_cells failed: out of sequence response");
      }
      offer_cells_result result = new offer_cells_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.e != null) {
        throw result.e;
      }
      return;
    }

    public void offer_cells_as_arrays(long ns, String table_name, MutateSpec mutate_spec, List<List<String>> cells) throws ClientException, TException
    {
      send_offer_cells_as_arrays(ns, table_name, mutate_spec, cells);
      recv_offer_cells_as_arrays();
    }

    public void send_offer_cells_as_arrays(long ns, String table_name, MutateSpec mutate_spec, List<List<String>> cells) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("offer_cells_as_arrays", TMessageType.CALL, ++seqid_));
      offer_cells_as_arrays_args args = new offer_cells_as_arrays_args();
      args.setNs(ns);
      args.setTable_name(table_name);
      args.setMutate_spec(mutate_spec);
      args.setCells(cells);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_offer_cells_as_arrays() throws ClientException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "offer_cells_as_arrays failed: out of sequence response");
      }
      offer_cells_as_arrays_result result = new offer_cells_as_arrays_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.e != null) {
        throw result.e;
      }
      return;
    }

    public void offer_cell(long ns, String table_name, MutateSpec mutate_spec, Cell cell) throws ClientException, TException
    {
      send_offer_cell(ns, table_name, mutate_spec, cell);
      recv_offer_cell();
    }

    public void send_offer_cell(long ns, String table_name, MutateSpec mutate_spec, Cell cell) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("offer_cell", TMessageType.CALL, ++seqid_));
      offer_cell_args args = new offer_cell_args();
      args.setNs(ns);
      args.setTable_name(table_name);
      args.setMutate_spec(mutate_spec);
      args.setCell(cell);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_offer_cell() throws ClientException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "offer_cell failed: out of sequence response");
      }
      offer_cell_result result = new offer_cell_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.e != null) {
        throw result.e;
      }
      return;
    }

    public void offer_cell_as_array(long ns, String table_name, MutateSpec mutate_spec, List<String> cell) throws ClientException, TException
    {
      send_offer_cell_as_array(ns, table_name, mutate_spec, cell);
      recv_offer_cell_as_array();
    }

    public void send_offer_cell_as_array(long ns, String table_name, MutateSpec mutate_spec, List<String> cell) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("offer_cell_as_array", TMessageType.CALL, ++seqid_));
      offer_cell_as_array_args args = new offer_cell_as_array_args();
      args.setNs(ns);
      args.setTable_name(table_name);
      args.setMutate_spec(mutate_spec);
      args.setCell(cell);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_offer_cell_as_array() throws ClientException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "offer_cell_as_array failed: out of sequence response");
      }
      offer_cell_as_array_result result = new offer_cell_as_array_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.e != null) {
        throw result.e;
      }
      return;
    }

    public long open_mutator(long ns, String table_name, int flags, int flush_interval) throws ClientException, TException
    {
      send_open_mutator(ns, table_name, flags, flush_interval);
      return recv_open_mutator();
    }

    public void send_open_mutator(long ns, String table_name, int flags, int flush_interval) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("open_mutator", TMessageType.CALL, ++seqid_));
      open_mutator_args args = new open_mutator_args();
      args.setNs(ns);
      args.setTable_name(table_name);
      args.setFlags(flags);
      args.setFlush_interval(flush_interval);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public long recv_open_mutator() throws ClientException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "open_mutator failed: out of sequence response");
      }
      open_mutator_result result = new open_mutator_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.e != null) {
        throw result.e;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "open_mutator failed: unknown result");
    }

    public void close_mutator(long mutator, boolean flush) throws ClientException, TException
    {
      send_close_mutator(mutator, flush);
      recv_close_mutator();
    }

    public void send_close_mutator(long mutator, boolean flush) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("close_mutator", TMessageType.CALL, ++seqid_));
      close_mutator_args args = new close_mutator_args();
      args.setMutator(mutator);
      args.setFlush(flush);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_close_mutator() throws ClientException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "close_mutator failed: out of sequence response");
      }
      close_mutator_result result = new close_mutator_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.e != null) {
        throw result.e;
      }
      return;
    }

    public void set_cell(long mutator, Cell cell) throws ClientException, TException
    {
      send_set_cell(mutator, cell);
      recv_set_cell();
    }

    public void send_set_cell(long mutator, Cell cell) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("set_cell", TMessageType.CALL, ++seqid_));
      set_cell_args args = new set_cell_args();
      args.setMutator(mutator);
      args.setCell(cell);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_set_cell() throws ClientException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "set_cell failed: out of sequence response");
      }
      set_cell_result result = new set_cell_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.e != null) {
        throw result.e;
      }
      return;
    }

    public void set_cell_as_array(long mutator, List<String> cell) throws ClientException, TException
    {
      send_set_cell_as_array(mutator, cell);
      recv_set_cell_as_array();
    }

    public void send_set_cell_as_array(long mutator, List<String> cell) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("set_cell_as_array", TMessageType.CALL, ++seqid_));
      set_cell_as_array_args args = new set_cell_as_array_args();
      args.setMutator(mutator);
      args.setCell(cell);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_set_cell_as_array() throws ClientException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "set_cell_as_array failed: out of sequence response");
      }
      set_cell_as_array_result result = new set_cell_as_array_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.e != null) {
        throw result.e;
      }
      return;
    }

    public void set_cells(long mutator, List<Cell> cells) throws ClientException, TException
    {
      send_set_cells(mutator, cells);
      recv_set_cells();
    }

    public void send_set_cells(long mutator, List<Cell> cells) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("set_cells", TMessageType.CALL, ++seqid_));
      set_cells_args args = new set_cells_args();
      args.setMutator(mutator);
      args.setCells(cells);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_set_cells() throws ClientException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "set_cells failed: out of sequence response");
      }
      set_cells_result result = new set_cells_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.e != null) {
        throw result.e;
      }
      return;
    }

    public void set_cells_as_arrays(long mutator, List<List<String>> cells) throws ClientException, TException
    {
      send_set_cells_as_arrays(mutator, cells);
      recv_set_cells_as_arrays();
    }

    public void send_set_cells_as_arrays(long mutator, List<List<String>> cells) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("set_cells_as_arrays", TMessageType.CALL, ++seqid_));
      set_cells_as_arrays_args args = new set_cells_as_arrays_args();
      args.setMutator(mutator);
      args.setCells(cells);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_set_cells_as_arrays() throws ClientException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "set_cells_as_arrays failed: out of sequence response");
      }
      set_cells_as_arrays_result result = new set_cells_as_arrays_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.e != null) {
        throw result.e;
      }
      return;
    }

    public void set_cells_serialized(long mutator, ByteBuffer cells, boolean flush) throws ClientException, TException
    {
      send_set_cells_serialized(mutator, cells, flush);
      recv_set_cells_serialized();
    }

    public void send_set_cells_serialized(long mutator, ByteBuffer cells, boolean flush) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("set_cells_serialized", TMessageType.CALL, ++seqid_));
      set_cells_serialized_args args = new set_cells_serialized_args();
      args.setMutator(mutator);
      args.setCells(cells);
      args.setFlush(flush);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_set_cells_serialized() throws ClientException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "set_cells_serialized failed: out of sequence response");
      }
      set_cells_serialized_result result = new set_cells_serialized_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.e != null) {
        throw result.e;
      }
      return;
    }

    public void flush_mutator(long mutator) throws ClientException, TException
    {
      send_flush_mutator(mutator);
      recv_flush_mutator();
    }

    public void send_flush_mutator(long mutator) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("flush_mutator", TMessageType.CALL, ++seqid_));
      flush_mutator_args args = new flush_mutator_args();
      args.setMutator(mutator);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_flush_mutator() throws ClientException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "flush_mutator failed: out of sequence response");
      }
      flush_mutator_result result = new flush_mutator_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.e != null) {
        throw result.e;
      }
      return;
    }

    public boolean exists_namespace(String ns) throws ClientException, TException
    {
      send_exists_namespace(ns);
      return recv_exists_namespace();
    }

    public void send_exists_namespace(String ns) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("exists_namespace", TMessageType.CALL, ++seqid_));
      exists_namespace_args args = new exists_namespace_args();
      args.setNs(ns);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public boolean recv_exists_namespace() throws ClientException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "exists_namespace failed: out of sequence response");
      }
      exists_namespace_result result = new exists_namespace_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.e != null) {
        throw result.e;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "exists_namespace failed: unknown result");
    }

    public boolean exists_table(long ns, String name) throws ClientException, TException
    {
      send_exists_table(ns, name);
      return recv_exists_table();
    }

    public void send_exists_table(long ns, String name) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("exists_table", TMessageType.CALL, ++seqid_));
      exists_table_args args = new exists_table_args();
      args.setNs(ns);
      args.setName(name);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public boolean recv_exists_table() throws ClientException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "exists_table failed: out of sequence response");
      }
      exists_table_result result = new exists_table_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.e != null) {
        throw result.e;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "exists_table failed: unknown result");
    }

    public String get_table_id(long ns, String table_name) throws ClientException, TException
    {
      send_get_table_id(ns, table_name);
      return recv_get_table_id();
    }

    public void send_get_table_id(long ns, String table_name) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("get_table_id", TMessageType.CALL, ++seqid_));
      get_table_id_args args = new get_table_id_args();
      args.setNs(ns);
      args.setTable_name(table_name);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public String recv_get_table_id() throws ClientException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "get_table_id failed: out of sequence response");
      }
      get_table_id_result result = new get_table_id_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.e != null) {
        throw result.e;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_table_id failed: unknown result");
    }

    public String get_schema_str(long ns, String table_name) throws ClientException, TException
    {
      send_get_schema_str(ns, table_name);
      return recv_get_schema_str();
    }

    public void send_get_schema_str(long ns, String table_name) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("get_schema_str", TMessageType.CALL, ++seqid_));
      get_schema_str_args args = new get_schema_str_args();
      args.setNs(ns);
      args.setTable_name(table_name);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public String recv_get_schema_str() throws ClientException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "get_schema_str failed: out of sequence response");
      }
      get_schema_str_result result = new get_schema_str_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.e != null) {
        throw result.e;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_schema_str failed: unknown result");
    }

    public Schema get_schema(long ns, String table_name) throws ClientException, TException
    {
      send_get_schema(ns, table_name);
      return recv_get_schema();
    }

    public void send_get_schema(long ns, String table_name) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("get_schema", TMessageType.CALL, ++seqid_));
      get_schema_args args = new get_schema_args();
      args.setNs(ns);
      args.setTable_name(table_name);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public Schema recv_get_schema() throws ClientException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "get_schema failed: out of sequence response");
      }
      get_schema_result result = new get_schema_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.e != null) {
        throw result.e;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_schema failed: unknown result");
    }

    public List<String> get_tables(long ns) throws ClientException, TException
    {
      send_get_tables(ns);
      return recv_get_tables();
    }

    public void send_get_tables(long ns) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("get_tables", TMessageType.CALL, ++seqid_));
      get_tables_args args = new get_tables_args();
      args.setNs(ns);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<String> recv_get_tables() throws ClientException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "get_tables failed: out of sequence response");
      }
      get_tables_result result = new get_tables_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.e != null) {
        throw result.e;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_tables failed: unknown result");
    }

    public List<NamespaceListing> get_listing(long ns) throws ClientException, TException
    {
      send_get_listing(ns);
      return recv_get_listing();
    }

    public void send_get_listing(long ns) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("get_listing", TMessageType.CALL, ++seqid_));
      get_listing_args args = new get_listing_args();
      args.setNs(ns);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<NamespaceListing> recv_get_listing() throws ClientException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "get_listing failed: out of sequence response");
      }
      get_listing_result result = new get_listing_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.e != null) {
        throw result.e;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_listing failed: unknown result");
    }

    public List<TableSplit> get_table_splits(long ns, String table_name) throws ClientException, TException
    {
      send_get_table_splits(ns, table_name);
      return recv_get_table_splits();
    }

    public void send_get_table_splits(long ns, String table_name) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("get_table_splits", TMessageType.CALL, ++seqid_));
      get_table_splits_args args = new get_table_splits_args();
      args.setNs(ns);
      args.setTable_name(table_name);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<TableSplit> recv_get_table_splits() throws ClientException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "get_table_splits failed: out of sequence response");
      }
      get_table_splits_result result = new get_table_splits_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.e != null) {
        throw result.e;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_table_splits failed: unknown result");
    }

    public void drop_namespace(String ns, boolean if_exists) throws ClientException, TException
    {
      send_drop_namespace(ns, if_exists);
      recv_drop_namespace();
    }

    public void send_drop_namespace(String ns, boolean if_exists) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("drop_namespace", TMessageType.CALL, ++seqid_));
      drop_namespace_args args = new drop_namespace_args();
      args.setNs(ns);
      args.setIf_exists(if_exists);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_drop_namespace() throws ClientException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "drop_namespace failed: out of sequence response");
      }
      drop_namespace_result result = new drop_namespace_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.e != null) {
        throw result.e;
      }
      return;
    }

    public void rename_table(long ns, String name, String new_name) throws ClientException, TException
    {
      send_rename_table(ns, name, new_name);
      recv_rename_table();
    }

    public void send_rename_table(long ns, String name, String new_name) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("rename_table", TMessageType.CALL, ++seqid_));
      rename_table_args args = new rename_table_args();
      args.setNs(ns);
      args.setName(name);
      args.setNew_name(new_name);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_rename_table() throws ClientException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "rename_table failed: out of sequence response");
      }
      rename_table_result result = new rename_table_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.e != null) {
        throw result.e;
      }
      return;
    }

    public void drop_table(long ns, String name, boolean if_exists) throws ClientException, TException
    {
      send_drop_table(ns, name, if_exists);
      recv_drop_table();
    }

    public void send_drop_table(long ns, String name, boolean if_exists) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("drop_table", TMessageType.CALL, ++seqid_));
      drop_table_args args = new drop_table_args();
      args.setNs(ns);
      args.setName(name);
      args.setIf_exists(if_exists);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_drop_table() throws ClientException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "drop_table failed: out of sequence response");
      }
      drop_table_result result = new drop_table_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.e != null) {
        throw result.e;
      }
      return;
    }

  }
  public static class AsyncClient extends TAsyncClient implements AsyncIface {
    public static class Factory implements TAsyncClientFactory<AsyncClient> {
      private TAsyncClientManager clientManager;
      private TProtocolFactory protocolFactory;
      public Factory(TAsyncClientManager clientManager, TProtocolFactory protocolFactory) {
        this.clientManager = clientManager;
        this.protocolFactory = protocolFactory;
      }
      public AsyncClient getAsyncClient(TNonblockingTransport transport) {
        return new AsyncClient(protocolFactory, clientManager, transport);
      }
    }

    public AsyncClient(TProtocolFactory protocolFactory, TAsyncClientManager clientManager, TNonblockingTransport transport) {
      super(protocolFactory, clientManager, transport);
    }

    public void create_namespace(String ns, AsyncMethodCallback<create_namespace_call> resultHandler) throws TException {
      checkReady();
      create_namespace_call method_call = new create_namespace_call(ns, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class create_namespace_call extends TAsyncMethodCall {
      private String ns;
      public create_namespace_call(String ns, AsyncMethodCallback<create_namespace_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.ns = ns;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("create_namespace", TMessageType.CALL, 0));
        create_namespace_args args = new create_namespace_args();
        args.setNs(ns);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws ClientException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_create_namespace();
      }
    }

    public void create_table(long ns, String table_name, String schema, AsyncMethodCallback<create_table_call> resultHandler) throws TException {
      checkReady();
      create_table_call method_call = new create_table_call(ns, table_name, schema, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class create_table_call extends TAsyncMethodCall {
      private long ns;
      private String table_name;
      private String schema;
      public create_table_call(long ns, String table_name, String schema, AsyncMethodCallback<create_table_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.ns = ns;
        this.table_name = table_name;
        this.schema = schema;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("create_table", TMessageType.CALL, 0));
        create_table_args args = new create_table_args();
        args.setNs(ns);
        args.setTable_name(table_name);
        args.setSchema(schema);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws ClientException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_create_table();
      }
    }

    public void open_namespace(String ns, AsyncMethodCallback<open_namespace_call> resultHandler) throws TException {
      checkReady();
      open_namespace_call method_call = new open_namespace_call(ns, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class open_namespace_call extends TAsyncMethodCall {
      private String ns;
      public open_namespace_call(String ns, AsyncMethodCallback<open_namespace_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.ns = ns;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("open_namespace", TMessageType.CALL, 0));
        open_namespace_args args = new open_namespace_args();
        args.setNs(ns);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public long getResult() throws ClientException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_open_namespace();
      }
    }

    public void close_namespace(long ns, AsyncMethodCallback<close_namespace_call> resultHandler) throws TException {
      checkReady();
      close_namespace_call method_call = new close_namespace_call(ns, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class close_namespace_call extends TAsyncMethodCall {
      private long ns;
      public close_namespace_call(long ns, AsyncMethodCallback<close_namespace_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.ns = ns;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("close_namespace", TMessageType.CALL, 0));
        close_namespace_args args = new close_namespace_args();
        args.setNs(ns);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws ClientException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_close_namespace();
      }
    }

    public void open_future(int queue_size, AsyncMethodCallback<open_future_call> resultHandler) throws TException {
      checkReady();
      open_future_call method_call = new open_future_call(queue_size, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class open_future_call extends TAsyncMethodCall {
      private int queue_size;
      public open_future_call(int queue_size, AsyncMethodCallback<open_future_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.queue_size = queue_size;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("open_future", TMessageType.CALL, 0));
        open_future_args args = new open_future_args();
        args.setQueue_size(queue_size);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public long getResult() throws ClientException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_open_future();
      }
    }

    public void get_future_result(long ff, AsyncMethodCallback<get_future_result_call> resultHandler) throws TException {
      checkReady();
      get_future_result_call method_call = new get_future_result_call(ff, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class get_future_result_call extends TAsyncMethodCall {
      private long ff;
      public get_future_result_call(long ff, AsyncMethodCallback<get_future_result_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.ff = ff;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("get_future_result", TMessageType.CALL, 0));
        get_future_result_args args = new get_future_result_args();
        args.setFf(ff);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public Result getResult() throws ClientException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_get_future_result();
      }
    }

    public void get_future_result_as_arrays(long ff, AsyncMethodCallback<get_future_result_as_arrays_call> resultHandler) throws TException {
      checkReady();
      get_future_result_as_arrays_call method_call = new get_future_result_as_arrays_call(ff, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class get_future_result_as_arrays_call extends TAsyncMethodCall {
      private long ff;
      public get_future_result_as_arrays_call(long ff, AsyncMethodCallback<get_future_result_as_arrays_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.ff = ff;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("get_future_result_as_arrays", TMessageType.CALL, 0));
        get_future_result_as_arrays_args args = new get_future_result_as_arrays_args();
        args.setFf(ff);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ResultAsArrays getResult() throws ClientException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_get_future_result_as_arrays();
      }
    }

    public void get_future_result_serialized(long ff, AsyncMethodCallback<get_future_result_serialized_call> resultHandler) throws TException {
      checkReady();
      get_future_result_serialized_call method_call = new get_future_result_serialized_call(ff, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class get_future_result_serialized_call extends TAsyncMethodCall {
      private long ff;
      public get_future_result_serialized_call(long ff, AsyncMethodCallback<get_future_result_serialized_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.ff = ff;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("get_future_result_serialized", TMessageType.CALL, 0));
        get_future_result_serialized_args args = new get_future_result_serialized_args();
        args.setFf(ff);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ResultSerialized getResult() throws ClientException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_get_future_result_serialized();
      }
    }

    public void close_future(long ff, AsyncMethodCallback<close_future_call> resultHandler) throws TException {
      checkReady();
      close_future_call method_call = new close_future_call(ff, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class close_future_call extends TAsyncMethodCall {
      private long ff;
      public close_future_call(long ff, AsyncMethodCallback<close_future_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.ff = ff;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("close_future", TMessageType.CALL, 0));
        close_future_args args = new close_future_args();
        args.setFf(ff);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws ClientException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_close_future();
      }
    }

    public void open_scanner(long ns, String table_name, ScanSpec scan_spec, boolean retry_table_not_found, AsyncMethodCallback<open_scanner_call> resultHandler) throws TException {
      checkReady();
      open_scanner_call method_call = new open_scanner_call(ns, table_name, scan_spec, retry_table_not_found, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class open_scanner_call extends TAsyncMethodCall {
      private long ns;
      private String table_name;
      private ScanSpec scan_spec;
      private boolean retry_table_not_found;
      public open_scanner_call(long ns, String table_name, ScanSpec scan_spec, boolean retry_table_not_found, AsyncMethodCallback<open_scanner_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.ns = ns;
        this.table_name = table_name;
        this.scan_spec = scan_spec;
        this.retry_table_not_found = retry_table_not_found;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("open_scanner", TMessageType.CALL, 0));
        open_scanner_args args = new open_scanner_args();
        args.setNs(ns);
        args.setTable_name(table_name);
        args.setScan_spec(scan_spec);
        args.setRetry_table_not_found(retry_table_not_found);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public long getResult() throws ClientException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_open_scanner();
      }
    }

    public void open_scanner_async(long ns, String table_name, long future, ScanSpec scan_spec, boolean retry_table_not_found, AsyncMethodCallback<open_scanner_async_call> resultHandler) throws TException {
      checkReady();
      open_scanner_async_call method_call = new open_scanner_async_call(ns, table_name, future, scan_spec, retry_table_not_found, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class open_scanner_async_call extends TAsyncMethodCall {
      private long ns;
      private String table_name;
      private long future;
      private ScanSpec scan_spec;
      private boolean retry_table_not_found;
      public open_scanner_async_call(long ns, String table_name, long future, ScanSpec scan_spec, boolean retry_table_not_found, AsyncMethodCallback<open_scanner_async_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.ns = ns;
        this.table_name = table_name;
        this.future = future;
        this.scan_spec = scan_spec;
        this.retry_table_not_found = retry_table_not_found;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("open_scanner_async", TMessageType.CALL, 0));
        open_scanner_async_args args = new open_scanner_async_args();
        args.setNs(ns);
        args.setTable_name(table_name);
        args.setFuture(future);
        args.setScan_spec(scan_spec);
        args.setRetry_table_not_found(retry_table_not_found);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public long getResult() throws ClientException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_open_scanner_async();
      }
    }

    public void close_scanner(long scanner, AsyncMethodCallback<close_scanner_call> resultHandler) throws TException {
      checkReady();
      close_scanner_call method_call = new close_scanner_call(scanner, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class close_scanner_call extends TAsyncMethodCall {
      private long scanner;
      public close_scanner_call(long scanner, AsyncMethodCallback<close_scanner_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.scanner = scanner;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("close_scanner", TMessageType.CALL, 0));
        close_scanner_args args = new close_scanner_args();
        args.setScanner(scanner);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws ClientException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_close_scanner();
      }
    }

    public void close_scanner_async(long scanner, AsyncMethodCallback<close_scanner_async_call> resultHandler) throws TException {
      checkReady();
      close_scanner_async_call method_call = new close_scanner_async_call(scanner, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class close_scanner_async_call extends TAsyncMethodCall {
      private long scanner;
      public close_scanner_async_call(long scanner, AsyncMethodCallback<close_scanner_async_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.scanner = scanner;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("close_scanner_async", TMessageType.CALL, 0));
        close_scanner_async_args args = new close_scanner_async_args();
        args.setScanner(scanner);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws ClientException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_close_scanner_async();
      }
    }

    public void next_cells(long scanner, AsyncMethodCallback<next_cells_call> resultHandler) throws TException {
      checkReady();
      next_cells_call method_call = new next_cells_call(scanner, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class next_cells_call extends TAsyncMethodCall {
      private long scanner;
      public next_cells_call(long scanner, AsyncMethodCallback<next_cells_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.scanner = scanner;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("next_cells", TMessageType.CALL, 0));
        next_cells_args args = new next_cells_args();
        args.setScanner(scanner);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public List<Cell> getResult() throws ClientException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_next_cells();
      }
    }

    public void next_cells_as_arrays(long scanner, AsyncMethodCallback<next_cells_as_arrays_call> resultHandler) throws TException {
      checkReady();
      next_cells_as_arrays_call method_call = new next_cells_as_arrays_call(scanner, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class next_cells_as_arrays_call extends TAsyncMethodCall {
      private long scanner;
      public next_cells_as_arrays_call(long scanner, AsyncMethodCallback<next_cells_as_arrays_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.scanner = scanner;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("next_cells_as_arrays", TMessageType.CALL, 0));
        next_cells_as_arrays_args args = new next_cells_as_arrays_args();
        args.setScanner(scanner);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public List<List<String>> getResult() throws ClientException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_next_cells_as_arrays();
      }
    }

    public void next_cells_serialized(long scanner, AsyncMethodCallback<next_cells_serialized_call> resultHandler) throws TException {
      checkReady();
      next_cells_serialized_call method_call = new next_cells_serialized_call(scanner, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class next_cells_serialized_call extends TAsyncMethodCall {
      private long scanner;
      public next_cells_serialized_call(long scanner, AsyncMethodCallback<next_cells_serialized_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.scanner = scanner;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("next_cells_serialized", TMessageType.CALL, 0));
        next_cells_serialized_args args = new next_cells_serialized_args();
        args.setScanner(scanner);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ByteBuffer getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_next_cells_serialized();
      }
    }

    public void next_row(long scanner, AsyncMethodCallback<next_row_call> resultHandler) throws TException {
      checkReady();
      next_row_call method_call = new next_row_call(scanner, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class next_row_call extends TAsyncMethodCall {
      private long scanner;
      public next_row_call(long scanner, AsyncMethodCallback<next_row_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.scanner = scanner;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("next_row", TMessageType.CALL, 0));
        next_row_args args = new next_row_args();
        args.setScanner(scanner);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public List<Cell> getResult() throws ClientException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_next_row();
      }
    }

    public void next_row_as_arrays(long scanner, AsyncMethodCallback<next_row_as_arrays_call> resultHandler) throws TException {
      checkReady();
      next_row_as_arrays_call method_call = new next_row_as_arrays_call(scanner, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class next_row_as_arrays_call extends TAsyncMethodCall {
      private long scanner;
      public next_row_as_arrays_call(long scanner, AsyncMethodCallback<next_row_as_arrays_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.scanner = scanner;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("next_row_as_arrays", TMessageType.CALL, 0));
        next_row_as_arrays_args args = new next_row_as_arrays_args();
        args.setScanner(scanner);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public List<List<String>> getResult() throws ClientException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_next_row_as_arrays();
      }
    }

    public void next_row_serialized(long scanner, AsyncMethodCallback<next_row_serialized_call> resultHandler) throws TException {
      checkReady();
      next_row_serialized_call method_call = new next_row_serialized_call(scanner, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class next_row_serialized_call extends TAsyncMethodCall {
      private long scanner;
      public next_row_serialized_call(long scanner, AsyncMethodCallback<next_row_serialized_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.scanner = scanner;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("next_row_serialized", TMessageType.CALL, 0));
        next_row_serialized_args args = new next_row_serialized_args();
        args.setScanner(scanner);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ByteBuffer getResult() throws ClientException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_next_row_serialized();
      }
    }

    public void get_row(long ns, String table_name, String row, AsyncMethodCallback<get_row_call> resultHandler) throws TException {
      checkReady();
      get_row_call method_call = new get_row_call(ns, table_name, row, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class get_row_call extends TAsyncMethodCall {
      private long ns;
      private String table_name;
      private String row;
      public get_row_call(long ns, String table_name, String row, AsyncMethodCallback<get_row_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.ns = ns;
        this.table_name = table_name;
        this.row = row;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("get_row", TMessageType.CALL, 0));
        get_row_args args = new get_row_args();
        args.setNs(ns);
        args.setTable_name(table_name);
        args.setRow(row);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public List<Cell> getResult() throws ClientException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_get_row();
      }
    }

    public void get_row_as_arrays(long ns, String name, String row, AsyncMethodCallback<get_row_as_arrays_call> resultHandler) throws TException {
      checkReady();
      get_row_as_arrays_call method_call = new get_row_as_arrays_call(ns, name, row, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class get_row_as_arrays_call extends TAsyncMethodCall {
      private long ns;
      private String name;
      private String row;
      public get_row_as_arrays_call(long ns, String name, String row, AsyncMethodCallback<get_row_as_arrays_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.ns = ns;
        this.name = name;
        this.row = row;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("get_row_as_arrays", TMessageType.CALL, 0));
        get_row_as_arrays_args args = new get_row_as_arrays_args();
        args.setNs(ns);
        args.setName(name);
        args.setRow(row);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public List<List<String>> getResult() throws ClientException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_get_row_as_arrays();
      }
    }

    public void get_row_serialized(long ns, String table_name, String row, AsyncMethodCallback<get_row_serialized_call> resultHandler) throws TException {
      checkReady();
      get_row_serialized_call method_call = new get_row_serialized_call(ns, table_name, row, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class get_row_serialized_call extends TAsyncMethodCall {
      private long ns;
      private String table_name;
      private String row;
      public get_row_serialized_call(long ns, String table_name, String row, AsyncMethodCallback<get_row_serialized_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.ns = ns;
        this.table_name = table_name;
        this.row = row;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("get_row_serialized", TMessageType.CALL, 0));
        get_row_serialized_args args = new get_row_serialized_args();
        args.setNs(ns);
        args.setTable_name(table_name);
        args.setRow(row);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ByteBuffer getResult() throws ClientException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_get_row_serialized();
      }
    }

    public void get_cell(long ns, String table_name, String row, String column, AsyncMethodCallback<get_cell_call> resultHandler) throws TException {
      checkReady();
      get_cell_call method_call = new get_cell_call(ns, table_name, row, column, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class get_cell_call extends TAsyncMethodCall {
      private long ns;
      private String table_name;
      private String row;
      private String column;
      public get_cell_call(long ns, String table_name, String row, String column, AsyncMethodCallback<get_cell_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.ns = ns;
        this.table_name = table_name;
        this.row = row;
        this.column = column;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("get_cell", TMessageType.CALL, 0));
        get_cell_args args = new get_cell_args();
        args.setNs(ns);
        args.setTable_name(table_name);
        args.setRow(row);
        args.setColumn(column);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ByteBuffer getResult() throws ClientException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_get_cell();
      }
    }

    public void get_cells(long ns, String table_name, ScanSpec scan_spec, AsyncMethodCallback<get_cells_call> resultHandler) throws TException {
      checkReady();
      get_cells_call method_call = new get_cells_call(ns, table_name, scan_spec, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class get_cells_call extends TAsyncMethodCall {
      private long ns;
      private String table_name;
      private ScanSpec scan_spec;
      public get_cells_call(long ns, String table_name, ScanSpec scan_spec, AsyncMethodCallback<get_cells_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.ns = ns;
        this.table_name = table_name;
        this.scan_spec = scan_spec;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("get_cells", TMessageType.CALL, 0));
        get_cells_args args = new get_cells_args();
        args.setNs(ns);
        args.setTable_name(table_name);
        args.setScan_spec(scan_spec);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public List<Cell> getResult() throws ClientException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_get_cells();
      }
    }

    public void get_cells_as_arrays(long ns, String name, ScanSpec scan_spec, AsyncMethodCallback<get_cells_as_arrays_call> resultHandler) throws TException {
      checkReady();
      get_cells_as_arrays_call method_call = new get_cells_as_arrays_call(ns, name, scan_spec, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class get_cells_as_arrays_call extends TAsyncMethodCall {
      private long ns;
      private String name;
      private ScanSpec scan_spec;
      public get_cells_as_arrays_call(long ns, String name, ScanSpec scan_spec, AsyncMethodCallback<get_cells_as_arrays_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.ns = ns;
        this.name = name;
        this.scan_spec = scan_spec;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("get_cells_as_arrays", TMessageType.CALL, 0));
        get_cells_as_arrays_args args = new get_cells_as_arrays_args();
        args.setNs(ns);
        args.setName(name);
        args.setScan_spec(scan_spec);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public List<List<String>> getResult() throws ClientException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_get_cells_as_arrays();
      }
    }

    public void get_cells_serialized(long ns, String name, ScanSpec scan_spec, AsyncMethodCallback<get_cells_serialized_call> resultHandler) throws TException {
      checkReady();
      get_cells_serialized_call method_call = new get_cells_serialized_call(ns, name, scan_spec, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class get_cells_serialized_call extends TAsyncMethodCall {
      private long ns;
      private String name;
      private ScanSpec scan_spec;
      public get_cells_serialized_call(long ns, String name, ScanSpec scan_spec, AsyncMethodCallback<get_cells_serialized_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.ns = ns;
        this.name = name;
        this.scan_spec = scan_spec;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("get_cells_serialized", TMessageType.CALL, 0));
        get_cells_serialized_args args = new get_cells_serialized_args();
        args.setNs(ns);
        args.setName(name);
        args.setScan_spec(scan_spec);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ByteBuffer getResult() throws ClientException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_get_cells_serialized();
      }
    }

    public void refresh_shared_mutator(long ns, String table_name, MutateSpec mutate_spec, AsyncMethodCallback<refresh_shared_mutator_call> resultHandler) throws TException {
      checkReady();
      refresh_shared_mutator_call method_call = new refresh_shared_mutator_call(ns, table_name, mutate_spec, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class refresh_shared_mutator_call extends TAsyncMethodCall {
      private long ns;
      private String table_name;
      private MutateSpec mutate_spec;
      public refresh_shared_mutator_call(long ns, String table_name, MutateSpec mutate_spec, AsyncMethodCallback<refresh_shared_mutator_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.ns = ns;
        this.table_name = table_name;
        this.mutate_spec = mutate_spec;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("refresh_shared_mutator", TMessageType.CALL, 0));
        refresh_shared_mutator_args args = new refresh_shared_mutator_args();
        args.setNs(ns);
        args.setTable_name(table_name);
        args.setMutate_spec(mutate_spec);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws ClientException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_refresh_shared_mutator();
      }
    }

    public void offer_cells(long ns, String table_name, MutateSpec mutate_spec, List<Cell> cells, AsyncMethodCallback<offer_cells_call> resultHandler) throws TException {
      checkReady();
      offer_cells_call method_call = new offer_cells_call(ns, table_name, mutate_spec, cells, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class offer_cells_call extends TAsyncMethodCall {
      private long ns;
      private String table_name;
      private MutateSpec mutate_spec;
      private List<Cell> cells;
      public offer_cells_call(long ns, String table_name, MutateSpec mutate_spec, List<Cell> cells, AsyncMethodCallback<offer_cells_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.ns = ns;
        this.table_name = table_name;
        this.mutate_spec = mutate_spec;
        this.cells = cells;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("offer_cells", TMessageType.CALL, 0));
        offer_cells_args args = new offer_cells_args();
        args.setNs(ns);
        args.setTable_name(table_name);
        args.setMutate_spec(mutate_spec);
        args.setCells(cells);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws ClientException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_offer_cells();
      }
    }

    public void offer_cells_as_arrays(long ns, String table_name, MutateSpec mutate_spec, List<List<String>> cells, AsyncMethodCallback<offer_cells_as_arrays_call> resultHandler) throws TException {
      checkReady();
      offer_cells_as_arrays_call method_call = new offer_cells_as_arrays_call(ns, table_name, mutate_spec, cells, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class offer_cells_as_arrays_call extends TAsyncMethodCall {
      private long ns;
      private String table_name;
      private MutateSpec mutate_spec;
      private List<List<String>> cells;
      public offer_cells_as_arrays_call(long ns, String table_name, MutateSpec mutate_spec, List<List<String>> cells, AsyncMethodCallback<offer_cells_as_arrays_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.ns = ns;
        this.table_name = table_name;
        this.mutate_spec = mutate_spec;
        this.cells = cells;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("offer_cells_as_arrays", TMessageType.CALL, 0));
        offer_cells_as_arrays_args args = new offer_cells_as_arrays_args();
        args.setNs(ns);
        args.setTable_name(table_name);
        args.setMutate_spec(mutate_spec);
        args.setCells(cells);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws ClientException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_offer_cells_as_arrays();
      }
    }

    public void offer_cell(long ns, String table_name, MutateSpec mutate_spec, Cell cell, AsyncMethodCallback<offer_cell_call> resultHandler) throws TException {
      checkReady();
      offer_cell_call method_call = new offer_cell_call(ns, table_name, mutate_spec, cell, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class offer_cell_call extends TAsyncMethodCall {
      private long ns;
      private String table_name;
      private MutateSpec mutate_spec;
      private Cell cell;
      public offer_cell_call(long ns, String table_name, MutateSpec mutate_spec, Cell cell, AsyncMethodCallback<offer_cell_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.ns = ns;
        this.table_name = table_name;
        this.mutate_spec = mutate_spec;
        this.cell = cell;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("offer_cell", TMessageType.CALL, 0));
        offer_cell_args args = new offer_cell_args();
        args.setNs(ns);
        args.setTable_name(table_name);
        args.setMutate_spec(mutate_spec);
        args.setCell(cell);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws ClientException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_offer_cell();
      }
    }

    public void offer_cell_as_array(long ns, String table_name, MutateSpec mutate_spec, List<String> cell, AsyncMethodCallback<offer_cell_as_array_call> resultHandler) throws TException {
      checkReady();
      offer_cell_as_array_call method_call = new offer_cell_as_array_call(ns, table_name, mutate_spec, cell, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class offer_cell_as_array_call extends TAsyncMethodCall {
      private long ns;
      private String table_name;
      private MutateSpec mutate_spec;
      private List<String> cell;
      public offer_cell_as_array_call(long ns, String table_name, MutateSpec mutate_spec, List<String> cell, AsyncMethodCallback<offer_cell_as_array_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.ns = ns;
        this.table_name = table_name;
        this.mutate_spec = mutate_spec;
        this.cell = cell;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("offer_cell_as_array", TMessageType.CALL, 0));
        offer_cell_as_array_args args = new offer_cell_as_array_args();
        args.setNs(ns);
        args.setTable_name(table_name);
        args.setMutate_spec(mutate_spec);
        args.setCell(cell);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws ClientException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_offer_cell_as_array();
      }
    }

    public void open_mutator(long ns, String table_name, int flags, int flush_interval, AsyncMethodCallback<open_mutator_call> resultHandler) throws TException {
      checkReady();
      open_mutator_call method_call = new open_mutator_call(ns, table_name, flags, flush_interval, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class open_mutator_call extends TAsyncMethodCall {
      private long ns;
      private String table_name;
      private int flags;
      private int flush_interval;
      public open_mutator_call(long ns, String table_name, int flags, int flush_interval, AsyncMethodCallback<open_mutator_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.ns = ns;
        this.table_name = table_name;
        this.flags = flags;
        this.flush_interval = flush_interval;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("open_mutator", TMessageType.CALL, 0));
        open_mutator_args args = new open_mutator_args();
        args.setNs(ns);
        args.setTable_name(table_name);
        args.setFlags(flags);
        args.setFlush_interval(flush_interval);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public long getResult() throws ClientException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_open_mutator();
      }
    }

    public void close_mutator(long mutator, boolean flush, AsyncMethodCallback<close_mutator_call> resultHandler) throws TException {
      checkReady();
      close_mutator_call method_call = new close_mutator_call(mutator, flush, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class close_mutator_call extends TAsyncMethodCall {
      private long mutator;
      private boolean flush;
      public close_mutator_call(long mutator, boolean flush, AsyncMethodCallback<close_mutator_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.mutator = mutator;
        this.flush = flush;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("close_mutator", TMessageType.CALL, 0));
        close_mutator_args args = new close_mutator_args();
        args.setMutator(mutator);
        args.setFlush(flush);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws ClientException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_close_mutator();
      }
    }

    public void set_cell(long mutator, Cell cell, AsyncMethodCallback<set_cell_call> resultHandler) throws TException {
      checkReady();
      set_cell_call method_call = new set_cell_call(mutator, cell, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class set_cell_call extends TAsyncMethodCall {
      private long mutator;
      private Cell cell;
      public set_cell_call(long mutator, Cell cell, AsyncMethodCallback<set_cell_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.mutator = mutator;
        this.cell = cell;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("set_cell", TMessageType.CALL, 0));
        set_cell_args args = new set_cell_args();
        args.setMutator(mutator);
        args.setCell(cell);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws ClientException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_set_cell();
      }
    }

    public void set_cell_as_array(long mutator, List<String> cell, AsyncMethodCallback<set_cell_as_array_call> resultHandler) throws TException {
      checkReady();
      set_cell_as_array_call method_call = new set_cell_as_array_call(mutator, cell, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class set_cell_as_array_call extends TAsyncMethodCall {
      private long mutator;
      private List<String> cell;
      public set_cell_as_array_call(long mutator, List<String> cell, AsyncMethodCallback<set_cell_as_array_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.mutator = mutator;
        this.cell = cell;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("set_cell_as_array", TMessageType.CALL, 0));
        set_cell_as_array_args args = new set_cell_as_array_args();
        args.setMutator(mutator);
        args.setCell(cell);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws ClientException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_set_cell_as_array();
      }
    }

    public void set_cells(long mutator, List<Cell> cells, AsyncMethodCallback<set_cells_call> resultHandler) throws TException {
      checkReady();
      set_cells_call method_call = new set_cells_call(mutator, cells, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class set_cells_call extends TAsyncMethodCall {
      private long mutator;
      private List<Cell> cells;
      public set_cells_call(long mutator, List<Cell> cells, AsyncMethodCallback<set_cells_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.mutator = mutator;
        this.cells = cells;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("set_cells", TMessageType.CALL, 0));
        set_cells_args args = new set_cells_args();
        args.setMutator(mutator);
        args.setCells(cells);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws ClientException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_set_cells();
      }
    }

    public void set_cells_as_arrays(long mutator, List<List<String>> cells, AsyncMethodCallback<set_cells_as_arrays_call> resultHandler) throws TException {
      checkReady();
      set_cells_as_arrays_call method_call = new set_cells_as_arrays_call(mutator, cells, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class set_cells_as_arrays_call extends TAsyncMethodCall {
      private long mutator;
      private List<List<String>> cells;
      public set_cells_as_arrays_call(long mutator, List<List<String>> cells, AsyncMethodCallback<set_cells_as_arrays_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.mutator = mutator;
        this.cells = cells;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("set_cells_as_arrays", TMessageType.CALL, 0));
        set_cells_as_arrays_args args = new set_cells_as_arrays_args();
        args.setMutator(mutator);
        args.setCells(cells);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws ClientException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_set_cells_as_arrays();
      }
    }

    public void set_cells_serialized(long mutator, ByteBuffer cells, boolean flush, AsyncMethodCallback<set_cells_serialized_call> resultHandler) throws TException {
      checkReady();
      set_cells_serialized_call method_call = new set_cells_serialized_call(mutator, cells, flush, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class set_cells_serialized_call extends TAsyncMethodCall {
      private long mutator;
      private ByteBuffer cells;
      private boolean flush;
      public set_cells_serialized_call(long mutator, ByteBuffer cells, boolean flush, AsyncMethodCallback<set_cells_serialized_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.mutator = mutator;
        this.cells = cells;
        this.flush = flush;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("set_cells_serialized", TMessageType.CALL, 0));
        set_cells_serialized_args args = new set_cells_serialized_args();
        args.setMutator(mutator);
        args.setCells(cells);
        args.setFlush(flush);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws ClientException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_set_cells_serialized();
      }
    }

    public void flush_mutator(long mutator, AsyncMethodCallback<flush_mutator_call> resultHandler) throws TException {
      checkReady();
      flush_mutator_call method_call = new flush_mutator_call(mutator, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class flush_mutator_call extends TAsyncMethodCall {
      private long mutator;
      public flush_mutator_call(long mutator, AsyncMethodCallback<flush_mutator_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.mutator = mutator;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("flush_mutator", TMessageType.CALL, 0));
        flush_mutator_args args = new flush_mutator_args();
        args.setMutator(mutator);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws ClientException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_flush_mutator();
      }
    }

    public void exists_namespace(String ns, AsyncMethodCallback<exists_namespace_call> resultHandler) throws TException {
      checkReady();
      exists_namespace_call method_call = new exists_namespace_call(ns, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class exists_namespace_call extends TAsyncMethodCall {
      private String ns;
      public exists_namespace_call(String ns, AsyncMethodCallback<exists_namespace_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.ns = ns;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("exists_namespace", TMessageType.CALL, 0));
        exists_namespace_args args = new exists_namespace_args();
        args.setNs(ns);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public boolean getResult() throws ClientException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_exists_namespace();
      }
    }

    public void exists_table(long ns, String name, AsyncMethodCallback<exists_table_call> resultHandler) throws TException {
      checkReady();
      exists_table_call method_call = new exists_table_call(ns, name, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class exists_table_call extends TAsyncMethodCall {
      private long ns;
      private String name;
      public exists_table_call(long ns, String name, AsyncMethodCallback<exists_table_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.ns = ns;
        this.name = name;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("exists_table", TMessageType.CALL, 0));
        exists_table_args args = new exists_table_args();
        args.setNs(ns);
        args.setName(name);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public boolean getResult() throws ClientException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_exists_table();
      }
    }

    public void get_table_id(long ns, String table_name, AsyncMethodCallback<get_table_id_call> resultHandler) throws TException {
      checkReady();
      get_table_id_call method_call = new get_table_id_call(ns, table_name, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class get_table_id_call extends TAsyncMethodCall {
      private long ns;
      private String table_name;
      public get_table_id_call(long ns, String table_name, AsyncMethodCallback<get_table_id_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.ns = ns;
        this.table_name = table_name;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("get_table_id", TMessageType.CALL, 0));
        get_table_id_args args = new get_table_id_args();
        args.setNs(ns);
        args.setTable_name(table_name);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public String getResult() throws ClientException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_get_table_id();
      }
    }

    public void get_schema_str(long ns, String table_name, AsyncMethodCallback<get_schema_str_call> resultHandler) throws TException {
      checkReady();
      get_schema_str_call method_call = new get_schema_str_call(ns, table_name, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class get_schema_str_call extends TAsyncMethodCall {
      private long ns;
      private String table_name;
      public get_schema_str_call(long ns, String table_name, AsyncMethodCallback<get_schema_str_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.ns = ns;
        this.table_name = table_name;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("get_schema_str", TMessageType.CALL, 0));
        get_schema_str_args args = new get_schema_str_args();
        args.setNs(ns);
        args.setTable_name(table_name);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public String getResult() throws ClientException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_get_schema_str();
      }
    }

    public void get_schema(long ns, String table_name, AsyncMethodCallback<get_schema_call> resultHandler) throws TException {
      checkReady();
      get_schema_call method_call = new get_schema_call(ns, table_name, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class get_schema_call extends TAsyncMethodCall {
      private long ns;
      private String table_name;
      public get_schema_call(long ns, String table_name, AsyncMethodCallback<get_schema_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.ns = ns;
        this.table_name = table_name;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("get_schema", TMessageType.CALL, 0));
        get_schema_args args = new get_schema_args();
        args.setNs(ns);
        args.setTable_name(table_name);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public Schema getResult() throws ClientException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_get_schema();
      }
    }

    public void get_tables(long ns, AsyncMethodCallback<get_tables_call> resultHandler) throws TException {
      checkReady();
      get_tables_call method_call = new get_tables_call(ns, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class get_tables_call extends TAsyncMethodCall {
      private long ns;
      public get_tables_call(long ns, AsyncMethodCallback<get_tables_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.ns = ns;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("get_tables", TMessageType.CALL, 0));
        get_tables_args args = new get_tables_args();
        args.setNs(ns);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public List<String> getResult() throws ClientException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_get_tables();
      }
    }

    public void get_listing(long ns, AsyncMethodCallback<get_listing_call> resultHandler) throws TException {
      checkReady();
      get_listing_call method_call = new get_listing_call(ns, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class get_listing_call extends TAsyncMethodCall {
      private long ns;
      public get_listing_call(long ns, AsyncMethodCallback<get_listing_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.ns = ns;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("get_listing", TMessageType.CALL, 0));
        get_listing_args args = new get_listing_args();
        args.setNs(ns);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public List<NamespaceListing> getResult() throws ClientException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_get_listing();
      }
    }

    public void get_table_splits(long ns, String table_name, AsyncMethodCallback<get_table_splits_call> resultHandler) throws TException {
      checkReady();
      get_table_splits_call method_call = new get_table_splits_call(ns, table_name, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class get_table_splits_call extends TAsyncMethodCall {
      private long ns;
      private String table_name;
      public get_table_splits_call(long ns, String table_name, AsyncMethodCallback<get_table_splits_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.ns = ns;
        this.table_name = table_name;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("get_table_splits", TMessageType.CALL, 0));
        get_table_splits_args args = new get_table_splits_args();
        args.setNs(ns);
        args.setTable_name(table_name);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public List<TableSplit> getResult() throws ClientException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_get_table_splits();
      }
    }

    public void drop_namespace(String ns, boolean if_exists, AsyncMethodCallback<drop_namespace_call> resultHandler) throws TException {
      checkReady();
      drop_namespace_call method_call = new drop_namespace_call(ns, if_exists, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class drop_namespace_call extends TAsyncMethodCall {
      private String ns;
      private boolean if_exists;
      public drop_namespace_call(String ns, boolean if_exists, AsyncMethodCallback<drop_namespace_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.ns = ns;
        this.if_exists = if_exists;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("drop_namespace", TMessageType.CALL, 0));
        drop_namespace_args args = new drop_namespace_args();
        args.setNs(ns);
        args.setIf_exists(if_exists);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws ClientException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_drop_namespace();
      }
    }

    public void rename_table(long ns, String name, String new_name, AsyncMethodCallback<rename_table_call> resultHandler) throws TException {
      checkReady();
      rename_table_call method_call = new rename_table_call(ns, name, new_name, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class rename_table_call extends TAsyncMethodCall {
      private long ns;
      private String name;
      private String new_name;
      public rename_table_call(long ns, String name, String new_name, AsyncMethodCallback<rename_table_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.ns = ns;
        this.name = name;
        this.new_name = new_name;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("rename_table", TMessageType.CALL, 0));
        rename_table_args args = new rename_table_args();
        args.setNs(ns);
        args.setName(name);
        args.setNew_name(new_name);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws ClientException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_rename_table();
      }
    }

    public void drop_table(long ns, String name, boolean if_exists, AsyncMethodCallback<drop_table_call> resultHandler) throws TException {
      checkReady();
      drop_table_call method_call = new drop_table_call(ns, name, if_exists, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class drop_table_call extends TAsyncMethodCall {
      private long ns;
      private String name;
      private boolean if_exists;
      public drop_table_call(long ns, String name, boolean if_exists, AsyncMethodCallback<drop_table_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.ns = ns;
        this.name = name;
        this.if_exists = if_exists;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("drop_table", TMessageType.CALL, 0));
        drop_table_args args = new drop_table_args();
        args.setNs(ns);
        args.setName(name);
        args.setIf_exists(if_exists);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws ClientException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_drop_table();
      }
    }

  }

  public static class Processor implements TProcessor {
    private static final Logger LOGGER = LoggerFactory.getLogger(Processor.class.getName());
    public Processor(Iface iface)
    {
      iface_ = iface;
      processMap_.put("create_namespace", new create_namespace());
      processMap_.put("create_table", new create_table());
      processMap_.put("open_namespace", new open_namespace());
      processMap_.put("close_namespace", new close_namespace());
      processMap_.put("open_future", new open_future());
      processMap_.put("get_future_result", new get_future_result());
      processMap_.put("get_future_result_as_arrays", new get_future_result_as_arrays());
      processMap_.put("get_future_result_serialized", new get_future_result_serialized());
      processMap_.put("close_future", new close_future());
      processMap_.put("open_scanner", new open_scanner());
      processMap_.put("open_scanner_async", new open_scanner_async());
      processMap_.put("close_scanner", new close_scanner());
      processMap_.put("close_scanner_async", new close_scanner_async());
      processMap_.put("next_cells", new next_cells());
      processMap_.put("next_cells_as_arrays", new next_cells_as_arrays());
      processMap_.put("next_cells_serialized", new next_cells_serialized());
      processMap_.put("next_row", new next_row());
      processMap_.put("next_row_as_arrays", new next_row_as_arrays());
      processMap_.put("next_row_serialized", new next_row_serialized());
      processMap_.put("get_row", new get_row());
      processMap_.put("get_row_as_arrays", new get_row_as_arrays());
      processMap_.put("get_row_serialized", new get_row_serialized());
      processMap_.put("get_cell", new get_cell());
      processMap_.put("get_cells", new get_cells());
      processMap_.put("get_cells_as_arrays", new get_cells_as_arrays());
      processMap_.put("get_cells_serialized", new get_cells_serialized());
      processMap_.put("refresh_shared_mutator", new refresh_shared_mutator());
      processMap_.put("offer_cells", new offer_cells());
      processMap_.put("offer_cells_as_arrays", new offer_cells_as_arrays());
      processMap_.put("offer_cell", new offer_cell());
      processMap_.put("offer_cell_as_array", new offer_cell_as_array());
      processMap_.put("open_mutator", new open_mutator());
      processMap_.put("close_mutator", new close_mutator());
      processMap_.put("set_cell", new set_cell());
      processMap_.put("set_cell_as_array", new set_cell_as_array());
      processMap_.put("set_cells", new set_cells());
      processMap_.put("set_cells_as_arrays", new set_cells_as_arrays());
      processMap_.put("set_cells_serialized", new set_cells_serialized());
      processMap_.put("flush_mutator", new flush_mutator());
      processMap_.put("exists_namespace", new exists_namespace());
      processMap_.put("exists_table", new exists_table());
      processMap_.put("get_table_id", new get_table_id());
      processMap_.put("get_schema_str", new get_schema_str());
      processMap_.put("get_schema", new get_schema());
      processMap_.put("get_tables", new get_tables());
      processMap_.put("get_listing", new get_listing());
      processMap_.put("get_table_splits", new get_table_splits());
      processMap_.put("drop_namespace", new drop_namespace());
      processMap_.put("rename_table", new rename_table());
      processMap_.put("drop_table", new drop_table());
    }

    protected static interface ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException;
    }

    private Iface iface_;
    protected final HashMap<String,ProcessFunction> processMap_ = new HashMap<String,ProcessFunction>();

    public boolean process(TProtocol iprot, TProtocol oprot) throws TException
    {
      TMessage msg = iprot.readMessageBegin();
      ProcessFunction fn = processMap_.get(msg.name);
      if (fn == null) {
        TProtocolUtil.skip(iprot, TType.STRUCT);
        iprot.readMessageEnd();
        TApplicationException x = new TApplicationException(TApplicationException.UNKNOWN_METHOD, "Invalid method name: '"+msg.name+"'");
        oprot.writeMessageBegin(new TMessage(msg.name, TMessageType.EXCEPTION, msg.seqid));
        x.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        return true;
      }
      fn.process(msg.seqid, iprot, oprot);
      return true;
    }

    private class create_namespace implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        create_namespace_args args = new create_namespace_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("create_namespace", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        create_namespace_result result = new create_namespace_result();
        try {
          iface_.create_namespace(args.ns);
        } catch (ClientException e) {
          result.e = e;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing create_namespace", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing create_namespace");
          oprot.writeMessageBegin(new TMessage("create_namespace", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("create_namespace", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class create_table implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        create_table_args args = new create_table_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("create_table", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        create_table_result result = new create_table_result();
        try {
          iface_.create_table(args.ns, args.table_name, args.schema);
        } catch (ClientException e) {
          result.e = e;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing create_table", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing create_table");
          oprot.writeMessageBegin(new TMessage("create_table", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("create_table", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class open_namespace implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        open_namespace_args args = new open_namespace_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("open_namespace", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        open_namespace_result result = new open_namespace_result();
        try {
          result.success = iface_.open_namespace(args.ns);
          result.setSuccessIsSet(true);
        } catch (ClientException e) {
          result.e = e;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing open_namespace", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing open_namespace");
          oprot.writeMessageBegin(new TMessage("open_namespace", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("open_namespace", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class close_namespace implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        close_namespace_args args = new close_namespace_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("close_namespace", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        close_namespace_result result = new close_namespace_result();
        try {
          iface_.close_namespace(args.ns);
        } catch (ClientException e) {
          result.e = e;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing close_namespace", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing close_namespace");
          oprot.writeMessageBegin(new TMessage("close_namespace", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("close_namespace", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class open_future implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        open_future_args args = new open_future_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("open_future", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        open_future_result result = new open_future_result();
        try {
          result.success = iface_.open_future(args.queue_size);
          result.setSuccessIsSet(true);
        } catch (ClientException e) {
          result.e = e;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing open_future", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing open_future");
          oprot.writeMessageBegin(new TMessage("open_future", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("open_future", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class get_future_result implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        get_future_result_args args = new get_future_result_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("get_future_result", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        get_future_result_result result = new get_future_result_result();
        try {
          result.success = iface_.get_future_result(args.ff);
        } catch (ClientException e) {
          result.e = e;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing get_future_result", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_future_result");
          oprot.writeMessageBegin(new TMessage("get_future_result", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("get_future_result", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class get_future_result_as_arrays implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        get_future_result_as_arrays_args args = new get_future_result_as_arrays_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("get_future_result_as_arrays", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        get_future_result_as_arrays_result result = new get_future_result_as_arrays_result();
        try {
          result.success = iface_.get_future_result_as_arrays(args.ff);
        } catch (ClientException e) {
          result.e = e;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing get_future_result_as_arrays", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_future_result_as_arrays");
          oprot.writeMessageBegin(new TMessage("get_future_result_as_arrays", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("get_future_result_as_arrays", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class get_future_result_serialized implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        get_future_result_serialized_args args = new get_future_result_serialized_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("get_future_result_serialized", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        get_future_result_serialized_result result = new get_future_result_serialized_result();
        try {
          result.success = iface_.get_future_result_serialized(args.ff);
        } catch (ClientException e) {
          result.e = e;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing get_future_result_serialized", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_future_result_serialized");
          oprot.writeMessageBegin(new TMessage("get_future_result_serialized", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("get_future_result_serialized", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class close_future implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        close_future_args args = new close_future_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("close_future", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        close_future_result result = new close_future_result();
        try {
          iface_.close_future(args.ff);
        } catch (ClientException e) {
          result.e = e;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing close_future", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing close_future");
          oprot.writeMessageBegin(new TMessage("close_future", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("close_future", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class open_scanner implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        open_scanner_args args = new open_scanner_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("open_scanner", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        open_scanner_result result = new open_scanner_result();
        try {
          result.success = iface_.open_scanner(args.ns, args.table_name, args.scan_spec, args.retry_table_not_found);
          result.setSuccessIsSet(true);
        } catch (ClientException e) {
          result.e = e;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing open_scanner", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing open_scanner");
          oprot.writeMessageBegin(new TMessage("open_scanner", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("open_scanner", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class open_scanner_async implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        open_scanner_async_args args = new open_scanner_async_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("open_scanner_async", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        open_scanner_async_result result = new open_scanner_async_result();
        try {
          result.success = iface_.open_scanner_async(args.ns, args.table_name, args.future, args.scan_spec, args.retry_table_not_found);
          result.setSuccessIsSet(true);
        } catch (ClientException e) {
          result.e = e;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing open_scanner_async", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing open_scanner_async");
          oprot.writeMessageBegin(new TMessage("open_scanner_async", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("open_scanner_async", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class close_scanner implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        close_scanner_args args = new close_scanner_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("close_scanner", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        close_scanner_result result = new close_scanner_result();
        try {
          iface_.close_scanner(args.scanner);
        } catch (ClientException e) {
          result.e = e;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing close_scanner", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing close_scanner");
          oprot.writeMessageBegin(new TMessage("close_scanner", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("close_scanner", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class close_scanner_async implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        close_scanner_async_args args = new close_scanner_async_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("close_scanner_async", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        close_scanner_async_result result = new close_scanner_async_result();
        try {
          iface_.close_scanner_async(args.scanner);
        } catch (ClientException e) {
          result.e = e;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing close_scanner_async", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing close_scanner_async");
          oprot.writeMessageBegin(new TMessage("close_scanner_async", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("close_scanner_async", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class next_cells implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        next_cells_args args = new next_cells_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("next_cells", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        next_cells_result result = new next_cells_result();
        try {
          result.success = iface_.next_cells(args.scanner);
        } catch (ClientException e) {
          result.e = e;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing next_cells", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing next_cells");
          oprot.writeMessageBegin(new TMessage("next_cells", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("next_cells", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class next_cells_as_arrays implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        next_cells_as_arrays_args args = new next_cells_as_arrays_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("next_cells_as_arrays", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        next_cells_as_arrays_result result = new next_cells_as_arrays_result();
        try {
          result.success = iface_.next_cells_as_arrays(args.scanner);
        } catch (ClientException e) {
          result.e = e;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing next_cells_as_arrays", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing next_cells_as_arrays");
          oprot.writeMessageBegin(new TMessage("next_cells_as_arrays", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("next_cells_as_arrays", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class next_cells_serialized implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        next_cells_serialized_args args = new next_cells_serialized_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("next_cells_serialized", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        next_cells_serialized_result result = new next_cells_serialized_result();
        result.success = iface_.next_cells_serialized(args.scanner);
        oprot.writeMessageBegin(new TMessage("next_cells_serialized", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class next_row implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        next_row_args args = new next_row_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("next_row", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        next_row_result result = new next_row_result();
        try {
          result.success = iface_.next_row(args.scanner);
        } catch (ClientException e) {
          result.e = e;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing next_row", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing next_row");
          oprot.writeMessageBegin(new TMessage("next_row", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("next_row", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class next_row_as_arrays implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        next_row_as_arrays_args args = new next_row_as_arrays_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("next_row_as_arrays", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        next_row_as_arrays_result result = new next_row_as_arrays_result();
        try {
          result.success = iface_.next_row_as_arrays(args.scanner);
        } catch (ClientException e) {
          result.e = e;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing next_row_as_arrays", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing next_row_as_arrays");
          oprot.writeMessageBegin(new TMessage("next_row_as_arrays", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("next_row_as_arrays", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class next_row_serialized implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        next_row_serialized_args args = new next_row_serialized_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("next_row_serialized", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        next_row_serialized_result result = new next_row_serialized_result();
        try {
          result.success = iface_.next_row_serialized(args.scanner);
        } catch (ClientException e) {
          result.e = e;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing next_row_serialized", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing next_row_serialized");
          oprot.writeMessageBegin(new TMessage("next_row_serialized", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("next_row_serialized", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class get_row implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        get_row_args args = new get_row_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("get_row", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        get_row_result result = new get_row_result();
        try {
          result.success = iface_.get_row(args.ns, args.table_name, args.row);
        } catch (ClientException e) {
          result.e = e;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing get_row", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_row");
          oprot.writeMessageBegin(new TMessage("get_row", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("get_row", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class get_row_as_arrays implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        get_row_as_arrays_args args = new get_row_as_arrays_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("get_row_as_arrays", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        get_row_as_arrays_result result = new get_row_as_arrays_result();
        try {
          result.success = iface_.get_row_as_arrays(args.ns, args.name, args.row);
        } catch (ClientException e) {
          result.e = e;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing get_row_as_arrays", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_row_as_arrays");
          oprot.writeMessageBegin(new TMessage("get_row_as_arrays", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("get_row_as_arrays", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class get_row_serialized implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        get_row_serialized_args args = new get_row_serialized_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("get_row_serialized", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        get_row_serialized_result result = new get_row_serialized_result();
        try {
          result.success = iface_.get_row_serialized(args.ns, args.table_name, args.row);
        } catch (ClientException e) {
          result.e = e;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing get_row_serialized", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_row_serialized");
          oprot.writeMessageBegin(new TMessage("get_row_serialized", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("get_row_serialized", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class get_cell implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        get_cell_args args = new get_cell_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("get_cell", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        get_cell_result result = new get_cell_result();
        try {
          result.success = iface_.get_cell(args.ns, args.table_name, args.row, args.column);
        } catch (ClientException e) {
          result.e = e;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing get_cell", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_cell");
          oprot.writeMessageBegin(new TMessage("get_cell", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("get_cell", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class get_cells implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        get_cells_args args = new get_cells_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("get_cells", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        get_cells_result result = new get_cells_result();
        try {
          result.success = iface_.get_cells(args.ns, args.table_name, args.scan_spec);
        } catch (ClientException e) {
          result.e = e;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing get_cells", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_cells");
          oprot.writeMessageBegin(new TMessage("get_cells", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("get_cells", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class get_cells_as_arrays implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        get_cells_as_arrays_args args = new get_cells_as_arrays_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("get_cells_as_arrays", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        get_cells_as_arrays_result result = new get_cells_as_arrays_result();
        try {
          result.success = iface_.get_cells_as_arrays(args.ns, args.name, args.scan_spec);
        } catch (ClientException e) {
          result.e = e;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing get_cells_as_arrays", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_cells_as_arrays");
          oprot.writeMessageBegin(new TMessage("get_cells_as_arrays", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("get_cells_as_arrays", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class get_cells_serialized implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        get_cells_serialized_args args = new get_cells_serialized_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("get_cells_serialized", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        get_cells_serialized_result result = new get_cells_serialized_result();
        try {
          result.success = iface_.get_cells_serialized(args.ns, args.name, args.scan_spec);
        } catch (ClientException e) {
          result.e = e;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing get_cells_serialized", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_cells_serialized");
          oprot.writeMessageBegin(new TMessage("get_cells_serialized", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("get_cells_serialized", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class refresh_shared_mutator implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        refresh_shared_mutator_args args = new refresh_shared_mutator_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("refresh_shared_mutator", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        refresh_shared_mutator_result result = new refresh_shared_mutator_result();
        try {
          iface_.refresh_shared_mutator(args.ns, args.table_name, args.mutate_spec);
        } catch (ClientException e) {
          result.e = e;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing refresh_shared_mutator", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing refresh_shared_mutator");
          oprot.writeMessageBegin(new TMessage("refresh_shared_mutator", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("refresh_shared_mutator", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class offer_cells implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        offer_cells_args args = new offer_cells_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("offer_cells", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        offer_cells_result result = new offer_cells_result();
        try {
          iface_.offer_cells(args.ns, args.table_name, args.mutate_spec, args.cells);
        } catch (ClientException e) {
          result.e = e;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing offer_cells", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing offer_cells");
          oprot.writeMessageBegin(new TMessage("offer_cells", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("offer_cells", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class offer_cells_as_arrays implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        offer_cells_as_arrays_args args = new offer_cells_as_arrays_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("offer_cells_as_arrays", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        offer_cells_as_arrays_result result = new offer_cells_as_arrays_result();
        try {
          iface_.offer_cells_as_arrays(args.ns, args.table_name, args.mutate_spec, args.cells);
        } catch (ClientException e) {
          result.e = e;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing offer_cells_as_arrays", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing offer_cells_as_arrays");
          oprot.writeMessageBegin(new TMessage("offer_cells_as_arrays", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("offer_cells_as_arrays", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class offer_cell implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        offer_cell_args args = new offer_cell_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("offer_cell", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        offer_cell_result result = new offer_cell_result();
        try {
          iface_.offer_cell(args.ns, args.table_name, args.mutate_spec, args.cell);
        } catch (ClientException e) {
          result.e = e;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing offer_cell", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing offer_cell");
          oprot.writeMessageBegin(new TMessage("offer_cell", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("offer_cell", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class offer_cell_as_array implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        offer_cell_as_array_args args = new offer_cell_as_array_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("offer_cell_as_array", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        offer_cell_as_array_result result = new offer_cell_as_array_result();
        try {
          iface_.offer_cell_as_array(args.ns, args.table_name, args.mutate_spec, args.cell);
        } catch (ClientException e) {
          result.e = e;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing offer_cell_as_array", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing offer_cell_as_array");
          oprot.writeMessageBegin(new TMessage("offer_cell_as_array", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("offer_cell_as_array", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class open_mutator implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        open_mutator_args args = new open_mutator_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("open_mutator", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        open_mutator_result result = new open_mutator_result();
        try {
          result.success = iface_.open_mutator(args.ns, args.table_name, args.flags, args.flush_interval);
          result.setSuccessIsSet(true);
        } catch (ClientException e) {
          result.e = e;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing open_mutator", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing open_mutator");
          oprot.writeMessageBegin(new TMessage("open_mutator", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("open_mutator", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class close_mutator implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        close_mutator_args args = new close_mutator_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("close_mutator", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        close_mutator_result result = new close_mutator_result();
        try {
          iface_.close_mutator(args.mutator, args.flush);
        } catch (ClientException e) {
          result.e = e;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing close_mutator", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing close_mutator");
          oprot.writeMessageBegin(new TMessage("close_mutator", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("close_mutator", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class set_cell implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        set_cell_args args = new set_cell_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("set_cell", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        set_cell_result result = new set_cell_result();
        try {
          iface_.set_cell(args.mutator, args.cell);
        } catch (ClientException e) {
          result.e = e;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing set_cell", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing set_cell");
          oprot.writeMessageBegin(new TMessage("set_cell", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("set_cell", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class set_cell_as_array implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        set_cell_as_array_args args = new set_cell_as_array_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("set_cell_as_array", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        set_cell_as_array_result result = new set_cell_as_array_result();
        try {
          iface_.set_cell_as_array(args.mutator, args.cell);
        } catch (ClientException e) {
          result.e = e;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing set_cell_as_array", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing set_cell_as_array");
          oprot.writeMessageBegin(new TMessage("set_cell_as_array", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("set_cell_as_array", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class set_cells implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        set_cells_args args = new set_cells_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("set_cells", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        set_cells_result result = new set_cells_result();
        try {
          iface_.set_cells(args.mutator, args.cells);
        } catch (ClientException e) {
          result.e = e;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing set_cells", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing set_cells");
          oprot.writeMessageBegin(new TMessage("set_cells", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("set_cells", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class set_cells_as_arrays implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        set_cells_as_arrays_args args = new set_cells_as_arrays_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("set_cells_as_arrays", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        set_cells_as_arrays_result result = new set_cells_as_arrays_result();
        try {
          iface_.set_cells_as_arrays(args.mutator, args.cells);
        } catch (ClientException e) {
          result.e = e;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing set_cells_as_arrays", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing set_cells_as_arrays");
          oprot.writeMessageBegin(new TMessage("set_cells_as_arrays", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("set_cells_as_arrays", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class set_cells_serialized implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        set_cells_serialized_args args = new set_cells_serialized_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("set_cells_serialized", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        set_cells_serialized_result result = new set_cells_serialized_result();
        try {
          iface_.set_cells_serialized(args.mutator, args.cells, args.flush);
        } catch (ClientException e) {
          result.e = e;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing set_cells_serialized", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing set_cells_serialized");
          oprot.writeMessageBegin(new TMessage("set_cells_serialized", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("set_cells_serialized", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class flush_mutator implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        flush_mutator_args args = new flush_mutator_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("flush_mutator", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        flush_mutator_result result = new flush_mutator_result();
        try {
          iface_.flush_mutator(args.mutator);
        } catch (ClientException e) {
          result.e = e;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing flush_mutator", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing flush_mutator");
          oprot.writeMessageBegin(new TMessage("flush_mutator", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("flush_mutator", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class exists_namespace implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        exists_namespace_args args = new exists_namespace_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("exists_namespace", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        exists_namespace_result result = new exists_namespace_result();
        try {
          result.success = iface_.exists_namespace(args.ns);
          result.setSuccessIsSet(true);
        } catch (ClientException e) {
          result.e = e;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing exists_namespace", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing exists_namespace");
          oprot.writeMessageBegin(new TMessage("exists_namespace", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("exists_namespace", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class exists_table implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        exists_table_args args = new exists_table_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("exists_table", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        exists_table_result result = new exists_table_result();
        try {
          result.success = iface_.exists_table(args.ns, args.name);
          result.setSuccessIsSet(true);
        } catch (ClientException e) {
          result.e = e;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing exists_table", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing exists_table");
          oprot.writeMessageBegin(new TMessage("exists_table", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("exists_table", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class get_table_id implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        get_table_id_args args = new get_table_id_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("get_table_id", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        get_table_id_result result = new get_table_id_result();
        try {
          result.success = iface_.get_table_id(args.ns, args.table_name);
        } catch (ClientException e) {
          result.e = e;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing get_table_id", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_table_id");
          oprot.writeMessageBegin(new TMessage("get_table_id", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("get_table_id", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class get_schema_str implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        get_schema_str_args args = new get_schema_str_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("get_schema_str", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        get_schema_str_result result = new get_schema_str_result();
        try {
          result.success = iface_.get_schema_str(args.ns, args.table_name);
        } catch (ClientException e) {
          result.e = e;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing get_schema_str", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_schema_str");
          oprot.writeMessageBegin(new TMessage("get_schema_str", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("get_schema_str", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class get_schema implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        get_schema_args args = new get_schema_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("get_schema", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        get_schema_result result = new get_schema_result();
        try {
          result.success = iface_.get_schema(args.ns, args.table_name);
        } catch (ClientException e) {
          result.e = e;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing get_schema", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_schema");
          oprot.writeMessageBegin(new TMessage("get_schema", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("get_schema", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class get_tables implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        get_tables_args args = new get_tables_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("get_tables", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        get_tables_result result = new get_tables_result();
        try {
          result.success = iface_.get_tables(args.ns);
        } catch (ClientException e) {
          result.e = e;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing get_tables", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_tables");
          oprot.writeMessageBegin(new TMessage("get_tables", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("get_tables", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class get_listing implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        get_listing_args args = new get_listing_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("get_listing", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        get_listing_result result = new get_listing_result();
        try {
          result.success = iface_.get_listing(args.ns);
        } catch (ClientException e) {
          result.e = e;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing get_listing", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_listing");
          oprot.writeMessageBegin(new TMessage("get_listing", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("get_listing", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class get_table_splits implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        get_table_splits_args args = new get_table_splits_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("get_table_splits", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        get_table_splits_result result = new get_table_splits_result();
        try {
          result.success = iface_.get_table_splits(args.ns, args.table_name);
        } catch (ClientException e) {
          result.e = e;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing get_table_splits", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_table_splits");
          oprot.writeMessageBegin(new TMessage("get_table_splits", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("get_table_splits", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class drop_namespace implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        drop_namespace_args args = new drop_namespace_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("drop_namespace", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        drop_namespace_result result = new drop_namespace_result();
        try {
          iface_.drop_namespace(args.ns, args.if_exists);
        } catch (ClientException e) {
          result.e = e;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing drop_namespace", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing drop_namespace");
          oprot.writeMessageBegin(new TMessage("drop_namespace", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("drop_namespace", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class rename_table implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        rename_table_args args = new rename_table_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("rename_table", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        rename_table_result result = new rename_table_result();
        try {
          iface_.rename_table(args.ns, args.name, args.new_name);
        } catch (ClientException e) {
          result.e = e;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing rename_table", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing rename_table");
          oprot.writeMessageBegin(new TMessage("rename_table", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("rename_table", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class drop_table implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        drop_table_args args = new drop_table_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("drop_table", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        drop_table_result result = new drop_table_result();
        try {
          iface_.drop_table(args.ns, args.name, args.if_exists);
        } catch (ClientException e) {
          result.e = e;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing drop_table", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing drop_table");
          oprot.writeMessageBegin(new TMessage("drop_table", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("drop_table", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

  }

  public static class create_namespace_args implements TBase<create_namespace_args, create_namespace_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("create_namespace_args");

    private static final TField NS_FIELD_DESC = new TField("ns", TType.STRING, (short)1);

    public String ns;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      NS((short)1, "ns");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // NS
            return NS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.NS, new FieldMetaData("ns", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(create_namespace_args.class, metaDataMap);
    }

    public create_namespace_args() {
    }

    public create_namespace_args(
      String ns)
    {
      this();
      this.ns = ns;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public create_namespace_args(create_namespace_args other) {
      if (other.isSetNs()) {
        this.ns = other.ns;
      }
    }

    public create_namespace_args deepCopy() {
      return new create_namespace_args(this);
    }

    @Override
    public void clear() {
      this.ns = null;
    }

    public String getNs() {
      return this.ns;
    }

    public create_namespace_args setNs(String ns) {
      this.ns = ns;
      return this;
    }

    public void unsetNs() {
      this.ns = null;
    }

    /** Returns true if field ns is set (has been asigned a value) and false otherwise */
    public boolean isSetNs() {
      return this.ns != null;
    }

    public void setNsIsSet(boolean value) {
      if (!value) {
        this.ns = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case NS:
        if (value == null) {
          unsetNs();
        } else {
          setNs((String)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case NS:
        return getNs();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case NS:
        return isSetNs();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof create_namespace_args)
        return this.equals((create_namespace_args)that);
      return false;
    }

    public boolean equals(create_namespace_args that) {
      if (that == null)
        return false;

      boolean this_present_ns = true && this.isSetNs();
      boolean that_present_ns = true && that.isSetNs();
      if (this_present_ns || that_present_ns) {
        if (!(this_present_ns && that_present_ns))
          return false;
        if (!this.ns.equals(that.ns))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(create_namespace_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      create_namespace_args typedOther = (create_namespace_args)other;

      lastComparison = Boolean.valueOf(isSetNs()).compareTo(typedOther.isSetNs());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetNs()) {
        lastComparison = TBaseHelper.compareTo(this.ns, typedOther.ns);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // NS
            if (field.type == TType.STRING) {
              this.ns = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.ns != null) {
        oprot.writeFieldBegin(NS_FIELD_DESC);
        oprot.writeString(this.ns);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("create_namespace_args(");
      boolean first = true;

      sb.append("ns:");
      if (this.ns == null) {
        sb.append("null");
      } else {
        sb.append(this.ns);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class create_namespace_result implements TBase<create_namespace_result, create_namespace_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("create_namespace_result");

    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public ClientException e;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      E((short)1, "e");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // E
            return E;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(create_namespace_result.class, metaDataMap);
    }

    public create_namespace_result() {
    }

    public create_namespace_result(
      ClientException e)
    {
      this();
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public create_namespace_result(create_namespace_result other) {
      if (other.isSetE()) {
        this.e = new ClientException(other.e);
      }
    }

    public create_namespace_result deepCopy() {
      return new create_namespace_result(this);
    }

    @Override
    public void clear() {
      this.e = null;
    }

    public ClientException getE() {
      return this.e;
    }

    public create_namespace_result setE(ClientException e) {
      this.e = e;
      return this;
    }

    public void unsetE() {
      this.e = null;
    }

    /** Returns true if field e is set (has been asigned a value) and false otherwise */
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((ClientException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case E:
        return getE();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case E:
        return isSetE();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof create_namespace_result)
        return this.equals((create_namespace_result)that);
      return false;
    }

    public boolean equals(create_namespace_result that) {
      if (that == null)
        return false;

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(create_namespace_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      create_namespace_result typedOther = (create_namespace_result)other;

      lastComparison = Boolean.valueOf(isSetE()).compareTo(typedOther.isSetE());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetE()) {
        lastComparison = TBaseHelper.compareTo(this.e, typedOther.e);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // E
            if (field.type == TType.STRUCT) {
              this.e = new ClientException();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetE()) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("create_namespace_result(");
      boolean first = true;

      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class create_table_args implements TBase<create_table_args, create_table_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("create_table_args");

    private static final TField NS_FIELD_DESC = new TField("ns", TType.I64, (short)1);
    private static final TField TABLE_NAME_FIELD_DESC = new TField("table_name", TType.STRING, (short)2);
    private static final TField SCHEMA_FIELD_DESC = new TField("schema", TType.STRING, (short)3);

    public long ns;
    public String table_name;
    public String schema;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      NS((short)1, "ns"),
      TABLE_NAME((short)2, "table_name"),
      SCHEMA((short)3, "schema");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // NS
            return NS;
          case 2: // TABLE_NAME
            return TABLE_NAME;
          case 3: // SCHEMA
            return SCHEMA;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __NS_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.NS, new FieldMetaData("ns", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64          , "Namespace")));
      tmpMap.put(_Fields.TABLE_NAME, new FieldMetaData("table_name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.SCHEMA, new FieldMetaData("schema", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(create_table_args.class, metaDataMap);
    }

    public create_table_args() {
    }

    public create_table_args(
      long ns,
      String table_name,
      String schema)
    {
      this();
      this.ns = ns;
      setNsIsSet(true);
      this.table_name = table_name;
      this.schema = schema;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public create_table_args(create_table_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.ns = other.ns;
      if (other.isSetTable_name()) {
        this.table_name = other.table_name;
      }
      if (other.isSetSchema()) {
        this.schema = other.schema;
      }
    }

    public create_table_args deepCopy() {
      return new create_table_args(this);
    }

    @Override
    public void clear() {
      setNsIsSet(false);
      this.ns = 0;
      this.table_name = null;
      this.schema = null;
    }

    public long getNs() {
      return this.ns;
    }

    public create_table_args setNs(long ns) {
      this.ns = ns;
      setNsIsSet(true);
      return this;
    }

    public void unsetNs() {
      __isset_bit_vector.clear(__NS_ISSET_ID);
    }

    /** Returns true if field ns is set (has been asigned a value) and false otherwise */
    public boolean isSetNs() {
      return __isset_bit_vector.get(__NS_ISSET_ID);
    }

    public void setNsIsSet(boolean value) {
      __isset_bit_vector.set(__NS_ISSET_ID, value);
    }

    public String getTable_name() {
      return this.table_name;
    }

    public create_table_args setTable_name(String table_name) {
      this.table_name = table_name;
      return this;
    }

    public void unsetTable_name() {
      this.table_name = null;
    }

    /** Returns true if field table_name is set (has been asigned a value) and false otherwise */
    public boolean isSetTable_name() {
      return this.table_name != null;
    }

    public void setTable_nameIsSet(boolean value) {
      if (!value) {
        this.table_name = null;
      }
    }

    public String getSchema() {
      return this.schema;
    }

    public create_table_args setSchema(String schema) {
      this.schema = schema;
      return this;
    }

    public void unsetSchema() {
      this.schema = null;
    }

    /** Returns true if field schema is set (has been asigned a value) and false otherwise */
    public boolean isSetSchema() {
      return this.schema != null;
    }

    public void setSchemaIsSet(boolean value) {
      if (!value) {
        this.schema = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case NS:
        if (value == null) {
          unsetNs();
        } else {
          setNs((Long)value);
        }
        break;

      case TABLE_NAME:
        if (value == null) {
          unsetTable_name();
        } else {
          setTable_name((String)value);
        }
        break;

      case SCHEMA:
        if (value == null) {
          unsetSchema();
        } else {
          setSchema((String)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case NS:
        return new Long(getNs());

      case TABLE_NAME:
        return getTable_name();

      case SCHEMA:
        return getSchema();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case NS:
        return isSetNs();
      case TABLE_NAME:
        return isSetTable_name();
      case SCHEMA:
        return isSetSchema();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof create_table_args)
        return this.equals((create_table_args)that);
      return false;
    }

    public boolean equals(create_table_args that) {
      if (that == null)
        return false;

      boolean this_present_ns = true;
      boolean that_present_ns = true;
      if (this_present_ns || that_present_ns) {
        if (!(this_present_ns && that_present_ns))
          return false;
        if (this.ns != that.ns)
          return false;
      }

      boolean this_present_table_name = true && this.isSetTable_name();
      boolean that_present_table_name = true && that.isSetTable_name();
      if (this_present_table_name || that_present_table_name) {
        if (!(this_present_table_name && that_present_table_name))
          return false;
        if (!this.table_name.equals(that.table_name))
          return false;
      }

      boolean this_present_schema = true && this.isSetSchema();
      boolean that_present_schema = true && that.isSetSchema();
      if (this_present_schema || that_present_schema) {
        if (!(this_present_schema && that_present_schema))
          return false;
        if (!this.schema.equals(that.schema))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(create_table_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      create_table_args typedOther = (create_table_args)other;

      lastComparison = Boolean.valueOf(isSetNs()).compareTo(typedOther.isSetNs());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetNs()) {
        lastComparison = TBaseHelper.compareTo(this.ns, typedOther.ns);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetTable_name()).compareTo(typedOther.isSetTable_name());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTable_name()) {
        lastComparison = TBaseHelper.compareTo(this.table_name, typedOther.table_name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetSchema()).compareTo(typedOther.isSetSchema());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSchema()) {
        lastComparison = TBaseHelper.compareTo(this.schema, typedOther.schema);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // NS
            if (field.type == TType.I64) {
              this.ns = iprot.readI64();
              setNsIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // TABLE_NAME
            if (field.type == TType.STRING) {
              this.table_name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // SCHEMA
            if (field.type == TType.STRING) {
              this.schema = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(NS_FIELD_DESC);
      oprot.writeI64(this.ns);
      oprot.writeFieldEnd();
      if (this.table_name != null) {
        oprot.writeFieldBegin(TABLE_NAME_FIELD_DESC);
        oprot.writeString(this.table_name);
        oprot.writeFieldEnd();
      }
      if (this.schema != null) {
        oprot.writeFieldBegin(SCHEMA_FIELD_DESC);
        oprot.writeString(this.schema);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("create_table_args(");
      boolean first = true;

      sb.append("ns:");
      sb.append(this.ns);
      first = false;
      if (!first) sb.append(", ");
      sb.append("table_name:");
      if (this.table_name == null) {
        sb.append("null");
      } else {
        sb.append(this.table_name);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("schema:");
      if (this.schema == null) {
        sb.append("null");
      } else {
        sb.append(this.schema);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class create_table_result implements TBase<create_table_result, create_table_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("create_table_result");

    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public ClientException e;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      E((short)1, "e");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // E
            return E;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(create_table_result.class, metaDataMap);
    }

    public create_table_result() {
    }

    public create_table_result(
      ClientException e)
    {
      this();
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public create_table_result(create_table_result other) {
      if (other.isSetE()) {
        this.e = new ClientException(other.e);
      }
    }

    public create_table_result deepCopy() {
      return new create_table_result(this);
    }

    @Override
    public void clear() {
      this.e = null;
    }

    public ClientException getE() {
      return this.e;
    }

    public create_table_result setE(ClientException e) {
      this.e = e;
      return this;
    }

    public void unsetE() {
      this.e = null;
    }

    /** Returns true if field e is set (has been asigned a value) and false otherwise */
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((ClientException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case E:
        return getE();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case E:
        return isSetE();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof create_table_result)
        return this.equals((create_table_result)that);
      return false;
    }

    public boolean equals(create_table_result that) {
      if (that == null)
        return false;

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(create_table_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      create_table_result typedOther = (create_table_result)other;

      lastComparison = Boolean.valueOf(isSetE()).compareTo(typedOther.isSetE());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetE()) {
        lastComparison = TBaseHelper.compareTo(this.e, typedOther.e);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // E
            if (field.type == TType.STRUCT) {
              this.e = new ClientException();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetE()) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("create_table_result(");
      boolean first = true;

      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class open_namespace_args implements TBase<open_namespace_args, open_namespace_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("open_namespace_args");

    private static final TField NS_FIELD_DESC = new TField("ns", TType.STRING, (short)1);

    public String ns;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      NS((short)1, "ns");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // NS
            return NS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.NS, new FieldMetaData("ns", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(open_namespace_args.class, metaDataMap);
    }

    public open_namespace_args() {
    }

    public open_namespace_args(
      String ns)
    {
      this();
      this.ns = ns;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public open_namespace_args(open_namespace_args other) {
      if (other.isSetNs()) {
        this.ns = other.ns;
      }
    }

    public open_namespace_args deepCopy() {
      return new open_namespace_args(this);
    }

    @Override
    public void clear() {
      this.ns = null;
    }

    public String getNs() {
      return this.ns;
    }

    public open_namespace_args setNs(String ns) {
      this.ns = ns;
      return this;
    }

    public void unsetNs() {
      this.ns = null;
    }

    /** Returns true if field ns is set (has been asigned a value) and false otherwise */
    public boolean isSetNs() {
      return this.ns != null;
    }

    public void setNsIsSet(boolean value) {
      if (!value) {
        this.ns = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case NS:
        if (value == null) {
          unsetNs();
        } else {
          setNs((String)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case NS:
        return getNs();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case NS:
        return isSetNs();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof open_namespace_args)
        return this.equals((open_namespace_args)that);
      return false;
    }

    public boolean equals(open_namespace_args that) {
      if (that == null)
        return false;

      boolean this_present_ns = true && this.isSetNs();
      boolean that_present_ns = true && that.isSetNs();
      if (this_present_ns || that_present_ns) {
        if (!(this_present_ns && that_present_ns))
          return false;
        if (!this.ns.equals(that.ns))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(open_namespace_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      open_namespace_args typedOther = (open_namespace_args)other;

      lastComparison = Boolean.valueOf(isSetNs()).compareTo(typedOther.isSetNs());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetNs()) {
        lastComparison = TBaseHelper.compareTo(this.ns, typedOther.ns);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // NS
            if (field.type == TType.STRING) {
              this.ns = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.ns != null) {
        oprot.writeFieldBegin(NS_FIELD_DESC);
        oprot.writeString(this.ns);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("open_namespace_args(");
      boolean first = true;

      sb.append("ns:");
      if (this.ns == null) {
        sb.append("null");
      } else {
        sb.append(this.ns);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class open_namespace_result implements TBase<open_namespace_result, open_namespace_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("open_namespace_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.I64, (short)0);
    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public long success;
    public ClientException e;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      E((short)1, "e");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // E
            return E;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __SUCCESS_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64          , "Namespace")));
      tmpMap.put(_Fields.E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(open_namespace_result.class, metaDataMap);
    }

    public open_namespace_result() {
    }

    public open_namespace_result(
      long success,
      ClientException e)
    {
      this();
      this.success = success;
      setSuccessIsSet(true);
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public open_namespace_result(open_namespace_result other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.success = other.success;
      if (other.isSetE()) {
        this.e = new ClientException(other.e);
      }
    }

    public open_namespace_result deepCopy() {
      return new open_namespace_result(this);
    }

    @Override
    public void clear() {
      setSuccessIsSet(false);
      this.success = 0;
      this.e = null;
    }

    public long getSuccess() {
      return this.success;
    }

    public open_namespace_result setSuccess(long success) {
      this.success = success;
      setSuccessIsSet(true);
      return this;
    }

    public void unsetSuccess() {
      __isset_bit_vector.clear(__SUCCESS_ISSET_ID);
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return __isset_bit_vector.get(__SUCCESS_ISSET_ID);
    }

    public void setSuccessIsSet(boolean value) {
      __isset_bit_vector.set(__SUCCESS_ISSET_ID, value);
    }

    public ClientException getE() {
      return this.e;
    }

    public open_namespace_result setE(ClientException e) {
      this.e = e;
      return this;
    }

    public void unsetE() {
      this.e = null;
    }

    /** Returns true if field e is set (has been asigned a value) and false otherwise */
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Long)value);
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((ClientException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return new Long(getSuccess());

      case E:
        return getE();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof open_namespace_result)
        return this.equals((open_namespace_result)that);
      return false;
    }

    public boolean equals(open_namespace_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(open_namespace_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      open_namespace_result typedOther = (open_namespace_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetE()).compareTo(typedOther.isSetE());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetE()) {
        lastComparison = TBaseHelper.compareTo(this.e, typedOther.e);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.I64) {
              this.success = iprot.readI64();
              setSuccessIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // E
            if (field.type == TType.STRUCT) {
              this.e = new ClientException();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeI64(this.success);
        oprot.writeFieldEnd();
      } else if (this.isSetE()) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("open_namespace_result(");
      boolean first = true;

      sb.append("success:");
      sb.append(this.success);
      first = false;
      if (!first) sb.append(", ");
      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class close_namespace_args implements TBase<close_namespace_args, close_namespace_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("close_namespace_args");

    private static final TField NS_FIELD_DESC = new TField("ns", TType.I64, (short)1);

    public long ns;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      NS((short)1, "ns");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // NS
            return NS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __NS_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.NS, new FieldMetaData("ns", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64          , "Namespace")));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(close_namespace_args.class, metaDataMap);
    }

    public close_namespace_args() {
    }

    public close_namespace_args(
      long ns)
    {
      this();
      this.ns = ns;
      setNsIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public close_namespace_args(close_namespace_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.ns = other.ns;
    }

    public close_namespace_args deepCopy() {
      return new close_namespace_args(this);
    }

    @Override
    public void clear() {
      setNsIsSet(false);
      this.ns = 0;
    }

    public long getNs() {
      return this.ns;
    }

    public close_namespace_args setNs(long ns) {
      this.ns = ns;
      setNsIsSet(true);
      return this;
    }

    public void unsetNs() {
      __isset_bit_vector.clear(__NS_ISSET_ID);
    }

    /** Returns true if field ns is set (has been asigned a value) and false otherwise */
    public boolean isSetNs() {
      return __isset_bit_vector.get(__NS_ISSET_ID);
    }

    public void setNsIsSet(boolean value) {
      __isset_bit_vector.set(__NS_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case NS:
        if (value == null) {
          unsetNs();
        } else {
          setNs((Long)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case NS:
        return new Long(getNs());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case NS:
        return isSetNs();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof close_namespace_args)
        return this.equals((close_namespace_args)that);
      return false;
    }

    public boolean equals(close_namespace_args that) {
      if (that == null)
        return false;

      boolean this_present_ns = true;
      boolean that_present_ns = true;
      if (this_present_ns || that_present_ns) {
        if (!(this_present_ns && that_present_ns))
          return false;
        if (this.ns != that.ns)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(close_namespace_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      close_namespace_args typedOther = (close_namespace_args)other;

      lastComparison = Boolean.valueOf(isSetNs()).compareTo(typedOther.isSetNs());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetNs()) {
        lastComparison = TBaseHelper.compareTo(this.ns, typedOther.ns);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // NS
            if (field.type == TType.I64) {
              this.ns = iprot.readI64();
              setNsIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(NS_FIELD_DESC);
      oprot.writeI64(this.ns);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("close_namespace_args(");
      boolean first = true;

      sb.append("ns:");
      sb.append(this.ns);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class close_namespace_result implements TBase<close_namespace_result, close_namespace_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("close_namespace_result");

    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public ClientException e;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      E((short)1, "e");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // E
            return E;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(close_namespace_result.class, metaDataMap);
    }

    public close_namespace_result() {
    }

    public close_namespace_result(
      ClientException e)
    {
      this();
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public close_namespace_result(close_namespace_result other) {
      if (other.isSetE()) {
        this.e = new ClientException(other.e);
      }
    }

    public close_namespace_result deepCopy() {
      return new close_namespace_result(this);
    }

    @Override
    public void clear() {
      this.e = null;
    }

    public ClientException getE() {
      return this.e;
    }

    public close_namespace_result setE(ClientException e) {
      this.e = e;
      return this;
    }

    public void unsetE() {
      this.e = null;
    }

    /** Returns true if field e is set (has been asigned a value) and false otherwise */
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((ClientException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case E:
        return getE();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case E:
        return isSetE();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof close_namespace_result)
        return this.equals((close_namespace_result)that);
      return false;
    }

    public boolean equals(close_namespace_result that) {
      if (that == null)
        return false;

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(close_namespace_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      close_namespace_result typedOther = (close_namespace_result)other;

      lastComparison = Boolean.valueOf(isSetE()).compareTo(typedOther.isSetE());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetE()) {
        lastComparison = TBaseHelper.compareTo(this.e, typedOther.e);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // E
            if (field.type == TType.STRUCT) {
              this.e = new ClientException();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetE()) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("close_namespace_result(");
      boolean first = true;

      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class open_future_args implements TBase<open_future_args, open_future_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("open_future_args");

    private static final TField QUEUE_SIZE_FIELD_DESC = new TField("queue_size", TType.I32, (short)1);

    public int queue_size;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      QUEUE_SIZE((short)1, "queue_size");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // QUEUE_SIZE
            return QUEUE_SIZE;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __QUEUE_SIZE_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.QUEUE_SIZE, new FieldMetaData("queue_size", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I32)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(open_future_args.class, metaDataMap);
    }

    public open_future_args() {
      this.queue_size = 0;

    }

    public open_future_args(
      int queue_size)
    {
      this();
      this.queue_size = queue_size;
      setQueue_sizeIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public open_future_args(open_future_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.queue_size = other.queue_size;
    }

    public open_future_args deepCopy() {
      return new open_future_args(this);
    }

    @Override
    public void clear() {
      this.queue_size = 0;

    }

    public int getQueue_size() {
      return this.queue_size;
    }

    public open_future_args setQueue_size(int queue_size) {
      this.queue_size = queue_size;
      setQueue_sizeIsSet(true);
      return this;
    }

    public void unsetQueue_size() {
      __isset_bit_vector.clear(__QUEUE_SIZE_ISSET_ID);
    }

    /** Returns true if field queue_size is set (has been asigned a value) and false otherwise */
    public boolean isSetQueue_size() {
      return __isset_bit_vector.get(__QUEUE_SIZE_ISSET_ID);
    }

    public void setQueue_sizeIsSet(boolean value) {
      __isset_bit_vector.set(__QUEUE_SIZE_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case QUEUE_SIZE:
        if (value == null) {
          unsetQueue_size();
        } else {
          setQueue_size((Integer)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case QUEUE_SIZE:
        return new Integer(getQueue_size());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case QUEUE_SIZE:
        return isSetQueue_size();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof open_future_args)
        return this.equals((open_future_args)that);
      return false;
    }

    public boolean equals(open_future_args that) {
      if (that == null)
        return false;

      boolean this_present_queue_size = true;
      boolean that_present_queue_size = true;
      if (this_present_queue_size || that_present_queue_size) {
        if (!(this_present_queue_size && that_present_queue_size))
          return false;
        if (this.queue_size != that.queue_size)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(open_future_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      open_future_args typedOther = (open_future_args)other;

      lastComparison = Boolean.valueOf(isSetQueue_size()).compareTo(typedOther.isSetQueue_size());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetQueue_size()) {
        lastComparison = TBaseHelper.compareTo(this.queue_size, typedOther.queue_size);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // QUEUE_SIZE
            if (field.type == TType.I32) {
              this.queue_size = iprot.readI32();
              setQueue_sizeIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(QUEUE_SIZE_FIELD_DESC);
      oprot.writeI32(this.queue_size);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("open_future_args(");
      boolean first = true;

      sb.append("queue_size:");
      sb.append(this.queue_size);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class open_future_result implements TBase<open_future_result, open_future_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("open_future_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.I64, (short)0);
    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public long success;
    public ClientException e;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      E((short)1, "e");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // E
            return E;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __SUCCESS_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64          , "Future")));
      tmpMap.put(_Fields.E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(open_future_result.class, metaDataMap);
    }

    public open_future_result() {
    }

    public open_future_result(
      long success,
      ClientException e)
    {
      this();
      this.success = success;
      setSuccessIsSet(true);
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public open_future_result(open_future_result other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.success = other.success;
      if (other.isSetE()) {
        this.e = new ClientException(other.e);
      }
    }

    public open_future_result deepCopy() {
      return new open_future_result(this);
    }

    @Override
    public void clear() {
      setSuccessIsSet(false);
      this.success = 0;
      this.e = null;
    }

    public long getSuccess() {
      return this.success;
    }

    public open_future_result setSuccess(long success) {
      this.success = success;
      setSuccessIsSet(true);
      return this;
    }

    public void unsetSuccess() {
      __isset_bit_vector.clear(__SUCCESS_ISSET_ID);
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return __isset_bit_vector.get(__SUCCESS_ISSET_ID);
    }

    public void setSuccessIsSet(boolean value) {
      __isset_bit_vector.set(__SUCCESS_ISSET_ID, value);
    }

    public ClientException getE() {
      return this.e;
    }

    public open_future_result setE(ClientException e) {
      this.e = e;
      return this;
    }

    public void unsetE() {
      this.e = null;
    }

    /** Returns true if field e is set (has been asigned a value) and false otherwise */
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Long)value);
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((ClientException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return new Long(getSuccess());

      case E:
        return getE();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof open_future_result)
        return this.equals((open_future_result)that);
      return false;
    }

    public boolean equals(open_future_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(open_future_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      open_future_result typedOther = (open_future_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetE()).compareTo(typedOther.isSetE());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetE()) {
        lastComparison = TBaseHelper.compareTo(this.e, typedOther.e);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.I64) {
              this.success = iprot.readI64();
              setSuccessIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // E
            if (field.type == TType.STRUCT) {
              this.e = new ClientException();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeI64(this.success);
        oprot.writeFieldEnd();
      } else if (this.isSetE()) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("open_future_result(");
      boolean first = true;

      sb.append("success:");
      sb.append(this.success);
      first = false;
      if (!first) sb.append(", ");
      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_future_result_args implements TBase<get_future_result_args, get_future_result_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_future_result_args");

    private static final TField FF_FIELD_DESC = new TField("ff", TType.I64, (short)1);

    public long ff;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      FF((short)1, "ff");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // FF
            return FF;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __FF_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.FF, new FieldMetaData("ff", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64          , "Future")));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(get_future_result_args.class, metaDataMap);
    }

    public get_future_result_args() {
    }

    public get_future_result_args(
      long ff)
    {
      this();
      this.ff = ff;
      setFfIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_future_result_args(get_future_result_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.ff = other.ff;
    }

    public get_future_result_args deepCopy() {
      return new get_future_result_args(this);
    }

    @Override
    public void clear() {
      setFfIsSet(false);
      this.ff = 0;
    }

    public long getFf() {
      return this.ff;
    }

    public get_future_result_args setFf(long ff) {
      this.ff = ff;
      setFfIsSet(true);
      return this;
    }

    public void unsetFf() {
      __isset_bit_vector.clear(__FF_ISSET_ID);
    }

    /** Returns true if field ff is set (has been asigned a value) and false otherwise */
    public boolean isSetFf() {
      return __isset_bit_vector.get(__FF_ISSET_ID);
    }

    public void setFfIsSet(boolean value) {
      __isset_bit_vector.set(__FF_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case FF:
        if (value == null) {
          unsetFf();
        } else {
          setFf((Long)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case FF:
        return new Long(getFf());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case FF:
        return isSetFf();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_future_result_args)
        return this.equals((get_future_result_args)that);
      return false;
    }

    public boolean equals(get_future_result_args that) {
      if (that == null)
        return false;

      boolean this_present_ff = true;
      boolean that_present_ff = true;
      if (this_present_ff || that_present_ff) {
        if (!(this_present_ff && that_present_ff))
          return false;
        if (this.ff != that.ff)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_future_result_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_future_result_args typedOther = (get_future_result_args)other;

      lastComparison = Boolean.valueOf(isSetFf()).compareTo(typedOther.isSetFf());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetFf()) {
        lastComparison = TBaseHelper.compareTo(this.ff, typedOther.ff);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // FF
            if (field.type == TType.I64) {
              this.ff = iprot.readI64();
              setFfIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(FF_FIELD_DESC);
      oprot.writeI64(this.ff);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_future_result_args(");
      boolean first = true;

      sb.append("ff:");
      sb.append(this.ff);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_future_result_result implements TBase<get_future_result_result, get_future_result_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_future_result_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);
    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public Result success;
    public ClientException e;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      E((short)1, "e");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // E
            return E;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, Result.class)));
      tmpMap.put(_Fields.E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(get_future_result_result.class, metaDataMap);
    }

    public get_future_result_result() {
    }

    public get_future_result_result(
      Result success,
      ClientException e)
    {
      this();
      this.success = success;
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_future_result_result(get_future_result_result other) {
      if (other.isSetSuccess()) {
        this.success = new Result(other.success);
      }
      if (other.isSetE()) {
        this.e = new ClientException(other.e);
      }
    }

    public get_future_result_result deepCopy() {
      return new get_future_result_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.e = null;
    }

    public Result getSuccess() {
      return this.success;
    }

    public get_future_result_result setSuccess(Result success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public ClientException getE() {
      return this.e;
    }

    public get_future_result_result setE(ClientException e) {
      this.e = e;
      return this;
    }

    public void unsetE() {
      this.e = null;
    }

    /** Returns true if field e is set (has been asigned a value) and false otherwise */
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Result)value);
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((ClientException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case E:
        return getE();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_future_result_result)
        return this.equals((get_future_result_result)that);
      return false;
    }

    public boolean equals(get_future_result_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_future_result_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_future_result_result typedOther = (get_future_result_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetE()).compareTo(typedOther.isSetE());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetE()) {
        lastComparison = TBaseHelper.compareTo(this.e, typedOther.e);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.STRUCT) {
              this.success = new Result();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // E
            if (field.type == TType.STRUCT) {
              this.e = new ClientException();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetE()) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_future_result_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_future_result_as_arrays_args implements TBase<get_future_result_as_arrays_args, get_future_result_as_arrays_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_future_result_as_arrays_args");

    private static final TField FF_FIELD_DESC = new TField("ff", TType.I64, (short)1);

    public long ff;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      FF((short)1, "ff");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // FF
            return FF;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __FF_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.FF, new FieldMetaData("ff", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64          , "Future")));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(get_future_result_as_arrays_args.class, metaDataMap);
    }

    public get_future_result_as_arrays_args() {
    }

    public get_future_result_as_arrays_args(
      long ff)
    {
      this();
      this.ff = ff;
      setFfIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_future_result_as_arrays_args(get_future_result_as_arrays_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.ff = other.ff;
    }

    public get_future_result_as_arrays_args deepCopy() {
      return new get_future_result_as_arrays_args(this);
    }

    @Override
    public void clear() {
      setFfIsSet(false);
      this.ff = 0;
    }

    public long getFf() {
      return this.ff;
    }

    public get_future_result_as_arrays_args setFf(long ff) {
      this.ff = ff;
      setFfIsSet(true);
      return this;
    }

    public void unsetFf() {
      __isset_bit_vector.clear(__FF_ISSET_ID);
    }

    /** Returns true if field ff is set (has been asigned a value) and false otherwise */
    public boolean isSetFf() {
      return __isset_bit_vector.get(__FF_ISSET_ID);
    }

    public void setFfIsSet(boolean value) {
      __isset_bit_vector.set(__FF_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case FF:
        if (value == null) {
          unsetFf();
        } else {
          setFf((Long)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case FF:
        return new Long(getFf());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case FF:
        return isSetFf();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_future_result_as_arrays_args)
        return this.equals((get_future_result_as_arrays_args)that);
      return false;
    }

    public boolean equals(get_future_result_as_arrays_args that) {
      if (that == null)
        return false;

      boolean this_present_ff = true;
      boolean that_present_ff = true;
      if (this_present_ff || that_present_ff) {
        if (!(this_present_ff && that_present_ff))
          return false;
        if (this.ff != that.ff)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_future_result_as_arrays_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_future_result_as_arrays_args typedOther = (get_future_result_as_arrays_args)other;

      lastComparison = Boolean.valueOf(isSetFf()).compareTo(typedOther.isSetFf());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetFf()) {
        lastComparison = TBaseHelper.compareTo(this.ff, typedOther.ff);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // FF
            if (field.type == TType.I64) {
              this.ff = iprot.readI64();
              setFfIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(FF_FIELD_DESC);
      oprot.writeI64(this.ff);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_future_result_as_arrays_args(");
      boolean first = true;

      sb.append("ff:");
      sb.append(this.ff);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_future_result_as_arrays_result implements TBase<get_future_result_as_arrays_result, get_future_result_as_arrays_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_future_result_as_arrays_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);
    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public ResultAsArrays success;
    public ClientException e;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      E((short)1, "e");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // E
            return E;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ResultAsArrays.class)));
      tmpMap.put(_Fields.E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(get_future_result_as_arrays_result.class, metaDataMap);
    }

    public get_future_result_as_arrays_result() {
    }

    public get_future_result_as_arrays_result(
      ResultAsArrays success,
      ClientException e)
    {
      this();
      this.success = success;
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_future_result_as_arrays_result(get_future_result_as_arrays_result other) {
      if (other.isSetSuccess()) {
        this.success = new ResultAsArrays(other.success);
      }
      if (other.isSetE()) {
        this.e = new ClientException(other.e);
      }
    }

    public get_future_result_as_arrays_result deepCopy() {
      return new get_future_result_as_arrays_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.e = null;
    }

    public ResultAsArrays getSuccess() {
      return this.success;
    }

    public get_future_result_as_arrays_result setSuccess(ResultAsArrays success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public ClientException getE() {
      return this.e;
    }

    public get_future_result_as_arrays_result setE(ClientException e) {
      this.e = e;
      return this;
    }

    public void unsetE() {
      this.e = null;
    }

    /** Returns true if field e is set (has been asigned a value) and false otherwise */
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ResultAsArrays)value);
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((ClientException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case E:
        return getE();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_future_result_as_arrays_result)
        return this.equals((get_future_result_as_arrays_result)that);
      return false;
    }

    public boolean equals(get_future_result_as_arrays_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_future_result_as_arrays_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_future_result_as_arrays_result typedOther = (get_future_result_as_arrays_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetE()).compareTo(typedOther.isSetE());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetE()) {
        lastComparison = TBaseHelper.compareTo(this.e, typedOther.e);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.STRUCT) {
              this.success = new ResultAsArrays();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // E
            if (field.type == TType.STRUCT) {
              this.e = new ClientException();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetE()) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_future_result_as_arrays_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_future_result_serialized_args implements TBase<get_future_result_serialized_args, get_future_result_serialized_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_future_result_serialized_args");

    private static final TField FF_FIELD_DESC = new TField("ff", TType.I64, (short)1);

    public long ff;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      FF((short)1, "ff");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // FF
            return FF;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __FF_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.FF, new FieldMetaData("ff", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64          , "Future")));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(get_future_result_serialized_args.class, metaDataMap);
    }

    public get_future_result_serialized_args() {
    }

    public get_future_result_serialized_args(
      long ff)
    {
      this();
      this.ff = ff;
      setFfIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_future_result_serialized_args(get_future_result_serialized_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.ff = other.ff;
    }

    public get_future_result_serialized_args deepCopy() {
      return new get_future_result_serialized_args(this);
    }

    @Override
    public void clear() {
      setFfIsSet(false);
      this.ff = 0;
    }

    public long getFf() {
      return this.ff;
    }

    public get_future_result_serialized_args setFf(long ff) {
      this.ff = ff;
      setFfIsSet(true);
      return this;
    }

    public void unsetFf() {
      __isset_bit_vector.clear(__FF_ISSET_ID);
    }

    /** Returns true if field ff is set (has been asigned a value) and false otherwise */
    public boolean isSetFf() {
      return __isset_bit_vector.get(__FF_ISSET_ID);
    }

    public void setFfIsSet(boolean value) {
      __isset_bit_vector.set(__FF_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case FF:
        if (value == null) {
          unsetFf();
        } else {
          setFf((Long)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case FF:
        return new Long(getFf());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case FF:
        return isSetFf();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_future_result_serialized_args)
        return this.equals((get_future_result_serialized_args)that);
      return false;
    }

    public boolean equals(get_future_result_serialized_args that) {
      if (that == null)
        return false;

      boolean this_present_ff = true;
      boolean that_present_ff = true;
      if (this_present_ff || that_present_ff) {
        if (!(this_present_ff && that_present_ff))
          return false;
        if (this.ff != that.ff)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_future_result_serialized_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_future_result_serialized_args typedOther = (get_future_result_serialized_args)other;

      lastComparison = Boolean.valueOf(isSetFf()).compareTo(typedOther.isSetFf());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetFf()) {
        lastComparison = TBaseHelper.compareTo(this.ff, typedOther.ff);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // FF
            if (field.type == TType.I64) {
              this.ff = iprot.readI64();
              setFfIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(FF_FIELD_DESC);
      oprot.writeI64(this.ff);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_future_result_serialized_args(");
      boolean first = true;

      sb.append("ff:");
      sb.append(this.ff);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_future_result_serialized_result implements TBase<get_future_result_serialized_result, get_future_result_serialized_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_future_result_serialized_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);
    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public ResultSerialized success;
    public ClientException e;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      E((short)1, "e");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // E
            return E;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ResultSerialized.class)));
      tmpMap.put(_Fields.E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(get_future_result_serialized_result.class, metaDataMap);
    }

    public get_future_result_serialized_result() {
    }

    public get_future_result_serialized_result(
      ResultSerialized success,
      ClientException e)
    {
      this();
      this.success = success;
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_future_result_serialized_result(get_future_result_serialized_result other) {
      if (other.isSetSuccess()) {
        this.success = new ResultSerialized(other.success);
      }
      if (other.isSetE()) {
        this.e = new ClientException(other.e);
      }
    }

    public get_future_result_serialized_result deepCopy() {
      return new get_future_result_serialized_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.e = null;
    }

    public ResultSerialized getSuccess() {
      return this.success;
    }

    public get_future_result_serialized_result setSuccess(ResultSerialized success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public ClientException getE() {
      return this.e;
    }

    public get_future_result_serialized_result setE(ClientException e) {
      this.e = e;
      return this;
    }

    public void unsetE() {
      this.e = null;
    }

    /** Returns true if field e is set (has been asigned a value) and false otherwise */
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ResultSerialized)value);
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((ClientException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case E:
        return getE();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_future_result_serialized_result)
        return this.equals((get_future_result_serialized_result)that);
      return false;
    }

    public boolean equals(get_future_result_serialized_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_future_result_serialized_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_future_result_serialized_result typedOther = (get_future_result_serialized_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetE()).compareTo(typedOther.isSetE());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetE()) {
        lastComparison = TBaseHelper.compareTo(this.e, typedOther.e);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.STRUCT) {
              this.success = new ResultSerialized();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // E
            if (field.type == TType.STRUCT) {
              this.e = new ClientException();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetE()) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_future_result_serialized_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class close_future_args implements TBase<close_future_args, close_future_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("close_future_args");

    private static final TField FF_FIELD_DESC = new TField("ff", TType.I64, (short)1);

    public long ff;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      FF((short)1, "ff");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // FF
            return FF;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __FF_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.FF, new FieldMetaData("ff", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64          , "Future")));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(close_future_args.class, metaDataMap);
    }

    public close_future_args() {
    }

    public close_future_args(
      long ff)
    {
      this();
      this.ff = ff;
      setFfIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public close_future_args(close_future_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.ff = other.ff;
    }

    public close_future_args deepCopy() {
      return new close_future_args(this);
    }

    @Override
    public void clear() {
      setFfIsSet(false);
      this.ff = 0;
    }

    public long getFf() {
      return this.ff;
    }

    public close_future_args setFf(long ff) {
      this.ff = ff;
      setFfIsSet(true);
      return this;
    }

    public void unsetFf() {
      __isset_bit_vector.clear(__FF_ISSET_ID);
    }

    /** Returns true if field ff is set (has been asigned a value) and false otherwise */
    public boolean isSetFf() {
      return __isset_bit_vector.get(__FF_ISSET_ID);
    }

    public void setFfIsSet(boolean value) {
      __isset_bit_vector.set(__FF_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case FF:
        if (value == null) {
          unsetFf();
        } else {
          setFf((Long)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case FF:
        return new Long(getFf());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case FF:
        return isSetFf();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof close_future_args)
        return this.equals((close_future_args)that);
      return false;
    }

    public boolean equals(close_future_args that) {
      if (that == null)
        return false;

      boolean this_present_ff = true;
      boolean that_present_ff = true;
      if (this_present_ff || that_present_ff) {
        if (!(this_present_ff && that_present_ff))
          return false;
        if (this.ff != that.ff)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(close_future_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      close_future_args typedOther = (close_future_args)other;

      lastComparison = Boolean.valueOf(isSetFf()).compareTo(typedOther.isSetFf());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetFf()) {
        lastComparison = TBaseHelper.compareTo(this.ff, typedOther.ff);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // FF
            if (field.type == TType.I64) {
              this.ff = iprot.readI64();
              setFfIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(FF_FIELD_DESC);
      oprot.writeI64(this.ff);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("close_future_args(");
      boolean first = true;

      sb.append("ff:");
      sb.append(this.ff);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class close_future_result implements TBase<close_future_result, close_future_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("close_future_result");

    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public ClientException e;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      E((short)1, "e");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // E
            return E;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(close_future_result.class, metaDataMap);
    }

    public close_future_result() {
    }

    public close_future_result(
      ClientException e)
    {
      this();
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public close_future_result(close_future_result other) {
      if (other.isSetE()) {
        this.e = new ClientException(other.e);
      }
    }

    public close_future_result deepCopy() {
      return new close_future_result(this);
    }

    @Override
    public void clear() {
      this.e = null;
    }

    public ClientException getE() {
      return this.e;
    }

    public close_future_result setE(ClientException e) {
      this.e = e;
      return this;
    }

    public void unsetE() {
      this.e = null;
    }

    /** Returns true if field e is set (has been asigned a value) and false otherwise */
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((ClientException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case E:
        return getE();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case E:
        return isSetE();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof close_future_result)
        return this.equals((close_future_result)that);
      return false;
    }

    public boolean equals(close_future_result that) {
      if (that == null)
        return false;

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(close_future_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      close_future_result typedOther = (close_future_result)other;

      lastComparison = Boolean.valueOf(isSetE()).compareTo(typedOther.isSetE());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetE()) {
        lastComparison = TBaseHelper.compareTo(this.e, typedOther.e);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // E
            if (field.type == TType.STRUCT) {
              this.e = new ClientException();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetE()) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("close_future_result(");
      boolean first = true;

      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class open_scanner_args implements TBase<open_scanner_args, open_scanner_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("open_scanner_args");

    private static final TField NS_FIELD_DESC = new TField("ns", TType.I64, (short)1);
    private static final TField TABLE_NAME_FIELD_DESC = new TField("table_name", TType.STRING, (short)2);
    private static final TField SCAN_SPEC_FIELD_DESC = new TField("scan_spec", TType.STRUCT, (short)3);
    private static final TField RETRY_TABLE_NOT_FOUND_FIELD_DESC = new TField("retry_table_not_found", TType.BOOL, (short)4);

    public long ns;
    public String table_name;
    public ScanSpec scan_spec;
    public boolean retry_table_not_found;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      NS((short)1, "ns"),
      TABLE_NAME((short)2, "table_name"),
      SCAN_SPEC((short)3, "scan_spec"),
      RETRY_TABLE_NOT_FOUND((short)4, "retry_table_not_found");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // NS
            return NS;
          case 2: // TABLE_NAME
            return TABLE_NAME;
          case 3: // SCAN_SPEC
            return SCAN_SPEC;
          case 4: // RETRY_TABLE_NOT_FOUND
            return RETRY_TABLE_NOT_FOUND;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __NS_ISSET_ID = 0;
    private static final int __RETRY_TABLE_NOT_FOUND_ISSET_ID = 1;
    private BitSet __isset_bit_vector = new BitSet(2);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.NS, new FieldMetaData("ns", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64          , "Namespace")));
      tmpMap.put(_Fields.TABLE_NAME, new FieldMetaData("table_name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.SCAN_SPEC, new FieldMetaData("scan_spec", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ScanSpec.class)));
      tmpMap.put(_Fields.RETRY_TABLE_NOT_FOUND, new FieldMetaData("retry_table_not_found", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.BOOL)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(open_scanner_args.class, metaDataMap);
    }

    public open_scanner_args() {
      this.retry_table_not_found = false;

    }

    public open_scanner_args(
      long ns,
      String table_name,
      ScanSpec scan_spec,
      boolean retry_table_not_found)
    {
      this();
      this.ns = ns;
      setNsIsSet(true);
      this.table_name = table_name;
      this.scan_spec = scan_spec;
      this.retry_table_not_found = retry_table_not_found;
      setRetry_table_not_foundIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public open_scanner_args(open_scanner_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.ns = other.ns;
      if (other.isSetTable_name()) {
        this.table_name = other.table_name;
      }
      if (other.isSetScan_spec()) {
        this.scan_spec = new ScanSpec(other.scan_spec);
      }
      this.retry_table_not_found = other.retry_table_not_found;
    }

    public open_scanner_args deepCopy() {
      return new open_scanner_args(this);
    }

    @Override
    public void clear() {
      setNsIsSet(false);
      this.ns = 0;
      this.table_name = null;
      this.scan_spec = null;
      this.retry_table_not_found = false;

    }

    public long getNs() {
      return this.ns;
    }

    public open_scanner_args setNs(long ns) {
      this.ns = ns;
      setNsIsSet(true);
      return this;
    }

    public void unsetNs() {
      __isset_bit_vector.clear(__NS_ISSET_ID);
    }

    /** Returns true if field ns is set (has been asigned a value) and false otherwise */
    public boolean isSetNs() {
      return __isset_bit_vector.get(__NS_ISSET_ID);
    }

    public void setNsIsSet(boolean value) {
      __isset_bit_vector.set(__NS_ISSET_ID, value);
    }

    public String getTable_name() {
      return this.table_name;
    }

    public open_scanner_args setTable_name(String table_name) {
      this.table_name = table_name;
      return this;
    }

    public void unsetTable_name() {
      this.table_name = null;
    }

    /** Returns true if field table_name is set (has been asigned a value) and false otherwise */
    public boolean isSetTable_name() {
      return this.table_name != null;
    }

    public void setTable_nameIsSet(boolean value) {
      if (!value) {
        this.table_name = null;
      }
    }

    public ScanSpec getScan_spec() {
      return this.scan_spec;
    }

    public open_scanner_args setScan_spec(ScanSpec scan_spec) {
      this.scan_spec = scan_spec;
      return this;
    }

    public void unsetScan_spec() {
      this.scan_spec = null;
    }

    /** Returns true if field scan_spec is set (has been asigned a value) and false otherwise */
    public boolean isSetScan_spec() {
      return this.scan_spec != null;
    }

    public void setScan_specIsSet(boolean value) {
      if (!value) {
        this.scan_spec = null;
      }
    }

    public boolean isRetry_table_not_found() {
      return this.retry_table_not_found;
    }

    public open_scanner_args setRetry_table_not_found(boolean retry_table_not_found) {
      this.retry_table_not_found = retry_table_not_found;
      setRetry_table_not_foundIsSet(true);
      return this;
    }

    public void unsetRetry_table_not_found() {
      __isset_bit_vector.clear(__RETRY_TABLE_NOT_FOUND_ISSET_ID);
    }

    /** Returns true if field retry_table_not_found is set (has been asigned a value) and false otherwise */
    public boolean isSetRetry_table_not_found() {
      return __isset_bit_vector.get(__RETRY_TABLE_NOT_FOUND_ISSET_ID);
    }

    public void setRetry_table_not_foundIsSet(boolean value) {
      __isset_bit_vector.set(__RETRY_TABLE_NOT_FOUND_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case NS:
        if (value == null) {
          unsetNs();
        } else {
          setNs((Long)value);
        }
        break;

      case TABLE_NAME:
        if (value == null) {
          unsetTable_name();
        } else {
          setTable_name((String)value);
        }
        break;

      case SCAN_SPEC:
        if (value == null) {
          unsetScan_spec();
        } else {
          setScan_spec((ScanSpec)value);
        }
        break;

      case RETRY_TABLE_NOT_FOUND:
        if (value == null) {
          unsetRetry_table_not_found();
        } else {
          setRetry_table_not_found((Boolean)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case NS:
        return new Long(getNs());

      case TABLE_NAME:
        return getTable_name();

      case SCAN_SPEC:
        return getScan_spec();

      case RETRY_TABLE_NOT_FOUND:
        return new Boolean(isRetry_table_not_found());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case NS:
        return isSetNs();
      case TABLE_NAME:
        return isSetTable_name();
      case SCAN_SPEC:
        return isSetScan_spec();
      case RETRY_TABLE_NOT_FOUND:
        return isSetRetry_table_not_found();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof open_scanner_args)
        return this.equals((open_scanner_args)that);
      return false;
    }

    public boolean equals(open_scanner_args that) {
      if (that == null)
        return false;

      boolean this_present_ns = true;
      boolean that_present_ns = true;
      if (this_present_ns || that_present_ns) {
        if (!(this_present_ns && that_present_ns))
          return false;
        if (this.ns != that.ns)
          return false;
      }

      boolean this_present_table_name = true && this.isSetTable_name();
      boolean that_present_table_name = true && that.isSetTable_name();
      if (this_present_table_name || that_present_table_name) {
        if (!(this_present_table_name && that_present_table_name))
          return false;
        if (!this.table_name.equals(that.table_name))
          return false;
      }

      boolean this_present_scan_spec = true && this.isSetScan_spec();
      boolean that_present_scan_spec = true && that.isSetScan_spec();
      if (this_present_scan_spec || that_present_scan_spec) {
        if (!(this_present_scan_spec && that_present_scan_spec))
          return false;
        if (!this.scan_spec.equals(that.scan_spec))
          return false;
      }

      boolean this_present_retry_table_not_found = true;
      boolean that_present_retry_table_not_found = true;
      if (this_present_retry_table_not_found || that_present_retry_table_not_found) {
        if (!(this_present_retry_table_not_found && that_present_retry_table_not_found))
          return false;
        if (this.retry_table_not_found != that.retry_table_not_found)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(open_scanner_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      open_scanner_args typedOther = (open_scanner_args)other;

      lastComparison = Boolean.valueOf(isSetNs()).compareTo(typedOther.isSetNs());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetNs()) {
        lastComparison = TBaseHelper.compareTo(this.ns, typedOther.ns);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetTable_name()).compareTo(typedOther.isSetTable_name());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTable_name()) {
        lastComparison = TBaseHelper.compareTo(this.table_name, typedOther.table_name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetScan_spec()).compareTo(typedOther.isSetScan_spec());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetScan_spec()) {
        lastComparison = TBaseHelper.compareTo(this.scan_spec, typedOther.scan_spec);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetRetry_table_not_found()).compareTo(typedOther.isSetRetry_table_not_found());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetRetry_table_not_found()) {
        lastComparison = TBaseHelper.compareTo(this.retry_table_not_found, typedOther.retry_table_not_found);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // NS
            if (field.type == TType.I64) {
              this.ns = iprot.readI64();
              setNsIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // TABLE_NAME
            if (field.type == TType.STRING) {
              this.table_name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // SCAN_SPEC
            if (field.type == TType.STRUCT) {
              this.scan_spec = new ScanSpec();
              this.scan_spec.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 4: // RETRY_TABLE_NOT_FOUND
            if (field.type == TType.BOOL) {
              this.retry_table_not_found = iprot.readBool();
              setRetry_table_not_foundIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(NS_FIELD_DESC);
      oprot.writeI64(this.ns);
      oprot.writeFieldEnd();
      if (this.table_name != null) {
        oprot.writeFieldBegin(TABLE_NAME_FIELD_DESC);
        oprot.writeString(this.table_name);
        oprot.writeFieldEnd();
      }
      if (this.scan_spec != null) {
        oprot.writeFieldBegin(SCAN_SPEC_FIELD_DESC);
        this.scan_spec.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(RETRY_TABLE_NOT_FOUND_FIELD_DESC);
      oprot.writeBool(this.retry_table_not_found);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("open_scanner_args(");
      boolean first = true;

      sb.append("ns:");
      sb.append(this.ns);
      first = false;
      if (!first) sb.append(", ");
      sb.append("table_name:");
      if (this.table_name == null) {
        sb.append("null");
      } else {
        sb.append(this.table_name);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("scan_spec:");
      if (this.scan_spec == null) {
        sb.append("null");
      } else {
        sb.append(this.scan_spec);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("retry_table_not_found:");
      sb.append(this.retry_table_not_found);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class open_scanner_result implements TBase<open_scanner_result, open_scanner_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("open_scanner_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.I64, (short)0);
    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public long success;
    public ClientException e;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      E((short)1, "e");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // E
            return E;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __SUCCESS_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64          , "Scanner")));
      tmpMap.put(_Fields.E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(open_scanner_result.class, metaDataMap);
    }

    public open_scanner_result() {
    }

    public open_scanner_result(
      long success,
      ClientException e)
    {
      this();
      this.success = success;
      setSuccessIsSet(true);
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public open_scanner_result(open_scanner_result other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.success = other.success;
      if (other.isSetE()) {
        this.e = new ClientException(other.e);
      }
    }

    public open_scanner_result deepCopy() {
      return new open_scanner_result(this);
    }

    @Override
    public void clear() {
      setSuccessIsSet(false);
      this.success = 0;
      this.e = null;
    }

    public long getSuccess() {
      return this.success;
    }

    public open_scanner_result setSuccess(long success) {
      this.success = success;
      setSuccessIsSet(true);
      return this;
    }

    public void unsetSuccess() {
      __isset_bit_vector.clear(__SUCCESS_ISSET_ID);
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return __isset_bit_vector.get(__SUCCESS_ISSET_ID);
    }

    public void setSuccessIsSet(boolean value) {
      __isset_bit_vector.set(__SUCCESS_ISSET_ID, value);
    }

    public ClientException getE() {
      return this.e;
    }

    public open_scanner_result setE(ClientException e) {
      this.e = e;
      return this;
    }

    public void unsetE() {
      this.e = null;
    }

    /** Returns true if field e is set (has been asigned a value) and false otherwise */
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Long)value);
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((ClientException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return new Long(getSuccess());

      case E:
        return getE();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof open_scanner_result)
        return this.equals((open_scanner_result)that);
      return false;
    }

    public boolean equals(open_scanner_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(open_scanner_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      open_scanner_result typedOther = (open_scanner_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetE()).compareTo(typedOther.isSetE());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetE()) {
        lastComparison = TBaseHelper.compareTo(this.e, typedOther.e);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.I64) {
              this.success = iprot.readI64();
              setSuccessIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // E
            if (field.type == TType.STRUCT) {
              this.e = new ClientException();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeI64(this.success);
        oprot.writeFieldEnd();
      } else if (this.isSetE()) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("open_scanner_result(");
      boolean first = true;

      sb.append("success:");
      sb.append(this.success);
      first = false;
      if (!first) sb.append(", ");
      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class open_scanner_async_args implements TBase<open_scanner_async_args, open_scanner_async_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("open_scanner_async_args");

    private static final TField NS_FIELD_DESC = new TField("ns", TType.I64, (short)1);
    private static final TField TABLE_NAME_FIELD_DESC = new TField("table_name", TType.STRING, (short)2);
    private static final TField FUTURE_FIELD_DESC = new TField("future", TType.I64, (short)3);
    private static final TField SCAN_SPEC_FIELD_DESC = new TField("scan_spec", TType.STRUCT, (short)4);
    private static final TField RETRY_TABLE_NOT_FOUND_FIELD_DESC = new TField("retry_table_not_found", TType.BOOL, (short)5);

    public long ns;
    public String table_name;
    public long future;
    public ScanSpec scan_spec;
    public boolean retry_table_not_found;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      NS((short)1, "ns"),
      TABLE_NAME((short)2, "table_name"),
      FUTURE((short)3, "future"),
      SCAN_SPEC((short)4, "scan_spec"),
      RETRY_TABLE_NOT_FOUND((short)5, "retry_table_not_found");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // NS
            return NS;
          case 2: // TABLE_NAME
            return TABLE_NAME;
          case 3: // FUTURE
            return FUTURE;
          case 4: // SCAN_SPEC
            return SCAN_SPEC;
          case 5: // RETRY_TABLE_NOT_FOUND
            return RETRY_TABLE_NOT_FOUND;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __NS_ISSET_ID = 0;
    private static final int __FUTURE_ISSET_ID = 1;
    private static final int __RETRY_TABLE_NOT_FOUND_ISSET_ID = 2;
    private BitSet __isset_bit_vector = new BitSet(3);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.NS, new FieldMetaData("ns", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64          , "Namespace")));
      tmpMap.put(_Fields.TABLE_NAME, new FieldMetaData("table_name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.FUTURE, new FieldMetaData("future", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64          , "Future")));
      tmpMap.put(_Fields.SCAN_SPEC, new FieldMetaData("scan_spec", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ScanSpec.class)));
      tmpMap.put(_Fields.RETRY_TABLE_NOT_FOUND, new FieldMetaData("retry_table_not_found", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.BOOL)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(open_scanner_async_args.class, metaDataMap);
    }

    public open_scanner_async_args() {
      this.retry_table_not_found = false;

    }

    public open_scanner_async_args(
      long ns,
      String table_name,
      long future,
      ScanSpec scan_spec,
      boolean retry_table_not_found)
    {
      this();
      this.ns = ns;
      setNsIsSet(true);
      this.table_name = table_name;
      this.future = future;
      setFutureIsSet(true);
      this.scan_spec = scan_spec;
      this.retry_table_not_found = retry_table_not_found;
      setRetry_table_not_foundIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public open_scanner_async_args(open_scanner_async_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.ns = other.ns;
      if (other.isSetTable_name()) {
        this.table_name = other.table_name;
      }
      this.future = other.future;
      if (other.isSetScan_spec()) {
        this.scan_spec = new ScanSpec(other.scan_spec);
      }
      this.retry_table_not_found = other.retry_table_not_found;
    }

    public open_scanner_async_args deepCopy() {
      return new open_scanner_async_args(this);
    }

    @Override
    public void clear() {
      setNsIsSet(false);
      this.ns = 0;
      this.table_name = null;
      setFutureIsSet(false);
      this.future = 0;
      this.scan_spec = null;
      this.retry_table_not_found = false;

    }

    public long getNs() {
      return this.ns;
    }

    public open_scanner_async_args setNs(long ns) {
      this.ns = ns;
      setNsIsSet(true);
      return this;
    }

    public void unsetNs() {
      __isset_bit_vector.clear(__NS_ISSET_ID);
    }

    /** Returns true if field ns is set (has been asigned a value) and false otherwise */
    public boolean isSetNs() {
      return __isset_bit_vector.get(__NS_ISSET_ID);
    }

    public void setNsIsSet(boolean value) {
      __isset_bit_vector.set(__NS_ISSET_ID, value);
    }

    public String getTable_name() {
      return this.table_name;
    }

    public open_scanner_async_args setTable_name(String table_name) {
      this.table_name = table_name;
      return this;
    }

    public void unsetTable_name() {
      this.table_name = null;
    }

    /** Returns true if field table_name is set (has been asigned a value) and false otherwise */
    public boolean isSetTable_name() {
      return this.table_name != null;
    }

    public void setTable_nameIsSet(boolean value) {
      if (!value) {
        this.table_name = null;
      }
    }

    public long getFuture() {
      return this.future;
    }

    public open_scanner_async_args setFuture(long future) {
      this.future = future;
      setFutureIsSet(true);
      return this;
    }

    public void unsetFuture() {
      __isset_bit_vector.clear(__FUTURE_ISSET_ID);
    }

    /** Returns true if field future is set (has been asigned a value) and false otherwise */
    public boolean isSetFuture() {
      return __isset_bit_vector.get(__FUTURE_ISSET_ID);
    }

    public void setFutureIsSet(boolean value) {
      __isset_bit_vector.set(__FUTURE_ISSET_ID, value);
    }

    public ScanSpec getScan_spec() {
      return this.scan_spec;
    }

    public open_scanner_async_args setScan_spec(ScanSpec scan_spec) {
      this.scan_spec = scan_spec;
      return this;
    }

    public void unsetScan_spec() {
      this.scan_spec = null;
    }

    /** Returns true if field scan_spec is set (has been asigned a value) and false otherwise */
    public boolean isSetScan_spec() {
      return this.scan_spec != null;
    }

    public void setScan_specIsSet(boolean value) {
      if (!value) {
        this.scan_spec = null;
      }
    }

    public boolean isRetry_table_not_found() {
      return this.retry_table_not_found;
    }

    public open_scanner_async_args setRetry_table_not_found(boolean retry_table_not_found) {
      this.retry_table_not_found = retry_table_not_found;
      setRetry_table_not_foundIsSet(true);
      return this;
    }

    public void unsetRetry_table_not_found() {
      __isset_bit_vector.clear(__RETRY_TABLE_NOT_FOUND_ISSET_ID);
    }

    /** Returns true if field retry_table_not_found is set (has been asigned a value) and false otherwise */
    public boolean isSetRetry_table_not_found() {
      return __isset_bit_vector.get(__RETRY_TABLE_NOT_FOUND_ISSET_ID);
    }

    public void setRetry_table_not_foundIsSet(boolean value) {
      __isset_bit_vector.set(__RETRY_TABLE_NOT_FOUND_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case NS:
        if (value == null) {
          unsetNs();
        } else {
          setNs((Long)value);
        }
        break;

      case TABLE_NAME:
        if (value == null) {
          unsetTable_name();
        } else {
          setTable_name((String)value);
        }
        break;

      case FUTURE:
        if (value == null) {
          unsetFuture();
        } else {
          setFuture((Long)value);
        }
        break;

      case SCAN_SPEC:
        if (value == null) {
          unsetScan_spec();
        } else {
          setScan_spec((ScanSpec)value);
        }
        break;

      case RETRY_TABLE_NOT_FOUND:
        if (value == null) {
          unsetRetry_table_not_found();
        } else {
          setRetry_table_not_found((Boolean)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case NS:
        return new Long(getNs());

      case TABLE_NAME:
        return getTable_name();

      case FUTURE:
        return new Long(getFuture());

      case SCAN_SPEC:
        return getScan_spec();

      case RETRY_TABLE_NOT_FOUND:
        return new Boolean(isRetry_table_not_found());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case NS:
        return isSetNs();
      case TABLE_NAME:
        return isSetTable_name();
      case FUTURE:
        return isSetFuture();
      case SCAN_SPEC:
        return isSetScan_spec();
      case RETRY_TABLE_NOT_FOUND:
        return isSetRetry_table_not_found();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof open_scanner_async_args)
        return this.equals((open_scanner_async_args)that);
      return false;
    }

    public boolean equals(open_scanner_async_args that) {
      if (that == null)
        return false;

      boolean this_present_ns = true;
      boolean that_present_ns = true;
      if (this_present_ns || that_present_ns) {
        if (!(this_present_ns && that_present_ns))
          return false;
        if (this.ns != that.ns)
          return false;
      }

      boolean this_present_table_name = true && this.isSetTable_name();
      boolean that_present_table_name = true && that.isSetTable_name();
      if (this_present_table_name || that_present_table_name) {
        if (!(this_present_table_name && that_present_table_name))
          return false;
        if (!this.table_name.equals(that.table_name))
          return false;
      }

      boolean this_present_future = true;
      boolean that_present_future = true;
      if (this_present_future || that_present_future) {
        if (!(this_present_future && that_present_future))
          return false;
        if (this.future != that.future)
          return false;
      }

      boolean this_present_scan_spec = true && this.isSetScan_spec();
      boolean that_present_scan_spec = true && that.isSetScan_spec();
      if (this_present_scan_spec || that_present_scan_spec) {
        if (!(this_present_scan_spec && that_present_scan_spec))
          return false;
        if (!this.scan_spec.equals(that.scan_spec))
          return false;
      }

      boolean this_present_retry_table_not_found = true;
      boolean that_present_retry_table_not_found = true;
      if (this_present_retry_table_not_found || that_present_retry_table_not_found) {
        if (!(this_present_retry_table_not_found && that_present_retry_table_not_found))
          return false;
        if (this.retry_table_not_found != that.retry_table_not_found)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(open_scanner_async_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      open_scanner_async_args typedOther = (open_scanner_async_args)other;

      lastComparison = Boolean.valueOf(isSetNs()).compareTo(typedOther.isSetNs());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetNs()) {
        lastComparison = TBaseHelper.compareTo(this.ns, typedOther.ns);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetTable_name()).compareTo(typedOther.isSetTable_name());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTable_name()) {
        lastComparison = TBaseHelper.compareTo(this.table_name, typedOther.table_name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetFuture()).compareTo(typedOther.isSetFuture());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetFuture()) {
        lastComparison = TBaseHelper.compareTo(this.future, typedOther.future);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetScan_spec()).compareTo(typedOther.isSetScan_spec());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetScan_spec()) {
        lastComparison = TBaseHelper.compareTo(this.scan_spec, typedOther.scan_spec);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetRetry_table_not_found()).compareTo(typedOther.isSetRetry_table_not_found());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetRetry_table_not_found()) {
        lastComparison = TBaseHelper.compareTo(this.retry_table_not_found, typedOther.retry_table_not_found);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // NS
            if (field.type == TType.I64) {
              this.ns = iprot.readI64();
              setNsIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // TABLE_NAME
            if (field.type == TType.STRING) {
              this.table_name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // FUTURE
            if (field.type == TType.I64) {
              this.future = iprot.readI64();
              setFutureIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 4: // SCAN_SPEC
            if (field.type == TType.STRUCT) {
              this.scan_spec = new ScanSpec();
              this.scan_spec.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 5: // RETRY_TABLE_NOT_FOUND
            if (field.type == TType.BOOL) {
              this.retry_table_not_found = iprot.readBool();
              setRetry_table_not_foundIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(NS_FIELD_DESC);
      oprot.writeI64(this.ns);
      oprot.writeFieldEnd();
      if (this.table_name != null) {
        oprot.writeFieldBegin(TABLE_NAME_FIELD_DESC);
        oprot.writeString(this.table_name);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(FUTURE_FIELD_DESC);
      oprot.writeI64(this.future);
      oprot.writeFieldEnd();
      if (this.scan_spec != null) {
        oprot.writeFieldBegin(SCAN_SPEC_FIELD_DESC);
        this.scan_spec.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(RETRY_TABLE_NOT_FOUND_FIELD_DESC);
      oprot.writeBool(this.retry_table_not_found);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("open_scanner_async_args(");
      boolean first = true;

      sb.append("ns:");
      sb.append(this.ns);
      first = false;
      if (!first) sb.append(", ");
      sb.append("table_name:");
      if (this.table_name == null) {
        sb.append("null");
      } else {
        sb.append(this.table_name);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("future:");
      sb.append(this.future);
      first = false;
      if (!first) sb.append(", ");
      sb.append("scan_spec:");
      if (this.scan_spec == null) {
        sb.append("null");
      } else {
        sb.append(this.scan_spec);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("retry_table_not_found:");
      sb.append(this.retry_table_not_found);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class open_scanner_async_result implements TBase<open_scanner_async_result, open_scanner_async_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("open_scanner_async_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.I64, (short)0);
    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public long success;
    public ClientException e;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      E((short)1, "e");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // E
            return E;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __SUCCESS_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64          , "ScannerAsync")));
      tmpMap.put(_Fields.E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(open_scanner_async_result.class, metaDataMap);
    }

    public open_scanner_async_result() {
    }

    public open_scanner_async_result(
      long success,
      ClientException e)
    {
      this();
      this.success = success;
      setSuccessIsSet(true);
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public open_scanner_async_result(open_scanner_async_result other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.success = other.success;
      if (other.isSetE()) {
        this.e = new ClientException(other.e);
      }
    }

    public open_scanner_async_result deepCopy() {
      return new open_scanner_async_result(this);
    }

    @Override
    public void clear() {
      setSuccessIsSet(false);
      this.success = 0;
      this.e = null;
    }

    public long getSuccess() {
      return this.success;
    }

    public open_scanner_async_result setSuccess(long success) {
      this.success = success;
      setSuccessIsSet(true);
      return this;
    }

    public void unsetSuccess() {
      __isset_bit_vector.clear(__SUCCESS_ISSET_ID);
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return __isset_bit_vector.get(__SUCCESS_ISSET_ID);
    }

    public void setSuccessIsSet(boolean value) {
      __isset_bit_vector.set(__SUCCESS_ISSET_ID, value);
    }

    public ClientException getE() {
      return this.e;
    }

    public open_scanner_async_result setE(ClientException e) {
      this.e = e;
      return this;
    }

    public void unsetE() {
      this.e = null;
    }

    /** Returns true if field e is set (has been asigned a value) and false otherwise */
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Long)value);
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((ClientException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return new Long(getSuccess());

      case E:
        return getE();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof open_scanner_async_result)
        return this.equals((open_scanner_async_result)that);
      return false;
    }

    public boolean equals(open_scanner_async_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(open_scanner_async_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      open_scanner_async_result typedOther = (open_scanner_async_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetE()).compareTo(typedOther.isSetE());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetE()) {
        lastComparison = TBaseHelper.compareTo(this.e, typedOther.e);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.I64) {
              this.success = iprot.readI64();
              setSuccessIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // E
            if (field.type == TType.STRUCT) {
              this.e = new ClientException();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeI64(this.success);
        oprot.writeFieldEnd();
      } else if (this.isSetE()) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("open_scanner_async_result(");
      boolean first = true;

      sb.append("success:");
      sb.append(this.success);
      first = false;
      if (!first) sb.append(", ");
      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class close_scanner_args implements TBase<close_scanner_args, close_scanner_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("close_scanner_args");

    private static final TField SCANNER_FIELD_DESC = new TField("scanner", TType.I64, (short)1);

    public long scanner;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SCANNER((short)1, "scanner");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // SCANNER
            return SCANNER;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __SCANNER_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SCANNER, new FieldMetaData("scanner", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64          , "Scanner")));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(close_scanner_args.class, metaDataMap);
    }

    public close_scanner_args() {
    }

    public close_scanner_args(
      long scanner)
    {
      this();
      this.scanner = scanner;
      setScannerIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public close_scanner_args(close_scanner_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.scanner = other.scanner;
    }

    public close_scanner_args deepCopy() {
      return new close_scanner_args(this);
    }

    @Override
    public void clear() {
      setScannerIsSet(false);
      this.scanner = 0;
    }

    public long getScanner() {
      return this.scanner;
    }

    public close_scanner_args setScanner(long scanner) {
      this.scanner = scanner;
      setScannerIsSet(true);
      return this;
    }

    public void unsetScanner() {
      __isset_bit_vector.clear(__SCANNER_ISSET_ID);
    }

    /** Returns true if field scanner is set (has been asigned a value) and false otherwise */
    public boolean isSetScanner() {
      return __isset_bit_vector.get(__SCANNER_ISSET_ID);
    }

    public void setScannerIsSet(boolean value) {
      __isset_bit_vector.set(__SCANNER_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SCANNER:
        if (value == null) {
          unsetScanner();
        } else {
          setScanner((Long)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SCANNER:
        return new Long(getScanner());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SCANNER:
        return isSetScanner();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof close_scanner_args)
        return this.equals((close_scanner_args)that);
      return false;
    }

    public boolean equals(close_scanner_args that) {
      if (that == null)
        return false;

      boolean this_present_scanner = true;
      boolean that_present_scanner = true;
      if (this_present_scanner || that_present_scanner) {
        if (!(this_present_scanner && that_present_scanner))
          return false;
        if (this.scanner != that.scanner)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(close_scanner_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      close_scanner_args typedOther = (close_scanner_args)other;

      lastComparison = Boolean.valueOf(isSetScanner()).compareTo(typedOther.isSetScanner());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetScanner()) {
        lastComparison = TBaseHelper.compareTo(this.scanner, typedOther.scanner);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // SCANNER
            if (field.type == TType.I64) {
              this.scanner = iprot.readI64();
              setScannerIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(SCANNER_FIELD_DESC);
      oprot.writeI64(this.scanner);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("close_scanner_args(");
      boolean first = true;

      sb.append("scanner:");
      sb.append(this.scanner);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class close_scanner_result implements TBase<close_scanner_result, close_scanner_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("close_scanner_result");

    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public ClientException e;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      E((short)1, "e");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // E
            return E;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(close_scanner_result.class, metaDataMap);
    }

    public close_scanner_result() {
    }

    public close_scanner_result(
      ClientException e)
    {
      this();
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public close_scanner_result(close_scanner_result other) {
      if (other.isSetE()) {
        this.e = new ClientException(other.e);
      }
    }

    public close_scanner_result deepCopy() {
      return new close_scanner_result(this);
    }

    @Override
    public void clear() {
      this.e = null;
    }

    public ClientException getE() {
      return this.e;
    }

    public close_scanner_result setE(ClientException e) {
      this.e = e;
      return this;
    }

    public void unsetE() {
      this.e = null;
    }

    /** Returns true if field e is set (has been asigned a value) and false otherwise */
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((ClientException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case E:
        return getE();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case E:
        return isSetE();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof close_scanner_result)
        return this.equals((close_scanner_result)that);
      return false;
    }

    public boolean equals(close_scanner_result that) {
      if (that == null)
        return false;

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(close_scanner_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      close_scanner_result typedOther = (close_scanner_result)other;

      lastComparison = Boolean.valueOf(isSetE()).compareTo(typedOther.isSetE());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetE()) {
        lastComparison = TBaseHelper.compareTo(this.e, typedOther.e);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // E
            if (field.type == TType.STRUCT) {
              this.e = new ClientException();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetE()) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("close_scanner_result(");
      boolean first = true;

      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class close_scanner_async_args implements TBase<close_scanner_async_args, close_scanner_async_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("close_scanner_async_args");

    private static final TField SCANNER_FIELD_DESC = new TField("scanner", TType.I64, (short)1);

    public long scanner;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SCANNER((short)1, "scanner");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // SCANNER
            return SCANNER;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __SCANNER_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SCANNER, new FieldMetaData("scanner", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64          , "ScannerAsync")));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(close_scanner_async_args.class, metaDataMap);
    }

    public close_scanner_async_args() {
    }

    public close_scanner_async_args(
      long scanner)
    {
      this();
      this.scanner = scanner;
      setScannerIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public close_scanner_async_args(close_scanner_async_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.scanner = other.scanner;
    }

    public close_scanner_async_args deepCopy() {
      return new close_scanner_async_args(this);
    }

    @Override
    public void clear() {
      setScannerIsSet(false);
      this.scanner = 0;
    }

    public long getScanner() {
      return this.scanner;
    }

    public close_scanner_async_args setScanner(long scanner) {
      this.scanner = scanner;
      setScannerIsSet(true);
      return this;
    }

    public void unsetScanner() {
      __isset_bit_vector.clear(__SCANNER_ISSET_ID);
    }

    /** Returns true if field scanner is set (has been asigned a value) and false otherwise */
    public boolean isSetScanner() {
      return __isset_bit_vector.get(__SCANNER_ISSET_ID);
    }

    public void setScannerIsSet(boolean value) {
      __isset_bit_vector.set(__SCANNER_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SCANNER:
        if (value == null) {
          unsetScanner();
        } else {
          setScanner((Long)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SCANNER:
        return new Long(getScanner());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SCANNER:
        return isSetScanner();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof close_scanner_async_args)
        return this.equals((close_scanner_async_args)that);
      return false;
    }

    public boolean equals(close_scanner_async_args that) {
      if (that == null)
        return false;

      boolean this_present_scanner = true;
      boolean that_present_scanner = true;
      if (this_present_scanner || that_present_scanner) {
        if (!(this_present_scanner && that_present_scanner))
          return false;
        if (this.scanner != that.scanner)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(close_scanner_async_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      close_scanner_async_args typedOther = (close_scanner_async_args)other;

      lastComparison = Boolean.valueOf(isSetScanner()).compareTo(typedOther.isSetScanner());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetScanner()) {
        lastComparison = TBaseHelper.compareTo(this.scanner, typedOther.scanner);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // SCANNER
            if (field.type == TType.I64) {
              this.scanner = iprot.readI64();
              setScannerIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(SCANNER_FIELD_DESC);
      oprot.writeI64(this.scanner);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("close_scanner_async_args(");
      boolean first = true;

      sb.append("scanner:");
      sb.append(this.scanner);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class close_scanner_async_result implements TBase<close_scanner_async_result, close_scanner_async_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("close_scanner_async_result");

    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public ClientException e;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      E((short)1, "e");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // E
            return E;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(close_scanner_async_result.class, metaDataMap);
    }

    public close_scanner_async_result() {
    }

    public close_scanner_async_result(
      ClientException e)
    {
      this();
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public close_scanner_async_result(close_scanner_async_result other) {
      if (other.isSetE()) {
        this.e = new ClientException(other.e);
      }
    }

    public close_scanner_async_result deepCopy() {
      return new close_scanner_async_result(this);
    }

    @Override
    public void clear() {
      this.e = null;
    }

    public ClientException getE() {
      return this.e;
    }

    public close_scanner_async_result setE(ClientException e) {
      this.e = e;
      return this;
    }

    public void unsetE() {
      this.e = null;
    }

    /** Returns true if field e is set (has been asigned a value) and false otherwise */
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((ClientException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case E:
        return getE();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case E:
        return isSetE();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof close_scanner_async_result)
        return this.equals((close_scanner_async_result)that);
      return false;
    }

    public boolean equals(close_scanner_async_result that) {
      if (that == null)
        return false;

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(close_scanner_async_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      close_scanner_async_result typedOther = (close_scanner_async_result)other;

      lastComparison = Boolean.valueOf(isSetE()).compareTo(typedOther.isSetE());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetE()) {
        lastComparison = TBaseHelper.compareTo(this.e, typedOther.e);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // E
            if (field.type == TType.STRUCT) {
              this.e = new ClientException();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetE()) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("close_scanner_async_result(");
      boolean first = true;

      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class next_cells_args implements TBase<next_cells_args, next_cells_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("next_cells_args");

    private static final TField SCANNER_FIELD_DESC = new TField("scanner", TType.I64, (short)1);

    public long scanner;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SCANNER((short)1, "scanner");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // SCANNER
            return SCANNER;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __SCANNER_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SCANNER, new FieldMetaData("scanner", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64          , "Scanner")));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(next_cells_args.class, metaDataMap);
    }

    public next_cells_args() {
    }

    public next_cells_args(
      long scanner)
    {
      this();
      this.scanner = scanner;
      setScannerIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public next_cells_args(next_cells_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.scanner = other.scanner;
    }

    public next_cells_args deepCopy() {
      return new next_cells_args(this);
    }

    @Override
    public void clear() {
      setScannerIsSet(false);
      this.scanner = 0;
    }

    public long getScanner() {
      return this.scanner;
    }

    public next_cells_args setScanner(long scanner) {
      this.scanner = scanner;
      setScannerIsSet(true);
      return this;
    }

    public void unsetScanner() {
      __isset_bit_vector.clear(__SCANNER_ISSET_ID);
    }

    /** Returns true if field scanner is set (has been asigned a value) and false otherwise */
    public boolean isSetScanner() {
      return __isset_bit_vector.get(__SCANNER_ISSET_ID);
    }

    public void setScannerIsSet(boolean value) {
      __isset_bit_vector.set(__SCANNER_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SCANNER:
        if (value == null) {
          unsetScanner();
        } else {
          setScanner((Long)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SCANNER:
        return new Long(getScanner());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SCANNER:
        return isSetScanner();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof next_cells_args)
        return this.equals((next_cells_args)that);
      return false;
    }

    public boolean equals(next_cells_args that) {
      if (that == null)
        return false;

      boolean this_present_scanner = true;
      boolean that_present_scanner = true;
      if (this_present_scanner || that_present_scanner) {
        if (!(this_present_scanner && that_present_scanner))
          return false;
        if (this.scanner != that.scanner)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(next_cells_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      next_cells_args typedOther = (next_cells_args)other;

      lastComparison = Boolean.valueOf(isSetScanner()).compareTo(typedOther.isSetScanner());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetScanner()) {
        lastComparison = TBaseHelper.compareTo(this.scanner, typedOther.scanner);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // SCANNER
            if (field.type == TType.I64) {
              this.scanner = iprot.readI64();
              setScannerIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(SCANNER_FIELD_DESC);
      oprot.writeI64(this.scanner);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("next_cells_args(");
      boolean first = true;

      sb.append("scanner:");
      sb.append(this.scanner);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class next_cells_result implements TBase<next_cells_result, next_cells_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("next_cells_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public List<Cell> success;
    public ClientException e;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      E((short)1, "e");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // E
            return E;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new StructMetaData(TType.STRUCT, Cell.class))));
      tmpMap.put(_Fields.E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(next_cells_result.class, metaDataMap);
    }

    public next_cells_result() {
    }

    public next_cells_result(
      List<Cell> success,
      ClientException e)
    {
      this();
      this.success = success;
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public next_cells_result(next_cells_result other) {
      if (other.isSetSuccess()) {
        List<Cell> __this__success = new ArrayList<Cell>();
        for (Cell other_element : other.success) {
          __this__success.add(new Cell(other_element));
        }
        this.success = __this__success;
      }
      if (other.isSetE()) {
        this.e = new ClientException(other.e);
      }
    }

    public next_cells_result deepCopy() {
      return new next_cells_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.e = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<Cell> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(Cell elem) {
      if (this.success == null) {
        this.success = new ArrayList<Cell>();
      }
      this.success.add(elem);
    }

    public List<Cell> getSuccess() {
      return this.success;
    }

    public next_cells_result setSuccess(List<Cell> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public ClientException getE() {
      return this.e;
    }

    public next_cells_result setE(ClientException e) {
      this.e = e;
      return this;
    }

    public void unsetE() {
      this.e = null;
    }

    /** Returns true if field e is set (has been asigned a value) and false otherwise */
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<Cell>)value);
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((ClientException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case E:
        return getE();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof next_cells_result)
        return this.equals((next_cells_result)that);
      return false;
    }

    public boolean equals(next_cells_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(next_cells_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      next_cells_result typedOther = (next_cells_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetE()).compareTo(typedOther.isSetE());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetE()) {
        lastComparison = TBaseHelper.compareTo(this.e, typedOther.e);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.LIST) {
              {
                TList _list38 = iprot.readListBegin();
                this.success = new ArrayList<Cell>(_list38.size);
                for (int _i39 = 0; _i39 < _list38.size; ++_i39)
                {
                  Cell _elem40;
                  _elem40 = new Cell();
                  _elem40.read(iprot);
                  this.success.add(_elem40);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // E
            if (field.type == TType.STRUCT) {
              this.e = new ClientException();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
          for (Cell _iter41 : this.success)
          {
            _iter41.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetE()) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("next_cells_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class next_cells_as_arrays_args implements TBase<next_cells_as_arrays_args, next_cells_as_arrays_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("next_cells_as_arrays_args");

    private static final TField SCANNER_FIELD_DESC = new TField("scanner", TType.I64, (short)1);

    public long scanner;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SCANNER((short)1, "scanner");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // SCANNER
            return SCANNER;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __SCANNER_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SCANNER, new FieldMetaData("scanner", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64          , "Scanner")));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(next_cells_as_arrays_args.class, metaDataMap);
    }

    public next_cells_as_arrays_args() {
    }

    public next_cells_as_arrays_args(
      long scanner)
    {
      this();
      this.scanner = scanner;
      setScannerIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public next_cells_as_arrays_args(next_cells_as_arrays_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.scanner = other.scanner;
    }

    public next_cells_as_arrays_args deepCopy() {
      return new next_cells_as_arrays_args(this);
    }

    @Override
    public void clear() {
      setScannerIsSet(false);
      this.scanner = 0;
    }

    public long getScanner() {
      return this.scanner;
    }

    public next_cells_as_arrays_args setScanner(long scanner) {
      this.scanner = scanner;
      setScannerIsSet(true);
      return this;
    }

    public void unsetScanner() {
      __isset_bit_vector.clear(__SCANNER_ISSET_ID);
    }

    /** Returns true if field scanner is set (has been asigned a value) and false otherwise */
    public boolean isSetScanner() {
      return __isset_bit_vector.get(__SCANNER_ISSET_ID);
    }

    public void setScannerIsSet(boolean value) {
      __isset_bit_vector.set(__SCANNER_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SCANNER:
        if (value == null) {
          unsetScanner();
        } else {
          setScanner((Long)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SCANNER:
        return new Long(getScanner());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SCANNER:
        return isSetScanner();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof next_cells_as_arrays_args)
        return this.equals((next_cells_as_arrays_args)that);
      return false;
    }

    public boolean equals(next_cells_as_arrays_args that) {
      if (that == null)
        return false;

      boolean this_present_scanner = true;
      boolean that_present_scanner = true;
      if (this_present_scanner || that_present_scanner) {
        if (!(this_present_scanner && that_present_scanner))
          return false;
        if (this.scanner != that.scanner)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(next_cells_as_arrays_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      next_cells_as_arrays_args typedOther = (next_cells_as_arrays_args)other;

      lastComparison = Boolean.valueOf(isSetScanner()).compareTo(typedOther.isSetScanner());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetScanner()) {
        lastComparison = TBaseHelper.compareTo(this.scanner, typedOther.scanner);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // SCANNER
            if (field.type == TType.I64) {
              this.scanner = iprot.readI64();
              setScannerIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(SCANNER_FIELD_DESC);
      oprot.writeI64(this.scanner);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("next_cells_as_arrays_args(");
      boolean first = true;

      sb.append("scanner:");
      sb.append(this.scanner);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class next_cells_as_arrays_result implements TBase<next_cells_as_arrays_result, next_cells_as_arrays_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("next_cells_as_arrays_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public List<List<String>> success;
    public ClientException e;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      E((short)1, "e");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // E
            return E;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.LIST              , "CellAsArray"))));
      tmpMap.put(_Fields.E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(next_cells_as_arrays_result.class, metaDataMap);
    }

    public next_cells_as_arrays_result() {
    }

    public next_cells_as_arrays_result(
      List<List<String>> success,
      ClientException e)
    {
      this();
      this.success = success;
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public next_cells_as_arrays_result(next_cells_as_arrays_result other) {
      if (other.isSetSuccess()) {
        List<List<String>> __this__success = new ArrayList<List<String>>();
        for (List<String> other_element : other.success) {
          __this__success.add(other_element);
        }
        this.success = __this__success;
      }
      if (other.isSetE()) {
        this.e = new ClientException(other.e);
      }
    }

    public next_cells_as_arrays_result deepCopy() {
      return new next_cells_as_arrays_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.e = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<List<String>> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(List<String> elem) {
      if (this.success == null) {
        this.success = new ArrayList<List<String>>();
      }
      this.success.add(elem);
    }

    public List<List<String>> getSuccess() {
      return this.success;
    }

    public next_cells_as_arrays_result setSuccess(List<List<String>> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public ClientException getE() {
      return this.e;
    }

    public next_cells_as_arrays_result setE(ClientException e) {
      this.e = e;
      return this;
    }

    public void unsetE() {
      this.e = null;
    }

    /** Returns true if field e is set (has been asigned a value) and false otherwise */
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<List<String>>)value);
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((ClientException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case E:
        return getE();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof next_cells_as_arrays_result)
        return this.equals((next_cells_as_arrays_result)that);
      return false;
    }

    public boolean equals(next_cells_as_arrays_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(next_cells_as_arrays_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      next_cells_as_arrays_result typedOther = (next_cells_as_arrays_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetE()).compareTo(typedOther.isSetE());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetE()) {
        lastComparison = TBaseHelper.compareTo(this.e, typedOther.e);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.LIST) {
              {
                TList _list42 = iprot.readListBegin();
                this.success = new ArrayList<List<String>>(_list42.size);
                for (int _i43 = 0; _i43 < _list42.size; ++_i43)
                {
                  List<String> _elem44;
                  {
                    TList _list45 = iprot.readListBegin();
                    _elem44 = new ArrayList<String>(_list45.size);
                    for (int _i46 = 0; _i46 < _list45.size; ++_i46)
                    {
                      String _elem47;
                      _elem47 = iprot.readString();
                      _elem44.add(_elem47);
                    }
                    iprot.readListEnd();
                  }
                  this.success.add(_elem44);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // E
            if (field.type == TType.STRUCT) {
              this.e = new ClientException();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.LIST, this.success.size()));
          for (List<String> _iter48 : this.success)
          {
            {
              oprot.writeListBegin(new TList(TType.STRING, _iter48.size()));
              for (String _iter49 : _iter48)
              {
                oprot.writeString(_iter49);
              }
              oprot.writeListEnd();
            }
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetE()) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("next_cells_as_arrays_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class next_cells_serialized_args implements TBase<next_cells_serialized_args, next_cells_serialized_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("next_cells_serialized_args");

    private static final TField SCANNER_FIELD_DESC = new TField("scanner", TType.I64, (short)1);

    public long scanner;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SCANNER((short)1, "scanner");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // SCANNER
            return SCANNER;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __SCANNER_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SCANNER, new FieldMetaData("scanner", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64          , "Scanner")));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(next_cells_serialized_args.class, metaDataMap);
    }

    public next_cells_serialized_args() {
    }

    public next_cells_serialized_args(
      long scanner)
    {
      this();
      this.scanner = scanner;
      setScannerIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public next_cells_serialized_args(next_cells_serialized_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.scanner = other.scanner;
    }

    public next_cells_serialized_args deepCopy() {
      return new next_cells_serialized_args(this);
    }

    @Override
    public void clear() {
      setScannerIsSet(false);
      this.scanner = 0;
    }

    public long getScanner() {
      return this.scanner;
    }

    public next_cells_serialized_args setScanner(long scanner) {
      this.scanner = scanner;
      setScannerIsSet(true);
      return this;
    }

    public void unsetScanner() {
      __isset_bit_vector.clear(__SCANNER_ISSET_ID);
    }

    /** Returns true if field scanner is set (has been asigned a value) and false otherwise */
    public boolean isSetScanner() {
      return __isset_bit_vector.get(__SCANNER_ISSET_ID);
    }

    public void setScannerIsSet(boolean value) {
      __isset_bit_vector.set(__SCANNER_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SCANNER:
        if (value == null) {
          unsetScanner();
        } else {
          setScanner((Long)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SCANNER:
        return new Long(getScanner());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SCANNER:
        return isSetScanner();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof next_cells_serialized_args)
        return this.equals((next_cells_serialized_args)that);
      return false;
    }

    public boolean equals(next_cells_serialized_args that) {
      if (that == null)
        return false;

      boolean this_present_scanner = true;
      boolean that_present_scanner = true;
      if (this_present_scanner || that_present_scanner) {
        if (!(this_present_scanner && that_present_scanner))
          return false;
        if (this.scanner != that.scanner)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(next_cells_serialized_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      next_cells_serialized_args typedOther = (next_cells_serialized_args)other;

      lastComparison = Boolean.valueOf(isSetScanner()).compareTo(typedOther.isSetScanner());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetScanner()) {
        lastComparison = TBaseHelper.compareTo(this.scanner, typedOther.scanner);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // SCANNER
            if (field.type == TType.I64) {
              this.scanner = iprot.readI64();
              setScannerIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(SCANNER_FIELD_DESC);
      oprot.writeI64(this.scanner);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("next_cells_serialized_args(");
      boolean first = true;

      sb.append("scanner:");
      sb.append(this.scanner);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class next_cells_serialized_result implements TBase<next_cells_serialized_result, next_cells_serialized_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("next_cells_serialized_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRING, (short)0);

    public ByteBuffer success;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING          , "CellsSerialized")));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(next_cells_serialized_result.class, metaDataMap);
    }

    public next_cells_serialized_result() {
    }

    public next_cells_serialized_result(
      ByteBuffer success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public next_cells_serialized_result(next_cells_serialized_result other) {
      if (other.isSetSuccess()) {
        this.success = other.success;
      }
    }

    public next_cells_serialized_result deepCopy() {
      return new next_cells_serialized_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
    }

    public byte[] getSuccess() {
      setSuccess(TBaseHelper.rightSize(success));
      return success.array();
    }

    public ByteBuffer BufferForSuccess() {
      return success;
    }

    public next_cells_serialized_result setSuccess(byte[] success) {
      setSuccess(ByteBuffer.wrap(success));
      return this;
    }

    public next_cells_serialized_result setSuccess(ByteBuffer success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ByteBuffer)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof next_cells_serialized_result)
        return this.equals((next_cells_serialized_result)that);
      return false;
    }

    public boolean equals(next_cells_serialized_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(next_cells_serialized_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      next_cells_serialized_result typedOther = (next_cells_serialized_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.STRING) {
              this.success = iprot.readBinary();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeBinary(this.success);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("next_cells_serialized_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class next_row_args implements TBase<next_row_args, next_row_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("next_row_args");

    private static final TField SCANNER_FIELD_DESC = new TField("scanner", TType.I64, (short)1);

    public long scanner;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SCANNER((short)1, "scanner");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // SCANNER
            return SCANNER;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __SCANNER_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SCANNER, new FieldMetaData("scanner", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64          , "Scanner")));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(next_row_args.class, metaDataMap);
    }

    public next_row_args() {
    }

    public next_row_args(
      long scanner)
    {
      this();
      this.scanner = scanner;
      setScannerIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public next_row_args(next_row_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.scanner = other.scanner;
    }

    public next_row_args deepCopy() {
      return new next_row_args(this);
    }

    @Override
    public void clear() {
      setScannerIsSet(false);
      this.scanner = 0;
    }

    public long getScanner() {
      return this.scanner;
    }

    public next_row_args setScanner(long scanner) {
      this.scanner = scanner;
      setScannerIsSet(true);
      return this;
    }

    public void unsetScanner() {
      __isset_bit_vector.clear(__SCANNER_ISSET_ID);
    }

    /** Returns true if field scanner is set (has been asigned a value) and false otherwise */
    public boolean isSetScanner() {
      return __isset_bit_vector.get(__SCANNER_ISSET_ID);
    }

    public void setScannerIsSet(boolean value) {
      __isset_bit_vector.set(__SCANNER_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SCANNER:
        if (value == null) {
          unsetScanner();
        } else {
          setScanner((Long)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SCANNER:
        return new Long(getScanner());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SCANNER:
        return isSetScanner();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof next_row_args)
        return this.equals((next_row_args)that);
      return false;
    }

    public boolean equals(next_row_args that) {
      if (that == null)
        return false;

      boolean this_present_scanner = true;
      boolean that_present_scanner = true;
      if (this_present_scanner || that_present_scanner) {
        if (!(this_present_scanner && that_present_scanner))
          return false;
        if (this.scanner != that.scanner)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(next_row_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      next_row_args typedOther = (next_row_args)other;

      lastComparison = Boolean.valueOf(isSetScanner()).compareTo(typedOther.isSetScanner());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetScanner()) {
        lastComparison = TBaseHelper.compareTo(this.scanner, typedOther.scanner);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // SCANNER
            if (field.type == TType.I64) {
              this.scanner = iprot.readI64();
              setScannerIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(SCANNER_FIELD_DESC);
      oprot.writeI64(this.scanner);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("next_row_args(");
      boolean first = true;

      sb.append("scanner:");
      sb.append(this.scanner);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class next_row_result implements TBase<next_row_result, next_row_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("next_row_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public List<Cell> success;
    public ClientException e;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      E((short)1, "e");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // E
            return E;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new StructMetaData(TType.STRUCT, Cell.class))));
      tmpMap.put(_Fields.E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(next_row_result.class, metaDataMap);
    }

    public next_row_result() {
    }

    public next_row_result(
      List<Cell> success,
      ClientException e)
    {
      this();
      this.success = success;
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public next_row_result(next_row_result other) {
      if (other.isSetSuccess()) {
        List<Cell> __this__success = new ArrayList<Cell>();
        for (Cell other_element : other.success) {
          __this__success.add(new Cell(other_element));
        }
        this.success = __this__success;
      }
      if (other.isSetE()) {
        this.e = new ClientException(other.e);
      }
    }

    public next_row_result deepCopy() {
      return new next_row_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.e = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<Cell> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(Cell elem) {
      if (this.success == null) {
        this.success = new ArrayList<Cell>();
      }
      this.success.add(elem);
    }

    public List<Cell> getSuccess() {
      return this.success;
    }

    public next_row_result setSuccess(List<Cell> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public ClientException getE() {
      return this.e;
    }

    public next_row_result setE(ClientException e) {
      this.e = e;
      return this;
    }

    public void unsetE() {
      this.e = null;
    }

    /** Returns true if field e is set (has been asigned a value) and false otherwise */
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<Cell>)value);
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((ClientException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case E:
        return getE();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof next_row_result)
        return this.equals((next_row_result)that);
      return false;
    }

    public boolean equals(next_row_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(next_row_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      next_row_result typedOther = (next_row_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetE()).compareTo(typedOther.isSetE());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetE()) {
        lastComparison = TBaseHelper.compareTo(this.e, typedOther.e);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.LIST) {
              {
                TList _list50 = iprot.readListBegin();
                this.success = new ArrayList<Cell>(_list50.size);
                for (int _i51 = 0; _i51 < _list50.size; ++_i51)
                {
                  Cell _elem52;
                  _elem52 = new Cell();
                  _elem52.read(iprot);
                  this.success.add(_elem52);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // E
            if (field.type == TType.STRUCT) {
              this.e = new ClientException();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
          for (Cell _iter53 : this.success)
          {
            _iter53.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetE()) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("next_row_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class next_row_as_arrays_args implements TBase<next_row_as_arrays_args, next_row_as_arrays_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("next_row_as_arrays_args");

    private static final TField SCANNER_FIELD_DESC = new TField("scanner", TType.I64, (short)1);

    public long scanner;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SCANNER((short)1, "scanner");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // SCANNER
            return SCANNER;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __SCANNER_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SCANNER, new FieldMetaData("scanner", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64          , "Scanner")));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(next_row_as_arrays_args.class, metaDataMap);
    }

    public next_row_as_arrays_args() {
    }

    public next_row_as_arrays_args(
      long scanner)
    {
      this();
      this.scanner = scanner;
      setScannerIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public next_row_as_arrays_args(next_row_as_arrays_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.scanner = other.scanner;
    }

    public next_row_as_arrays_args deepCopy() {
      return new next_row_as_arrays_args(this);
    }

    @Override
    public void clear() {
      setScannerIsSet(false);
      this.scanner = 0;
    }

    public long getScanner() {
      return this.scanner;
    }

    public next_row_as_arrays_args setScanner(long scanner) {
      this.scanner = scanner;
      setScannerIsSet(true);
      return this;
    }

    public void unsetScanner() {
      __isset_bit_vector.clear(__SCANNER_ISSET_ID);
    }

    /** Returns true if field scanner is set (has been asigned a value) and false otherwise */
    public boolean isSetScanner() {
      return __isset_bit_vector.get(__SCANNER_ISSET_ID);
    }

    public void setScannerIsSet(boolean value) {
      __isset_bit_vector.set(__SCANNER_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SCANNER:
        if (value == null) {
          unsetScanner();
        } else {
          setScanner((Long)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SCANNER:
        return new Long(getScanner());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SCANNER:
        return isSetScanner();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof next_row_as_arrays_args)
        return this.equals((next_row_as_arrays_args)that);
      return false;
    }

    public boolean equals(next_row_as_arrays_args that) {
      if (that == null)
        return false;

      boolean this_present_scanner = true;
      boolean that_present_scanner = true;
      if (this_present_scanner || that_present_scanner) {
        if (!(this_present_scanner && that_present_scanner))
          return false;
        if (this.scanner != that.scanner)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(next_row_as_arrays_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      next_row_as_arrays_args typedOther = (next_row_as_arrays_args)other;

      lastComparison = Boolean.valueOf(isSetScanner()).compareTo(typedOther.isSetScanner());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetScanner()) {
        lastComparison = TBaseHelper.compareTo(this.scanner, typedOther.scanner);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // SCANNER
            if (field.type == TType.I64) {
              this.scanner = iprot.readI64();
              setScannerIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(SCANNER_FIELD_DESC);
      oprot.writeI64(this.scanner);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("next_row_as_arrays_args(");
      boolean first = true;

      sb.append("scanner:");
      sb.append(this.scanner);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class next_row_as_arrays_result implements TBase<next_row_as_arrays_result, next_row_as_arrays_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("next_row_as_arrays_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public List<List<String>> success;
    public ClientException e;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      E((short)1, "e");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // E
            return E;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.LIST              , "CellAsArray"))));
      tmpMap.put(_Fields.E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(next_row_as_arrays_result.class, metaDataMap);
    }

    public next_row_as_arrays_result() {
    }

    public next_row_as_arrays_result(
      List<List<String>> success,
      ClientException e)
    {
      this();
      this.success = success;
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public next_row_as_arrays_result(next_row_as_arrays_result other) {
      if (other.isSetSuccess()) {
        List<List<String>> __this__success = new ArrayList<List<String>>();
        for (List<String> other_element : other.success) {
          __this__success.add(other_element);
        }
        this.success = __this__success;
      }
      if (other.isSetE()) {
        this.e = new ClientException(other.e);
      }
    }

    public next_row_as_arrays_result deepCopy() {
      return new next_row_as_arrays_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.e = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<List<String>> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(List<String> elem) {
      if (this.success == null) {
        this.success = new ArrayList<List<String>>();
      }
      this.success.add(elem);
    }

    public List<List<String>> getSuccess() {
      return this.success;
    }

    public next_row_as_arrays_result setSuccess(List<List<String>> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public ClientException getE() {
      return this.e;
    }

    public next_row_as_arrays_result setE(ClientException e) {
      this.e = e;
      return this;
    }

    public void unsetE() {
      this.e = null;
    }

    /** Returns true if field e is set (has been asigned a value) and false otherwise */
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<List<String>>)value);
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((ClientException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case E:
        return getE();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof next_row_as_arrays_result)
        return this.equals((next_row_as_arrays_result)that);
      return false;
    }

    public boolean equals(next_row_as_arrays_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(next_row_as_arrays_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      next_row_as_arrays_result typedOther = (next_row_as_arrays_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetE()).compareTo(typedOther.isSetE());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetE()) {
        lastComparison = TBaseHelper.compareTo(this.e, typedOther.e);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.LIST) {
              {
                TList _list54 = iprot.readListBegin();
                this.success = new ArrayList<List<String>>(_list54.size);
                for (int _i55 = 0; _i55 < _list54.size; ++_i55)
                {
                  List<String> _elem56;
                  {
                    TList _list57 = iprot.readListBegin();
                    _elem56 = new ArrayList<String>(_list57.size);
                    for (int _i58 = 0; _i58 < _list57.size; ++_i58)
                    {
                      String _elem59;
                      _elem59 = iprot.readString();
                      _elem56.add(_elem59);
                    }
                    iprot.readListEnd();
                  }
                  this.success.add(_elem56);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // E
            if (field.type == TType.STRUCT) {
              this.e = new ClientException();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.LIST, this.success.size()));
          for (List<String> _iter60 : this.success)
          {
            {
              oprot.writeListBegin(new TList(TType.STRING, _iter60.size()));
              for (String _iter61 : _iter60)
              {
                oprot.writeString(_iter61);
              }
              oprot.writeListEnd();
            }
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetE()) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("next_row_as_arrays_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class next_row_serialized_args implements TBase<next_row_serialized_args, next_row_serialized_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("next_row_serialized_args");

    private static final TField SCANNER_FIELD_DESC = new TField("scanner", TType.I64, (short)1);

    public long scanner;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SCANNER((short)1, "scanner");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // SCANNER
            return SCANNER;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __SCANNER_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SCANNER, new FieldMetaData("scanner", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64          , "Scanner")));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(next_row_serialized_args.class, metaDataMap);
    }

    public next_row_serialized_args() {
    }

    public next_row_serialized_args(
      long scanner)
    {
      this();
      this.scanner = scanner;
      setScannerIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public next_row_serialized_args(next_row_serialized_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.scanner = other.scanner;
    }

    public next_row_serialized_args deepCopy() {
      return new next_row_serialized_args(this);
    }

    @Override
    public void clear() {
      setScannerIsSet(false);
      this.scanner = 0;
    }

    public long getScanner() {
      return this.scanner;
    }

    public next_row_serialized_args setScanner(long scanner) {
      this.scanner = scanner;
      setScannerIsSet(true);
      return this;
    }

    public void unsetScanner() {
      __isset_bit_vector.clear(__SCANNER_ISSET_ID);
    }

    /** Returns true if field scanner is set (has been asigned a value) and false otherwise */
    public boolean isSetScanner() {
      return __isset_bit_vector.get(__SCANNER_ISSET_ID);
    }

    public void setScannerIsSet(boolean value) {
      __isset_bit_vector.set(__SCANNER_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SCANNER:
        if (value == null) {
          unsetScanner();
        } else {
          setScanner((Long)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SCANNER:
        return new Long(getScanner());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SCANNER:
        return isSetScanner();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof next_row_serialized_args)
        return this.equals((next_row_serialized_args)that);
      return false;
    }

    public boolean equals(next_row_serialized_args that) {
      if (that == null)
        return false;

      boolean this_present_scanner = true;
      boolean that_present_scanner = true;
      if (this_present_scanner || that_present_scanner) {
        if (!(this_present_scanner && that_present_scanner))
          return false;
        if (this.scanner != that.scanner)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(next_row_serialized_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      next_row_serialized_args typedOther = (next_row_serialized_args)other;

      lastComparison = Boolean.valueOf(isSetScanner()).compareTo(typedOther.isSetScanner());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetScanner()) {
        lastComparison = TBaseHelper.compareTo(this.scanner, typedOther.scanner);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // SCANNER
            if (field.type == TType.I64) {
              this.scanner = iprot.readI64();
              setScannerIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(SCANNER_FIELD_DESC);
      oprot.writeI64(this.scanner);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("next_row_serialized_args(");
      boolean first = true;

      sb.append("scanner:");
      sb.append(this.scanner);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class next_row_serialized_result implements TBase<next_row_serialized_result, next_row_serialized_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("next_row_serialized_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRING, (short)0);
    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public ByteBuffer success;
    public ClientException e;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      E((short)1, "e");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // E
            return E;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING          , "CellsSerialized")));
      tmpMap.put(_Fields.E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(next_row_serialized_result.class, metaDataMap);
    }

    public next_row_serialized_result() {
    }

    public next_row_serialized_result(
      ByteBuffer success,
      ClientException e)
    {
      this();
      this.success = success;
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public next_row_serialized_result(next_row_serialized_result other) {
      if (other.isSetSuccess()) {
        this.success = other.success;
      }
      if (other.isSetE()) {
        this.e = new ClientException(other.e);
      }
    }

    public next_row_serialized_result deepCopy() {
      return new next_row_serialized_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.e = null;
    }

    public byte[] getSuccess() {
      setSuccess(TBaseHelper.rightSize(success));
      return success.array();
    }

    public ByteBuffer BufferForSuccess() {
      return success;
    }

    public next_row_serialized_result setSuccess(byte[] success) {
      setSuccess(ByteBuffer.wrap(success));
      return this;
    }

    public next_row_serialized_result setSuccess(ByteBuffer success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public ClientException getE() {
      return this.e;
    }

    public next_row_serialized_result setE(ClientException e) {
      this.e = e;
      return this;
    }

    public void unsetE() {
      this.e = null;
    }

    /** Returns true if field e is set (has been asigned a value) and false otherwise */
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ByteBuffer)value);
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((ClientException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case E:
        return getE();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof next_row_serialized_result)
        return this.equals((next_row_serialized_result)that);
      return false;
    }

    public boolean equals(next_row_serialized_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(next_row_serialized_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      next_row_serialized_result typedOther = (next_row_serialized_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetE()).compareTo(typedOther.isSetE());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetE()) {
        lastComparison = TBaseHelper.compareTo(this.e, typedOther.e);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.STRING) {
              this.success = iprot.readBinary();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // E
            if (field.type == TType.STRUCT) {
              this.e = new ClientException();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeBinary(this.success);
        oprot.writeFieldEnd();
      } else if (this.isSetE()) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("next_row_serialized_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_row_args implements TBase<get_row_args, get_row_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_row_args");

    private static final TField NS_FIELD_DESC = new TField("ns", TType.I64, (short)1);
    private static final TField TABLE_NAME_FIELD_DESC = new TField("table_name", TType.STRING, (short)2);
    private static final TField ROW_FIELD_DESC = new TField("row", TType.STRING, (short)3);

    public long ns;
    public String table_name;
    public String row;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      NS((short)1, "ns"),
      TABLE_NAME((short)2, "table_name"),
      ROW((short)3, "row");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // NS
            return NS;
          case 2: // TABLE_NAME
            return TABLE_NAME;
          case 3: // ROW
            return ROW;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __NS_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.NS, new FieldMetaData("ns", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64          , "Namespace")));
      tmpMap.put(_Fields.TABLE_NAME, new FieldMetaData("table_name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.ROW, new FieldMetaData("row", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(get_row_args.class, metaDataMap);
    }

    public get_row_args() {
    }

    public get_row_args(
      long ns,
      String table_name,
      String row)
    {
      this();
      this.ns = ns;
      setNsIsSet(true);
      this.table_name = table_name;
      this.row = row;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_row_args(get_row_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.ns = other.ns;
      if (other.isSetTable_name()) {
        this.table_name = other.table_name;
      }
      if (other.isSetRow()) {
        this.row = other.row;
      }
    }

    public get_row_args deepCopy() {
      return new get_row_args(this);
    }

    @Override
    public void clear() {
      setNsIsSet(false);
      this.ns = 0;
      this.table_name = null;
      this.row = null;
    }

    public long getNs() {
      return this.ns;
    }

    public get_row_args setNs(long ns) {
      this.ns = ns;
      setNsIsSet(true);
      return this;
    }

    public void unsetNs() {
      __isset_bit_vector.clear(__NS_ISSET_ID);
    }

    /** Returns true if field ns is set (has been asigned a value) and false otherwise */
    public boolean isSetNs() {
      return __isset_bit_vector.get(__NS_ISSET_ID);
    }

    public void setNsIsSet(boolean value) {
      __isset_bit_vector.set(__NS_ISSET_ID, value);
    }

    public String getTable_name() {
      return this.table_name;
    }

    public get_row_args setTable_name(String table_name) {
      this.table_name = table_name;
      return this;
    }

    public void unsetTable_name() {
      this.table_name = null;
    }

    /** Returns true if field table_name is set (has been asigned a value) and false otherwise */
    public boolean isSetTable_name() {
      return this.table_name != null;
    }

    public void setTable_nameIsSet(boolean value) {
      if (!value) {
        this.table_name = null;
      }
    }

    public String getRow() {
      return this.row;
    }

    public get_row_args setRow(String row) {
      this.row = row;
      return this;
    }

    public void unsetRow() {
      this.row = null;
    }

    /** Returns true if field row is set (has been asigned a value) and false otherwise */
    public boolean isSetRow() {
      return this.row != null;
    }

    public void setRowIsSet(boolean value) {
      if (!value) {
        this.row = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case NS:
        if (value == null) {
          unsetNs();
        } else {
          setNs((Long)value);
        }
        break;

      case TABLE_NAME:
        if (value == null) {
          unsetTable_name();
        } else {
          setTable_name((String)value);
        }
        break;

      case ROW:
        if (value == null) {
          unsetRow();
        } else {
          setRow((String)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case NS:
        return new Long(getNs());

      case TABLE_NAME:
        return getTable_name();

      case ROW:
        return getRow();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case NS:
        return isSetNs();
      case TABLE_NAME:
        return isSetTable_name();
      case ROW:
        return isSetRow();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_row_args)
        return this.equals((get_row_args)that);
      return false;
    }

    public boolean equals(get_row_args that) {
      if (that == null)
        return false;

      boolean this_present_ns = true;
      boolean that_present_ns = true;
      if (this_present_ns || that_present_ns) {
        if (!(this_present_ns && that_present_ns))
          return false;
        if (this.ns != that.ns)
          return false;
      }

      boolean this_present_table_name = true && this.isSetTable_name();
      boolean that_present_table_name = true && that.isSetTable_name();
      if (this_present_table_name || that_present_table_name) {
        if (!(this_present_table_name && that_present_table_name))
          return false;
        if (!this.table_name.equals(that.table_name))
          return false;
      }

      boolean this_present_row = true && this.isSetRow();
      boolean that_present_row = true && that.isSetRow();
      if (this_present_row || that_present_row) {
        if (!(this_present_row && that_present_row))
          return false;
        if (!this.row.equals(that.row))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_row_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_row_args typedOther = (get_row_args)other;

      lastComparison = Boolean.valueOf(isSetNs()).compareTo(typedOther.isSetNs());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetNs()) {
        lastComparison = TBaseHelper.compareTo(this.ns, typedOther.ns);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetTable_name()).compareTo(typedOther.isSetTable_name());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTable_name()) {
        lastComparison = TBaseHelper.compareTo(this.table_name, typedOther.table_name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetRow()).compareTo(typedOther.isSetRow());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetRow()) {
        lastComparison = TBaseHelper.compareTo(this.row, typedOther.row);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // NS
            if (field.type == TType.I64) {
              this.ns = iprot.readI64();
              setNsIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // TABLE_NAME
            if (field.type == TType.STRING) {
              this.table_name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // ROW
            if (field.type == TType.STRING) {
              this.row = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(NS_FIELD_DESC);
      oprot.writeI64(this.ns);
      oprot.writeFieldEnd();
      if (this.table_name != null) {
        oprot.writeFieldBegin(TABLE_NAME_FIELD_DESC);
        oprot.writeString(this.table_name);
        oprot.writeFieldEnd();
      }
      if (this.row != null) {
        oprot.writeFieldBegin(ROW_FIELD_DESC);
        oprot.writeString(this.row);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_row_args(");
      boolean first = true;

      sb.append("ns:");
      sb.append(this.ns);
      first = false;
      if (!first) sb.append(", ");
      sb.append("table_name:");
      if (this.table_name == null) {
        sb.append("null");
      } else {
        sb.append(this.table_name);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("row:");
      if (this.row == null) {
        sb.append("null");
      } else {
        sb.append(this.row);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_row_result implements TBase<get_row_result, get_row_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_row_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public List<Cell> success;
    public ClientException e;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      E((short)1, "e");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // E
            return E;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new StructMetaData(TType.STRUCT, Cell.class))));
      tmpMap.put(_Fields.E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(get_row_result.class, metaDataMap);
    }

    public get_row_result() {
    }

    public get_row_result(
      List<Cell> success,
      ClientException e)
    {
      this();
      this.success = success;
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_row_result(get_row_result other) {
      if (other.isSetSuccess()) {
        List<Cell> __this__success = new ArrayList<Cell>();
        for (Cell other_element : other.success) {
          __this__success.add(new Cell(other_element));
        }
        this.success = __this__success;
      }
      if (other.isSetE()) {
        this.e = new ClientException(other.e);
      }
    }

    public get_row_result deepCopy() {
      return new get_row_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.e = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<Cell> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(Cell elem) {
      if (this.success == null) {
        this.success = new ArrayList<Cell>();
      }
      this.success.add(elem);
    }

    public List<Cell> getSuccess() {
      return this.success;
    }

    public get_row_result setSuccess(List<Cell> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public ClientException getE() {
      return this.e;
    }

    public get_row_result setE(ClientException e) {
      this.e = e;
      return this;
    }

    public void unsetE() {
      this.e = null;
    }

    /** Returns true if field e is set (has been asigned a value) and false otherwise */
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<Cell>)value);
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((ClientException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case E:
        return getE();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_row_result)
        return this.equals((get_row_result)that);
      return false;
    }

    public boolean equals(get_row_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_row_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_row_result typedOther = (get_row_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetE()).compareTo(typedOther.isSetE());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetE()) {
        lastComparison = TBaseHelper.compareTo(this.e, typedOther.e);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.LIST) {
              {
                TList _list62 = iprot.readListBegin();
                this.success = new ArrayList<Cell>(_list62.size);
                for (int _i63 = 0; _i63 < _list62.size; ++_i63)
                {
                  Cell _elem64;
                  _elem64 = new Cell();
                  _elem64.read(iprot);
                  this.success.add(_elem64);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // E
            if (field.type == TType.STRUCT) {
              this.e = new ClientException();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
          for (Cell _iter65 : this.success)
          {
            _iter65.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetE()) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_row_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_row_as_arrays_args implements TBase<get_row_as_arrays_args, get_row_as_arrays_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_row_as_arrays_args");

    private static final TField NS_FIELD_DESC = new TField("ns", TType.I64, (short)1);
    private static final TField NAME_FIELD_DESC = new TField("name", TType.STRING, (short)2);
    private static final TField ROW_FIELD_DESC = new TField("row", TType.STRING, (short)3);

    public long ns;
    public String name;
    public String row;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      NS((short)1, "ns"),
      NAME((short)2, "name"),
      ROW((short)3, "row");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // NS
            return NS;
          case 2: // NAME
            return NAME;
          case 3: // ROW
            return ROW;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __NS_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.NS, new FieldMetaData("ns", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64          , "Namespace")));
      tmpMap.put(_Fields.NAME, new FieldMetaData("name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.ROW, new FieldMetaData("row", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(get_row_as_arrays_args.class, metaDataMap);
    }

    public get_row_as_arrays_args() {
    }

    public get_row_as_arrays_args(
      long ns,
      String name,
      String row)
    {
      this();
      this.ns = ns;
      setNsIsSet(true);
      this.name = name;
      this.row = row;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_row_as_arrays_args(get_row_as_arrays_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.ns = other.ns;
      if (other.isSetName()) {
        this.name = other.name;
      }
      if (other.isSetRow()) {
        this.row = other.row;
      }
    }

    public get_row_as_arrays_args deepCopy() {
      return new get_row_as_arrays_args(this);
    }

    @Override
    public void clear() {
      setNsIsSet(false);
      this.ns = 0;
      this.name = null;
      this.row = null;
    }

    public long getNs() {
      return this.ns;
    }

    public get_row_as_arrays_args setNs(long ns) {
      this.ns = ns;
      setNsIsSet(true);
      return this;
    }

    public void unsetNs() {
      __isset_bit_vector.clear(__NS_ISSET_ID);
    }

    /** Returns true if field ns is set (has been asigned a value) and false otherwise */
    public boolean isSetNs() {
      return __isset_bit_vector.get(__NS_ISSET_ID);
    }

    public void setNsIsSet(boolean value) {
      __isset_bit_vector.set(__NS_ISSET_ID, value);
    }

    public String getName() {
      return this.name;
    }

    public get_row_as_arrays_args setName(String name) {
      this.name = name;
      return this;
    }

    public void unsetName() {
      this.name = null;
    }

    /** Returns true if field name is set (has been asigned a value) and false otherwise */
    public boolean isSetName() {
      return this.name != null;
    }

    public void setNameIsSet(boolean value) {
      if (!value) {
        this.name = null;
      }
    }

    public String getRow() {
      return this.row;
    }

    public get_row_as_arrays_args setRow(String row) {
      this.row = row;
      return this;
    }

    public void unsetRow() {
      this.row = null;
    }

    /** Returns true if field row is set (has been asigned a value) and false otherwise */
    public boolean isSetRow() {
      return this.row != null;
    }

    public void setRowIsSet(boolean value) {
      if (!value) {
        this.row = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case NS:
        if (value == null) {
          unsetNs();
        } else {
          setNs((Long)value);
        }
        break;

      case NAME:
        if (value == null) {
          unsetName();
        } else {
          setName((String)value);
        }
        break;

      case ROW:
        if (value == null) {
          unsetRow();
        } else {
          setRow((String)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case NS:
        return new Long(getNs());

      case NAME:
        return getName();

      case ROW:
        return getRow();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case NS:
        return isSetNs();
      case NAME:
        return isSetName();
      case ROW:
        return isSetRow();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_row_as_arrays_args)
        return this.equals((get_row_as_arrays_args)that);
      return false;
    }

    public boolean equals(get_row_as_arrays_args that) {
      if (that == null)
        return false;

      boolean this_present_ns = true;
      boolean that_present_ns = true;
      if (this_present_ns || that_present_ns) {
        if (!(this_present_ns && that_present_ns))
          return false;
        if (this.ns != that.ns)
          return false;
      }

      boolean this_present_name = true && this.isSetName();
      boolean that_present_name = true && that.isSetName();
      if (this_present_name || that_present_name) {
        if (!(this_present_name && that_present_name))
          return false;
        if (!this.name.equals(that.name))
          return false;
      }

      boolean this_present_row = true && this.isSetRow();
      boolean that_present_row = true && that.isSetRow();
      if (this_present_row || that_present_row) {
        if (!(this_present_row && that_present_row))
          return false;
        if (!this.row.equals(that.row))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_row_as_arrays_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_row_as_arrays_args typedOther = (get_row_as_arrays_args)other;

      lastComparison = Boolean.valueOf(isSetNs()).compareTo(typedOther.isSetNs());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetNs()) {
        lastComparison = TBaseHelper.compareTo(this.ns, typedOther.ns);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetName()).compareTo(typedOther.isSetName());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetName()) {
        lastComparison = TBaseHelper.compareTo(this.name, typedOther.name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetRow()).compareTo(typedOther.isSetRow());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetRow()) {
        lastComparison = TBaseHelper.compareTo(this.row, typedOther.row);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // NS
            if (field.type == TType.I64) {
              this.ns = iprot.readI64();
              setNsIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // NAME
            if (field.type == TType.STRING) {
              this.name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // ROW
            if (field.type == TType.STRING) {
              this.row = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(NS_FIELD_DESC);
      oprot.writeI64(this.ns);
      oprot.writeFieldEnd();
      if (this.name != null) {
        oprot.writeFieldBegin(NAME_FIELD_DESC);
        oprot.writeString(this.name);
        oprot.writeFieldEnd();
      }
      if (this.row != null) {
        oprot.writeFieldBegin(ROW_FIELD_DESC);
        oprot.writeString(this.row);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_row_as_arrays_args(");
      boolean first = true;

      sb.append("ns:");
      sb.append(this.ns);
      first = false;
      if (!first) sb.append(", ");
      sb.append("name:");
      if (this.name == null) {
        sb.append("null");
      } else {
        sb.append(this.name);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("row:");
      if (this.row == null) {
        sb.append("null");
      } else {
        sb.append(this.row);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_row_as_arrays_result implements TBase<get_row_as_arrays_result, get_row_as_arrays_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_row_as_arrays_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public List<List<String>> success;
    public ClientException e;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      E((short)1, "e");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // E
            return E;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.LIST              , "CellAsArray"))));
      tmpMap.put(_Fields.E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(get_row_as_arrays_result.class, metaDataMap);
    }

    public get_row_as_arrays_result() {
    }

    public get_row_as_arrays_result(
      List<List<String>> success,
      ClientException e)
    {
      this();
      this.success = success;
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_row_as_arrays_result(get_row_as_arrays_result other) {
      if (other.isSetSuccess()) {
        List<List<String>> __this__success = new ArrayList<List<String>>();
        for (List<String> other_element : other.success) {
          __this__success.add(other_element);
        }
        this.success = __this__success;
      }
      if (other.isSetE()) {
        this.e = new ClientException(other.e);
      }
    }

    public get_row_as_arrays_result deepCopy() {
      return new get_row_as_arrays_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.e = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<List<String>> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(List<String> elem) {
      if (this.success == null) {
        this.success = new ArrayList<List<String>>();
      }
      this.success.add(elem);
    }

    public List<List<String>> getSuccess() {
      return this.success;
    }

    public get_row_as_arrays_result setSuccess(List<List<String>> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public ClientException getE() {
      return this.e;
    }

    public get_row_as_arrays_result setE(ClientException e) {
      this.e = e;
      return this;
    }

    public void unsetE() {
      this.e = null;
    }

    /** Returns true if field e is set (has been asigned a value) and false otherwise */
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<List<String>>)value);
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((ClientException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case E:
        return getE();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_row_as_arrays_result)
        return this.equals((get_row_as_arrays_result)that);
      return false;
    }

    public boolean equals(get_row_as_arrays_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_row_as_arrays_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_row_as_arrays_result typedOther = (get_row_as_arrays_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetE()).compareTo(typedOther.isSetE());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetE()) {
        lastComparison = TBaseHelper.compareTo(this.e, typedOther.e);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.LIST) {
              {
                TList _list66 = iprot.readListBegin();
                this.success = new ArrayList<List<String>>(_list66.size);
                for (int _i67 = 0; _i67 < _list66.size; ++_i67)
                {
                  List<String> _elem68;
                  {
                    TList _list69 = iprot.readListBegin();
                    _elem68 = new ArrayList<String>(_list69.size);
                    for (int _i70 = 0; _i70 < _list69.size; ++_i70)
                    {
                      String _elem71;
                      _elem71 = iprot.readString();
                      _elem68.add(_elem71);
                    }
                    iprot.readListEnd();
                  }
                  this.success.add(_elem68);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // E
            if (field.type == TType.STRUCT) {
              this.e = new ClientException();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.LIST, this.success.size()));
          for (List<String> _iter72 : this.success)
          {
            {
              oprot.writeListBegin(new TList(TType.STRING, _iter72.size()));
              for (String _iter73 : _iter72)
              {
                oprot.writeString(_iter73);
              }
              oprot.writeListEnd();
            }
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetE()) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_row_as_arrays_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_row_serialized_args implements TBase<get_row_serialized_args, get_row_serialized_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_row_serialized_args");

    private static final TField NS_FIELD_DESC = new TField("ns", TType.I64, (short)1);
    private static final TField TABLE_NAME_FIELD_DESC = new TField("table_name", TType.STRING, (short)2);
    private static final TField ROW_FIELD_DESC = new TField("row", TType.STRING, (short)3);

    public long ns;
    public String table_name;
    public String row;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      NS((short)1, "ns"),
      TABLE_NAME((short)2, "table_name"),
      ROW((short)3, "row");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // NS
            return NS;
          case 2: // TABLE_NAME
            return TABLE_NAME;
          case 3: // ROW
            return ROW;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __NS_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.NS, new FieldMetaData("ns", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64          , "Namespace")));
      tmpMap.put(_Fields.TABLE_NAME, new FieldMetaData("table_name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.ROW, new FieldMetaData("row", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(get_row_serialized_args.class, metaDataMap);
    }

    public get_row_serialized_args() {
    }

    public get_row_serialized_args(
      long ns,
      String table_name,
      String row)
    {
      this();
      this.ns = ns;
      setNsIsSet(true);
      this.table_name = table_name;
      this.row = row;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_row_serialized_args(get_row_serialized_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.ns = other.ns;
      if (other.isSetTable_name()) {
        this.table_name = other.table_name;
      }
      if (other.isSetRow()) {
        this.row = other.row;
      }
    }

    public get_row_serialized_args deepCopy() {
      return new get_row_serialized_args(this);
    }

    @Override
    public void clear() {
      setNsIsSet(false);
      this.ns = 0;
      this.table_name = null;
      this.row = null;
    }

    public long getNs() {
      return this.ns;
    }

    public get_row_serialized_args setNs(long ns) {
      this.ns = ns;
      setNsIsSet(true);
      return this;
    }

    public void unsetNs() {
      __isset_bit_vector.clear(__NS_ISSET_ID);
    }

    /** Returns true if field ns is set (has been asigned a value) and false otherwise */
    public boolean isSetNs() {
      return __isset_bit_vector.get(__NS_ISSET_ID);
    }

    public void setNsIsSet(boolean value) {
      __isset_bit_vector.set(__NS_ISSET_ID, value);
    }

    public String getTable_name() {
      return this.table_name;
    }

    public get_row_serialized_args setTable_name(String table_name) {
      this.table_name = table_name;
      return this;
    }

    public void unsetTable_name() {
      this.table_name = null;
    }

    /** Returns true if field table_name is set (has been asigned a value) and false otherwise */
    public boolean isSetTable_name() {
      return this.table_name != null;
    }

    public void setTable_nameIsSet(boolean value) {
      if (!value) {
        this.table_name = null;
      }
    }

    public String getRow() {
      return this.row;
    }

    public get_row_serialized_args setRow(String row) {
      this.row = row;
      return this;
    }

    public void unsetRow() {
      this.row = null;
    }

    /** Returns true if field row is set (has been asigned a value) and false otherwise */
    public boolean isSetRow() {
      return this.row != null;
    }

    public void setRowIsSet(boolean value) {
      if (!value) {
        this.row = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case NS:
        if (value == null) {
          unsetNs();
        } else {
          setNs((Long)value);
        }
        break;

      case TABLE_NAME:
        if (value == null) {
          unsetTable_name();
        } else {
          setTable_name((String)value);
        }
        break;

      case ROW:
        if (value == null) {
          unsetRow();
        } else {
          setRow((String)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case NS:
        return new Long(getNs());

      case TABLE_NAME:
        return getTable_name();

      case ROW:
        return getRow();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case NS:
        return isSetNs();
      case TABLE_NAME:
        return isSetTable_name();
      case ROW:
        return isSetRow();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_row_serialized_args)
        return this.equals((get_row_serialized_args)that);
      return false;
    }

    public boolean equals(get_row_serialized_args that) {
      if (that == null)
        return false;

      boolean this_present_ns = true;
      boolean that_present_ns = true;
      if (this_present_ns || that_present_ns) {
        if (!(this_present_ns && that_present_ns))
          return false;
        if (this.ns != that.ns)
          return false;
      }

      boolean this_present_table_name = true && this.isSetTable_name();
      boolean that_present_table_name = true && that.isSetTable_name();
      if (this_present_table_name || that_present_table_name) {
        if (!(this_present_table_name && that_present_table_name))
          return false;
        if (!this.table_name.equals(that.table_name))
          return false;
      }

      boolean this_present_row = true && this.isSetRow();
      boolean that_present_row = true && that.isSetRow();
      if (this_present_row || that_present_row) {
        if (!(this_present_row && that_present_row))
          return false;
        if (!this.row.equals(that.row))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_row_serialized_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_row_serialized_args typedOther = (get_row_serialized_args)other;

      lastComparison = Boolean.valueOf(isSetNs()).compareTo(typedOther.isSetNs());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetNs()) {
        lastComparison = TBaseHelper.compareTo(this.ns, typedOther.ns);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetTable_name()).compareTo(typedOther.isSetTable_name());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTable_name()) {
        lastComparison = TBaseHelper.compareTo(this.table_name, typedOther.table_name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetRow()).compareTo(typedOther.isSetRow());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetRow()) {
        lastComparison = TBaseHelper.compareTo(this.row, typedOther.row);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // NS
            if (field.type == TType.I64) {
              this.ns = iprot.readI64();
              setNsIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // TABLE_NAME
            if (field.type == TType.STRING) {
              this.table_name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // ROW
            if (field.type == TType.STRING) {
              this.row = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(NS_FIELD_DESC);
      oprot.writeI64(this.ns);
      oprot.writeFieldEnd();
      if (this.table_name != null) {
        oprot.writeFieldBegin(TABLE_NAME_FIELD_DESC);
        oprot.writeString(this.table_name);
        oprot.writeFieldEnd();
      }
      if (this.row != null) {
        oprot.writeFieldBegin(ROW_FIELD_DESC);
        oprot.writeString(this.row);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_row_serialized_args(");
      boolean first = true;

      sb.append("ns:");
      sb.append(this.ns);
      first = false;
      if (!first) sb.append(", ");
      sb.append("table_name:");
      if (this.table_name == null) {
        sb.append("null");
      } else {
        sb.append(this.table_name);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("row:");
      if (this.row == null) {
        sb.append("null");
      } else {
        sb.append(this.row);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_row_serialized_result implements TBase<get_row_serialized_result, get_row_serialized_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_row_serialized_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRING, (short)0);
    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public ByteBuffer success;
    public ClientException e;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      E((short)1, "e");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // E
            return E;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING          , "CellsSerialized")));
      tmpMap.put(_Fields.E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(get_row_serialized_result.class, metaDataMap);
    }

    public get_row_serialized_result() {
    }

    public get_row_serialized_result(
      ByteBuffer success,
      ClientException e)
    {
      this();
      this.success = success;
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_row_serialized_result(get_row_serialized_result other) {
      if (other.isSetSuccess()) {
        this.success = other.success;
      }
      if (other.isSetE()) {
        this.e = new ClientException(other.e);
      }
    }

    public get_row_serialized_result deepCopy() {
      return new get_row_serialized_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.e = null;
    }

    public byte[] getSuccess() {
      setSuccess(TBaseHelper.rightSize(success));
      return success.array();
    }

    public ByteBuffer BufferForSuccess() {
      return success;
    }

    public get_row_serialized_result setSuccess(byte[] success) {
      setSuccess(ByteBuffer.wrap(success));
      return this;
    }

    public get_row_serialized_result setSuccess(ByteBuffer success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public ClientException getE() {
      return this.e;
    }

    public get_row_serialized_result setE(ClientException e) {
      this.e = e;
      return this;
    }

    public void unsetE() {
      this.e = null;
    }

    /** Returns true if field e is set (has been asigned a value) and false otherwise */
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ByteBuffer)value);
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((ClientException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case E:
        return getE();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_row_serialized_result)
        return this.equals((get_row_serialized_result)that);
      return false;
    }

    public boolean equals(get_row_serialized_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_row_serialized_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_row_serialized_result typedOther = (get_row_serialized_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetE()).compareTo(typedOther.isSetE());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetE()) {
        lastComparison = TBaseHelper.compareTo(this.e, typedOther.e);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.STRING) {
              this.success = iprot.readBinary();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // E
            if (field.type == TType.STRUCT) {
              this.e = new ClientException();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeBinary(this.success);
        oprot.writeFieldEnd();
      } else if (this.isSetE()) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_row_serialized_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_cell_args implements TBase<get_cell_args, get_cell_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_cell_args");

    private static final TField NS_FIELD_DESC = new TField("ns", TType.I64, (short)1);
    private static final TField TABLE_NAME_FIELD_DESC = new TField("table_name", TType.STRING, (short)2);
    private static final TField ROW_FIELD_DESC = new TField("row", TType.STRING, (short)3);
    private static final TField COLUMN_FIELD_DESC = new TField("column", TType.STRING, (short)4);

    public long ns;
    public String table_name;
    public String row;
    public String column;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      NS((short)1, "ns"),
      TABLE_NAME((short)2, "table_name"),
      ROW((short)3, "row"),
      COLUMN((short)4, "column");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // NS
            return NS;
          case 2: // TABLE_NAME
            return TABLE_NAME;
          case 3: // ROW
            return ROW;
          case 4: // COLUMN
            return COLUMN;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __NS_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.NS, new FieldMetaData("ns", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64          , "Namespace")));
      tmpMap.put(_Fields.TABLE_NAME, new FieldMetaData("table_name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.ROW, new FieldMetaData("row", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.COLUMN, new FieldMetaData("column", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(get_cell_args.class, metaDataMap);
    }

    public get_cell_args() {
    }

    public get_cell_args(
      long ns,
      String table_name,
      String row,
      String column)
    {
      this();
      this.ns = ns;
      setNsIsSet(true);
      this.table_name = table_name;
      this.row = row;
      this.column = column;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_cell_args(get_cell_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.ns = other.ns;
      if (other.isSetTable_name()) {
        this.table_name = other.table_name;
      }
      if (other.isSetRow()) {
        this.row = other.row;
      }
      if (other.isSetColumn()) {
        this.column = other.column;
      }
    }

    public get_cell_args deepCopy() {
      return new get_cell_args(this);
    }

    @Override
    public void clear() {
      setNsIsSet(false);
      this.ns = 0;
      this.table_name = null;
      this.row = null;
      this.column = null;
    }

    public long getNs() {
      return this.ns;
    }

    public get_cell_args setNs(long ns) {
      this.ns = ns;
      setNsIsSet(true);
      return this;
    }

    public void unsetNs() {
      __isset_bit_vector.clear(__NS_ISSET_ID);
    }

    /** Returns true if field ns is set (has been asigned a value) and false otherwise */
    public boolean isSetNs() {
      return __isset_bit_vector.get(__NS_ISSET_ID);
    }

    public void setNsIsSet(boolean value) {
      __isset_bit_vector.set(__NS_ISSET_ID, value);
    }

    public String getTable_name() {
      return this.table_name;
    }

    public get_cell_args setTable_name(String table_name) {
      this.table_name = table_name;
      return this;
    }

    public void unsetTable_name() {
      this.table_name = null;
    }

    /** Returns true if field table_name is set (has been asigned a value) and false otherwise */
    public boolean isSetTable_name() {
      return this.table_name != null;
    }

    public void setTable_nameIsSet(boolean value) {
      if (!value) {
        this.table_name = null;
      }
    }

    public String getRow() {
      return this.row;
    }

    public get_cell_args setRow(String row) {
      this.row = row;
      return this;
    }

    public void unsetRow() {
      this.row = null;
    }

    /** Returns true if field row is set (has been asigned a value) and false otherwise */
    public boolean isSetRow() {
      return this.row != null;
    }

    public void setRowIsSet(boolean value) {
      if (!value) {
        this.row = null;
      }
    }

    public String getColumn() {
      return this.column;
    }

    public get_cell_args setColumn(String column) {
      this.column = column;
      return this;
    }

    public void unsetColumn() {
      this.column = null;
    }

    /** Returns true if field column is set (has been asigned a value) and false otherwise */
    public boolean isSetColumn() {
      return this.column != null;
    }

    public void setColumnIsSet(boolean value) {
      if (!value) {
        this.column = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case NS:
        if (value == null) {
          unsetNs();
        } else {
          setNs((Long)value);
        }
        break;

      case TABLE_NAME:
        if (value == null) {
          unsetTable_name();
        } else {
          setTable_name((String)value);
        }
        break;

      case ROW:
        if (value == null) {
          unsetRow();
        } else {
          setRow((String)value);
        }
        break;

      case COLUMN:
        if (value == null) {
          unsetColumn();
        } else {
          setColumn((String)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case NS:
        return new Long(getNs());

      case TABLE_NAME:
        return getTable_name();

      case ROW:
        return getRow();

      case COLUMN:
        return getColumn();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case NS:
        return isSetNs();
      case TABLE_NAME:
        return isSetTable_name();
      case ROW:
        return isSetRow();
      case COLUMN:
        return isSetColumn();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_cell_args)
        return this.equals((get_cell_args)that);
      return false;
    }

    public boolean equals(get_cell_args that) {
      if (that == null)
        return false;

      boolean this_present_ns = true;
      boolean that_present_ns = true;
      if (this_present_ns || that_present_ns) {
        if (!(this_present_ns && that_present_ns))
          return false;
        if (this.ns != that.ns)
          return false;
      }

      boolean this_present_table_name = true && this.isSetTable_name();
      boolean that_present_table_name = true && that.isSetTable_name();
      if (this_present_table_name || that_present_table_name) {
        if (!(this_present_table_name && that_present_table_name))
          return false;
        if (!this.table_name.equals(that.table_name))
          return false;
      }

      boolean this_present_row = true && this.isSetRow();
      boolean that_present_row = true && that.isSetRow();
      if (this_present_row || that_present_row) {
        if (!(this_present_row && that_present_row))
          return false;
        if (!this.row.equals(that.row))
          return false;
      }

      boolean this_present_column = true && this.isSetColumn();
      boolean that_present_column = true && that.isSetColumn();
      if (this_present_column || that_present_column) {
        if (!(this_present_column && that_present_column))
          return false;
        if (!this.column.equals(that.column))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_cell_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_cell_args typedOther = (get_cell_args)other;

      lastComparison = Boolean.valueOf(isSetNs()).compareTo(typedOther.isSetNs());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetNs()) {
        lastComparison = TBaseHelper.compareTo(this.ns, typedOther.ns);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetTable_name()).compareTo(typedOther.isSetTable_name());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTable_name()) {
        lastComparison = TBaseHelper.compareTo(this.table_name, typedOther.table_name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetRow()).compareTo(typedOther.isSetRow());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetRow()) {
        lastComparison = TBaseHelper.compareTo(this.row, typedOther.row);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetColumn()).compareTo(typedOther.isSetColumn());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetColumn()) {
        lastComparison = TBaseHelper.compareTo(this.column, typedOther.column);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // NS
            if (field.type == TType.I64) {
              this.ns = iprot.readI64();
              setNsIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // TABLE_NAME
            if (field.type == TType.STRING) {
              this.table_name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // ROW
            if (field.type == TType.STRING) {
              this.row = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 4: // COLUMN
            if (field.type == TType.STRING) {
              this.column = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(NS_FIELD_DESC);
      oprot.writeI64(this.ns);
      oprot.writeFieldEnd();
      if (this.table_name != null) {
        oprot.writeFieldBegin(TABLE_NAME_FIELD_DESC);
        oprot.writeString(this.table_name);
        oprot.writeFieldEnd();
      }
      if (this.row != null) {
        oprot.writeFieldBegin(ROW_FIELD_DESC);
        oprot.writeString(this.row);
        oprot.writeFieldEnd();
      }
      if (this.column != null) {
        oprot.writeFieldBegin(COLUMN_FIELD_DESC);
        oprot.writeString(this.column);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_cell_args(");
      boolean first = true;

      sb.append("ns:");
      sb.append(this.ns);
      first = false;
      if (!first) sb.append(", ");
      sb.append("table_name:");
      if (this.table_name == null) {
        sb.append("null");
      } else {
        sb.append(this.table_name);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("row:");
      if (this.row == null) {
        sb.append("null");
      } else {
        sb.append(this.row);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("column:");
      if (this.column == null) {
        sb.append("null");
      } else {
        sb.append(this.column);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_cell_result implements TBase<get_cell_result, get_cell_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_cell_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRING, (short)0);
    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public ByteBuffer success;
    public ClientException e;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      E((short)1, "e");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // E
            return E;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING          , "Value")));
      tmpMap.put(_Fields.E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(get_cell_result.class, metaDataMap);
    }

    public get_cell_result() {
    }

    public get_cell_result(
      ByteBuffer success,
      ClientException e)
    {
      this();
      this.success = success;
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_cell_result(get_cell_result other) {
      if (other.isSetSuccess()) {
        this.success = other.success;
      }
      if (other.isSetE()) {
        this.e = new ClientException(other.e);
      }
    }

    public get_cell_result deepCopy() {
      return new get_cell_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.e = null;
    }

    public byte[] getSuccess() {
      setSuccess(TBaseHelper.rightSize(success));
      return success.array();
    }

    public ByteBuffer BufferForSuccess() {
      return success;
    }

    public get_cell_result setSuccess(byte[] success) {
      setSuccess(ByteBuffer.wrap(success));
      return this;
    }

    public get_cell_result setSuccess(ByteBuffer success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public ClientException getE() {
      return this.e;
    }

    public get_cell_result setE(ClientException e) {
      this.e = e;
      return this;
    }

    public void unsetE() {
      this.e = null;
    }

    /** Returns true if field e is set (has been asigned a value) and false otherwise */
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ByteBuffer)value);
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((ClientException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case E:
        return getE();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_cell_result)
        return this.equals((get_cell_result)that);
      return false;
    }

    public boolean equals(get_cell_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_cell_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_cell_result typedOther = (get_cell_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetE()).compareTo(typedOther.isSetE());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetE()) {
        lastComparison = TBaseHelper.compareTo(this.e, typedOther.e);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.STRING) {
              this.success = iprot.readBinary();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // E
            if (field.type == TType.STRUCT) {
              this.e = new ClientException();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeBinary(this.success);
        oprot.writeFieldEnd();
      } else if (this.isSetE()) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_cell_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_cells_args implements TBase<get_cells_args, get_cells_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_cells_args");

    private static final TField NS_FIELD_DESC = new TField("ns", TType.I64, (short)1);
    private static final TField TABLE_NAME_FIELD_DESC = new TField("table_name", TType.STRING, (short)2);
    private static final TField SCAN_SPEC_FIELD_DESC = new TField("scan_spec", TType.STRUCT, (short)3);

    public long ns;
    public String table_name;
    public ScanSpec scan_spec;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      NS((short)1, "ns"),
      TABLE_NAME((short)2, "table_name"),
      SCAN_SPEC((short)3, "scan_spec");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // NS
            return NS;
          case 2: // TABLE_NAME
            return TABLE_NAME;
          case 3: // SCAN_SPEC
            return SCAN_SPEC;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __NS_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.NS, new FieldMetaData("ns", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64          , "Namespace")));
      tmpMap.put(_Fields.TABLE_NAME, new FieldMetaData("table_name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.SCAN_SPEC, new FieldMetaData("scan_spec", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ScanSpec.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(get_cells_args.class, metaDataMap);
    }

    public get_cells_args() {
    }

    public get_cells_args(
      long ns,
      String table_name,
      ScanSpec scan_spec)
    {
      this();
      this.ns = ns;
      setNsIsSet(true);
      this.table_name = table_name;
      this.scan_spec = scan_spec;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_cells_args(get_cells_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.ns = other.ns;
      if (other.isSetTable_name()) {
        this.table_name = other.table_name;
      }
      if (other.isSetScan_spec()) {
        this.scan_spec = new ScanSpec(other.scan_spec);
      }
    }

    public get_cells_args deepCopy() {
      return new get_cells_args(this);
    }

    @Override
    public void clear() {
      setNsIsSet(false);
      this.ns = 0;
      this.table_name = null;
      this.scan_spec = null;
    }

    public long getNs() {
      return this.ns;
    }

    public get_cells_args setNs(long ns) {
      this.ns = ns;
      setNsIsSet(true);
      return this;
    }

    public void unsetNs() {
      __isset_bit_vector.clear(__NS_ISSET_ID);
    }

    /** Returns true if field ns is set (has been asigned a value) and false otherwise */
    public boolean isSetNs() {
      return __isset_bit_vector.get(__NS_ISSET_ID);
    }

    public void setNsIsSet(boolean value) {
      __isset_bit_vector.set(__NS_ISSET_ID, value);
    }

    public String getTable_name() {
      return this.table_name;
    }

    public get_cells_args setTable_name(String table_name) {
      this.table_name = table_name;
      return this;
    }

    public void unsetTable_name() {
      this.table_name = null;
    }

    /** Returns true if field table_name is set (has been asigned a value) and false otherwise */
    public boolean isSetTable_name() {
      return this.table_name != null;
    }

    public void setTable_nameIsSet(boolean value) {
      if (!value) {
        this.table_name = null;
      }
    }

    public ScanSpec getScan_spec() {
      return this.scan_spec;
    }

    public get_cells_args setScan_spec(ScanSpec scan_spec) {
      this.scan_spec = scan_spec;
      return this;
    }

    public void unsetScan_spec() {
      this.scan_spec = null;
    }

    /** Returns true if field scan_spec is set (has been asigned a value) and false otherwise */
    public boolean isSetScan_spec() {
      return this.scan_spec != null;
    }

    public void setScan_specIsSet(boolean value) {
      if (!value) {
        this.scan_spec = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case NS:
        if (value == null) {
          unsetNs();
        } else {
          setNs((Long)value);
        }
        break;

      case TABLE_NAME:
        if (value == null) {
          unsetTable_name();
        } else {
          setTable_name((String)value);
        }
        break;

      case SCAN_SPEC:
        if (value == null) {
          unsetScan_spec();
        } else {
          setScan_spec((ScanSpec)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case NS:
        return new Long(getNs());

      case TABLE_NAME:
        return getTable_name();

      case SCAN_SPEC:
        return getScan_spec();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case NS:
        return isSetNs();
      case TABLE_NAME:
        return isSetTable_name();
      case SCAN_SPEC:
        return isSetScan_spec();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_cells_args)
        return this.equals((get_cells_args)that);
      return false;
    }

    public boolean equals(get_cells_args that) {
      if (that == null)
        return false;

      boolean this_present_ns = true;
      boolean that_present_ns = true;
      if (this_present_ns || that_present_ns) {
        if (!(this_present_ns && that_present_ns))
          return false;
        if (this.ns != that.ns)
          return false;
      }

      boolean this_present_table_name = true && this.isSetTable_name();
      boolean that_present_table_name = true && that.isSetTable_name();
      if (this_present_table_name || that_present_table_name) {
        if (!(this_present_table_name && that_present_table_name))
          return false;
        if (!this.table_name.equals(that.table_name))
          return false;
      }

      boolean this_present_scan_spec = true && this.isSetScan_spec();
      boolean that_present_scan_spec = true && that.isSetScan_spec();
      if (this_present_scan_spec || that_present_scan_spec) {
        if (!(this_present_scan_spec && that_present_scan_spec))
          return false;
        if (!this.scan_spec.equals(that.scan_spec))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_cells_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_cells_args typedOther = (get_cells_args)other;

      lastComparison = Boolean.valueOf(isSetNs()).compareTo(typedOther.isSetNs());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetNs()) {
        lastComparison = TBaseHelper.compareTo(this.ns, typedOther.ns);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetTable_name()).compareTo(typedOther.isSetTable_name());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTable_name()) {
        lastComparison = TBaseHelper.compareTo(this.table_name, typedOther.table_name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetScan_spec()).compareTo(typedOther.isSetScan_spec());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetScan_spec()) {
        lastComparison = TBaseHelper.compareTo(this.scan_spec, typedOther.scan_spec);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // NS
            if (field.type == TType.I64) {
              this.ns = iprot.readI64();
              setNsIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // TABLE_NAME
            if (field.type == TType.STRING) {
              this.table_name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // SCAN_SPEC
            if (field.type == TType.STRUCT) {
              this.scan_spec = new ScanSpec();
              this.scan_spec.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(NS_FIELD_DESC);
      oprot.writeI64(this.ns);
      oprot.writeFieldEnd();
      if (this.table_name != null) {
        oprot.writeFieldBegin(TABLE_NAME_FIELD_DESC);
        oprot.writeString(this.table_name);
        oprot.writeFieldEnd();
      }
      if (this.scan_spec != null) {
        oprot.writeFieldBegin(SCAN_SPEC_FIELD_DESC);
        this.scan_spec.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_cells_args(");
      boolean first = true;

      sb.append("ns:");
      sb.append(this.ns);
      first = false;
      if (!first) sb.append(", ");
      sb.append("table_name:");
      if (this.table_name == null) {
        sb.append("null");
      } else {
        sb.append(this.table_name);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("scan_spec:");
      if (this.scan_spec == null) {
        sb.append("null");
      } else {
        sb.append(this.scan_spec);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_cells_result implements TBase<get_cells_result, get_cells_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_cells_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public List<Cell> success;
    public ClientException e;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      E((short)1, "e");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // E
            return E;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new StructMetaData(TType.STRUCT, Cell.class))));
      tmpMap.put(_Fields.E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(get_cells_result.class, metaDataMap);
    }

    public get_cells_result() {
    }

    public get_cells_result(
      List<Cell> success,
      ClientException e)
    {
      this();
      this.success = success;
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_cells_result(get_cells_result other) {
      if (other.isSetSuccess()) {
        List<Cell> __this__success = new ArrayList<Cell>();
        for (Cell other_element : other.success) {
          __this__success.add(new Cell(other_element));
        }
        this.success = __this__success;
      }
      if (other.isSetE()) {
        this.e = new ClientException(other.e);
      }
    }

    public get_cells_result deepCopy() {
      return new get_cells_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.e = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<Cell> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(Cell elem) {
      if (this.success == null) {
        this.success = new ArrayList<Cell>();
      }
      this.success.add(elem);
    }

    public List<Cell> getSuccess() {
      return this.success;
    }

    public get_cells_result setSuccess(List<Cell> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public ClientException getE() {
      return this.e;
    }

    public get_cells_result setE(ClientException e) {
      this.e = e;
      return this;
    }

    public void unsetE() {
      this.e = null;
    }

    /** Returns true if field e is set (has been asigned a value) and false otherwise */
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<Cell>)value);
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((ClientException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case E:
        return getE();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_cells_result)
        return this.equals((get_cells_result)that);
      return false;
    }

    public boolean equals(get_cells_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_cells_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_cells_result typedOther = (get_cells_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetE()).compareTo(typedOther.isSetE());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetE()) {
        lastComparison = TBaseHelper.compareTo(this.e, typedOther.e);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.LIST) {
              {
                TList _list74 = iprot.readListBegin();
                this.success = new ArrayList<Cell>(_list74.size);
                for (int _i75 = 0; _i75 < _list74.size; ++_i75)
                {
                  Cell _elem76;
                  _elem76 = new Cell();
                  _elem76.read(iprot);
                  this.success.add(_elem76);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // E
            if (field.type == TType.STRUCT) {
              this.e = new ClientException();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
          for (Cell _iter77 : this.success)
          {
            _iter77.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetE()) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_cells_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_cells_as_arrays_args implements TBase<get_cells_as_arrays_args, get_cells_as_arrays_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_cells_as_arrays_args");

    private static final TField NS_FIELD_DESC = new TField("ns", TType.I64, (short)1);
    private static final TField NAME_FIELD_DESC = new TField("name", TType.STRING, (short)2);
    private static final TField SCAN_SPEC_FIELD_DESC = new TField("scan_spec", TType.STRUCT, (short)3);

    public long ns;
    public String name;
    public ScanSpec scan_spec;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      NS((short)1, "ns"),
      NAME((short)2, "name"),
      SCAN_SPEC((short)3, "scan_spec");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // NS
            return NS;
          case 2: // NAME
            return NAME;
          case 3: // SCAN_SPEC
            return SCAN_SPEC;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __NS_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.NS, new FieldMetaData("ns", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64          , "Namespace")));
      tmpMap.put(_Fields.NAME, new FieldMetaData("name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.SCAN_SPEC, new FieldMetaData("scan_spec", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ScanSpec.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(get_cells_as_arrays_args.class, metaDataMap);
    }

    public get_cells_as_arrays_args() {
    }

    public get_cells_as_arrays_args(
      long ns,
      String name,
      ScanSpec scan_spec)
    {
      this();
      this.ns = ns;
      setNsIsSet(true);
      this.name = name;
      this.scan_spec = scan_spec;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_cells_as_arrays_args(get_cells_as_arrays_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.ns = other.ns;
      if (other.isSetName()) {
        this.name = other.name;
      }
      if (other.isSetScan_spec()) {
        this.scan_spec = new ScanSpec(other.scan_spec);
      }
    }

    public get_cells_as_arrays_args deepCopy() {
      return new get_cells_as_arrays_args(this);
    }

    @Override
    public void clear() {
      setNsIsSet(false);
      this.ns = 0;
      this.name = null;
      this.scan_spec = null;
    }

    public long getNs() {
      return this.ns;
    }

    public get_cells_as_arrays_args setNs(long ns) {
      this.ns = ns;
      setNsIsSet(true);
      return this;
    }

    public void unsetNs() {
      __isset_bit_vector.clear(__NS_ISSET_ID);
    }

    /** Returns true if field ns is set (has been asigned a value) and false otherwise */
    public boolean isSetNs() {
      return __isset_bit_vector.get(__NS_ISSET_ID);
    }

    public void setNsIsSet(boolean value) {
      __isset_bit_vector.set(__NS_ISSET_ID, value);
    }

    public String getName() {
      return this.name;
    }

    public get_cells_as_arrays_args setName(String name) {
      this.name = name;
      return this;
    }

    public void unsetName() {
      this.name = null;
    }

    /** Returns true if field name is set (has been asigned a value) and false otherwise */
    public boolean isSetName() {
      return this.name != null;
    }

    public void setNameIsSet(boolean value) {
      if (!value) {
        this.name = null;
      }
    }

    public ScanSpec getScan_spec() {
      return this.scan_spec;
    }

    public get_cells_as_arrays_args setScan_spec(ScanSpec scan_spec) {
      this.scan_spec = scan_spec;
      return this;
    }

    public void unsetScan_spec() {
      this.scan_spec = null;
    }

    /** Returns true if field scan_spec is set (has been asigned a value) and false otherwise */
    public boolean isSetScan_spec() {
      return this.scan_spec != null;
    }

    public void setScan_specIsSet(boolean value) {
      if (!value) {
        this.scan_spec = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case NS:
        if (value == null) {
          unsetNs();
        } else {
          setNs((Long)value);
        }
        break;

      case NAME:
        if (value == null) {
          unsetName();
        } else {
          setName((String)value);
        }
        break;

      case SCAN_SPEC:
        if (value == null) {
          unsetScan_spec();
        } else {
          setScan_spec((ScanSpec)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case NS:
        return new Long(getNs());

      case NAME:
        return getName();

      case SCAN_SPEC:
        return getScan_spec();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case NS:
        return isSetNs();
      case NAME:
        return isSetName();
      case SCAN_SPEC:
        return isSetScan_spec();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_cells_as_arrays_args)
        return this.equals((get_cells_as_arrays_args)that);
      return false;
    }

    public boolean equals(get_cells_as_arrays_args that) {
      if (that == null)
        return false;

      boolean this_present_ns = true;
      boolean that_present_ns = true;
      if (this_present_ns || that_present_ns) {
        if (!(this_present_ns && that_present_ns))
          return false;
        if (this.ns != that.ns)
          return false;
      }

      boolean this_present_name = true && this.isSetName();
      boolean that_present_name = true && that.isSetName();
      if (this_present_name || that_present_name) {
        if (!(this_present_name && that_present_name))
          return false;
        if (!this.name.equals(that.name))
          return false;
      }

      boolean this_present_scan_spec = true && this.isSetScan_spec();
      boolean that_present_scan_spec = true && that.isSetScan_spec();
      if (this_present_scan_spec || that_present_scan_spec) {
        if (!(this_present_scan_spec && that_present_scan_spec))
          return false;
        if (!this.scan_spec.equals(that.scan_spec))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_cells_as_arrays_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_cells_as_arrays_args typedOther = (get_cells_as_arrays_args)other;

      lastComparison = Boolean.valueOf(isSetNs()).compareTo(typedOther.isSetNs());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetNs()) {
        lastComparison = TBaseHelper.compareTo(this.ns, typedOther.ns);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetName()).compareTo(typedOther.isSetName());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetName()) {
        lastComparison = TBaseHelper.compareTo(this.name, typedOther.name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetScan_spec()).compareTo(typedOther.isSetScan_spec());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetScan_spec()) {
        lastComparison = TBaseHelper.compareTo(this.scan_spec, typedOther.scan_spec);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // NS
            if (field.type == TType.I64) {
              this.ns = iprot.readI64();
              setNsIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // NAME
            if (field.type == TType.STRING) {
              this.name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // SCAN_SPEC
            if (field.type == TType.STRUCT) {
              this.scan_spec = new ScanSpec();
              this.scan_spec.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(NS_FIELD_DESC);
      oprot.writeI64(this.ns);
      oprot.writeFieldEnd();
      if (this.name != null) {
        oprot.writeFieldBegin(NAME_FIELD_DESC);
        oprot.writeString(this.name);
        oprot.writeFieldEnd();
      }
      if (this.scan_spec != null) {
        oprot.writeFieldBegin(SCAN_SPEC_FIELD_DESC);
        this.scan_spec.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_cells_as_arrays_args(");
      boolean first = true;

      sb.append("ns:");
      sb.append(this.ns);
      first = false;
      if (!first) sb.append(", ");
      sb.append("name:");
      if (this.name == null) {
        sb.append("null");
      } else {
        sb.append(this.name);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("scan_spec:");
      if (this.scan_spec == null) {
        sb.append("null");
      } else {
        sb.append(this.scan_spec);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_cells_as_arrays_result implements TBase<get_cells_as_arrays_result, get_cells_as_arrays_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_cells_as_arrays_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public List<List<String>> success;
    public ClientException e;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      E((short)1, "e");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // E
            return E;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.LIST              , "CellAsArray"))));
      tmpMap.put(_Fields.E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(get_cells_as_arrays_result.class, metaDataMap);
    }

    public get_cells_as_arrays_result() {
    }

    public get_cells_as_arrays_result(
      List<List<String>> success,
      ClientException e)
    {
      this();
      this.success = success;
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_cells_as_arrays_result(get_cells_as_arrays_result other) {
      if (other.isSetSuccess()) {
        List<List<String>> __this__success = new ArrayList<List<String>>();
        for (List<String> other_element : other.success) {
          __this__success.add(other_element);
        }
        this.success = __this__success;
      }
      if (other.isSetE()) {
        this.e = new ClientException(other.e);
      }
    }

    public get_cells_as_arrays_result deepCopy() {
      return new get_cells_as_arrays_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.e = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<List<String>> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(List<String> elem) {
      if (this.success == null) {
        this.success = new ArrayList<List<String>>();
      }
      this.success.add(elem);
    }

    public List<List<String>> getSuccess() {
      return this.success;
    }

    public get_cells_as_arrays_result setSuccess(List<List<String>> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public ClientException getE() {
      return this.e;
    }

    public get_cells_as_arrays_result setE(ClientException e) {
      this.e = e;
      return this;
    }

    public void unsetE() {
      this.e = null;
    }

    /** Returns true if field e is set (has been asigned a value) and false otherwise */
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<List<String>>)value);
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((ClientException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case E:
        return getE();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_cells_as_arrays_result)
        return this.equals((get_cells_as_arrays_result)that);
      return false;
    }

    public boolean equals(get_cells_as_arrays_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_cells_as_arrays_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_cells_as_arrays_result typedOther = (get_cells_as_arrays_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetE()).compareTo(typedOther.isSetE());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetE()) {
        lastComparison = TBaseHelper.compareTo(this.e, typedOther.e);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.LIST) {
              {
                TList _list78 = iprot.readListBegin();
                this.success = new ArrayList<List<String>>(_list78.size);
                for (int _i79 = 0; _i79 < _list78.size; ++_i79)
                {
                  List<String> _elem80;
                  {
                    TList _list81 = iprot.readListBegin();
                    _elem80 = new ArrayList<String>(_list81.size);
                    for (int _i82 = 0; _i82 < _list81.size; ++_i82)
                    {
                      String _elem83;
                      _elem83 = iprot.readString();
                      _elem80.add(_elem83);
                    }
                    iprot.readListEnd();
                  }
                  this.success.add(_elem80);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // E
            if (field.type == TType.STRUCT) {
              this.e = new ClientException();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.LIST, this.success.size()));
          for (List<String> _iter84 : this.success)
          {
            {
              oprot.writeListBegin(new TList(TType.STRING, _iter84.size()));
              for (String _iter85 : _iter84)
              {
                oprot.writeString(_iter85);
              }
              oprot.writeListEnd();
            }
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetE()) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_cells_as_arrays_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_cells_serialized_args implements TBase<get_cells_serialized_args, get_cells_serialized_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_cells_serialized_args");

    private static final TField NS_FIELD_DESC = new TField("ns", TType.I64, (short)1);
    private static final TField NAME_FIELD_DESC = new TField("name", TType.STRING, (short)2);
    private static final TField SCAN_SPEC_FIELD_DESC = new TField("scan_spec", TType.STRUCT, (short)3);

    public long ns;
    public String name;
    public ScanSpec scan_spec;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      NS((short)1, "ns"),
      NAME((short)2, "name"),
      SCAN_SPEC((short)3, "scan_spec");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // NS
            return NS;
          case 2: // NAME
            return NAME;
          case 3: // SCAN_SPEC
            return SCAN_SPEC;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __NS_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.NS, new FieldMetaData("ns", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64          , "Namespace")));
      tmpMap.put(_Fields.NAME, new FieldMetaData("name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.SCAN_SPEC, new FieldMetaData("scan_spec", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ScanSpec.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(get_cells_serialized_args.class, metaDataMap);
    }

    public get_cells_serialized_args() {
    }

    public get_cells_serialized_args(
      long ns,
      String name,
      ScanSpec scan_spec)
    {
      this();
      this.ns = ns;
      setNsIsSet(true);
      this.name = name;
      this.scan_spec = scan_spec;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_cells_serialized_args(get_cells_serialized_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.ns = other.ns;
      if (other.isSetName()) {
        this.name = other.name;
      }
      if (other.isSetScan_spec()) {
        this.scan_spec = new ScanSpec(other.scan_spec);
      }
    }

    public get_cells_serialized_args deepCopy() {
      return new get_cells_serialized_args(this);
    }

    @Override
    public void clear() {
      setNsIsSet(false);
      this.ns = 0;
      this.name = null;
      this.scan_spec = null;
    }

    public long getNs() {
      return this.ns;
    }

    public get_cells_serialized_args setNs(long ns) {
      this.ns = ns;
      setNsIsSet(true);
      return this;
    }

    public void unsetNs() {
      __isset_bit_vector.clear(__NS_ISSET_ID);
    }

    /** Returns true if field ns is set (has been asigned a value) and false otherwise */
    public boolean isSetNs() {
      return __isset_bit_vector.get(__NS_ISSET_ID);
    }

    public void setNsIsSet(boolean value) {
      __isset_bit_vector.set(__NS_ISSET_ID, value);
    }

    public String getName() {
      return this.name;
    }

    public get_cells_serialized_args setName(String name) {
      this.name = name;
      return this;
    }

    public void unsetName() {
      this.name = null;
    }

    /** Returns true if field name is set (has been asigned a value) and false otherwise */
    public boolean isSetName() {
      return this.name != null;
    }

    public void setNameIsSet(boolean value) {
      if (!value) {
        this.name = null;
      }
    }

    public ScanSpec getScan_spec() {
      return this.scan_spec;
    }

    public get_cells_serialized_args setScan_spec(ScanSpec scan_spec) {
      this.scan_spec = scan_spec;
      return this;
    }

    public void unsetScan_spec() {
      this.scan_spec = null;
    }

    /** Returns true if field scan_spec is set (has been asigned a value) and false otherwise */
    public boolean isSetScan_spec() {
      return this.scan_spec != null;
    }

    public void setScan_specIsSet(boolean value) {
      if (!value) {
        this.scan_spec = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case NS:
        if (value == null) {
          unsetNs();
        } else {
          setNs((Long)value);
        }
        break;

      case NAME:
        if (value == null) {
          unsetName();
        } else {
          setName((String)value);
        }
        break;

      case SCAN_SPEC:
        if (value == null) {
          unsetScan_spec();
        } else {
          setScan_spec((ScanSpec)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case NS:
        return new Long(getNs());

      case NAME:
        return getName();

      case SCAN_SPEC:
        return getScan_spec();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case NS:
        return isSetNs();
      case NAME:
        return isSetName();
      case SCAN_SPEC:
        return isSetScan_spec();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_cells_serialized_args)
        return this.equals((get_cells_serialized_args)that);
      return false;
    }

    public boolean equals(get_cells_serialized_args that) {
      if (that == null)
        return false;

      boolean this_present_ns = true;
      boolean that_present_ns = true;
      if (this_present_ns || that_present_ns) {
        if (!(this_present_ns && that_present_ns))
          return false;
        if (this.ns != that.ns)
          return false;
      }

      boolean this_present_name = true && this.isSetName();
      boolean that_present_name = true && that.isSetName();
      if (this_present_name || that_present_name) {
        if (!(this_present_name && that_present_name))
          return false;
        if (!this.name.equals(that.name))
          return false;
      }

      boolean this_present_scan_spec = true && this.isSetScan_spec();
      boolean that_present_scan_spec = true && that.isSetScan_spec();
      if (this_present_scan_spec || that_present_scan_spec) {
        if (!(this_present_scan_spec && that_present_scan_spec))
          return false;
        if (!this.scan_spec.equals(that.scan_spec))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_cells_serialized_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_cells_serialized_args typedOther = (get_cells_serialized_args)other;

      lastComparison = Boolean.valueOf(isSetNs()).compareTo(typedOther.isSetNs());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetNs()) {
        lastComparison = TBaseHelper.compareTo(this.ns, typedOther.ns);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetName()).compareTo(typedOther.isSetName());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetName()) {
        lastComparison = TBaseHelper.compareTo(this.name, typedOther.name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetScan_spec()).compareTo(typedOther.isSetScan_spec());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetScan_spec()) {
        lastComparison = TBaseHelper.compareTo(this.scan_spec, typedOther.scan_spec);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // NS
            if (field.type == TType.I64) {
              this.ns = iprot.readI64();
              setNsIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // NAME
            if (field.type == TType.STRING) {
              this.name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // SCAN_SPEC
            if (field.type == TType.STRUCT) {
              this.scan_spec = new ScanSpec();
              this.scan_spec.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(NS_FIELD_DESC);
      oprot.writeI64(this.ns);
      oprot.writeFieldEnd();
      if (this.name != null) {
        oprot.writeFieldBegin(NAME_FIELD_DESC);
        oprot.writeString(this.name);
        oprot.writeFieldEnd();
      }
      if (this.scan_spec != null) {
        oprot.writeFieldBegin(SCAN_SPEC_FIELD_DESC);
        this.scan_spec.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_cells_serialized_args(");
      boolean first = true;

      sb.append("ns:");
      sb.append(this.ns);
      first = false;
      if (!first) sb.append(", ");
      sb.append("name:");
      if (this.name == null) {
        sb.append("null");
      } else {
        sb.append(this.name);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("scan_spec:");
      if (this.scan_spec == null) {
        sb.append("null");
      } else {
        sb.append(this.scan_spec);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_cells_serialized_result implements TBase<get_cells_serialized_result, get_cells_serialized_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_cells_serialized_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRING, (short)0);
    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public ByteBuffer success;
    public ClientException e;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      E((short)1, "e");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // E
            return E;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING          , "CellsSerialized")));
      tmpMap.put(_Fields.E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(get_cells_serialized_result.class, metaDataMap);
    }

    public get_cells_serialized_result() {
    }

    public get_cells_serialized_result(
      ByteBuffer success,
      ClientException e)
    {
      this();
      this.success = success;
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_cells_serialized_result(get_cells_serialized_result other) {
      if (other.isSetSuccess()) {
        this.success = other.success;
      }
      if (other.isSetE()) {
        this.e = new ClientException(other.e);
      }
    }

    public get_cells_serialized_result deepCopy() {
      return new get_cells_serialized_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.e = null;
    }

    public byte[] getSuccess() {
      setSuccess(TBaseHelper.rightSize(success));
      return success.array();
    }

    public ByteBuffer BufferForSuccess() {
      return success;
    }

    public get_cells_serialized_result setSuccess(byte[] success) {
      setSuccess(ByteBuffer.wrap(success));
      return this;
    }

    public get_cells_serialized_result setSuccess(ByteBuffer success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public ClientException getE() {
      return this.e;
    }

    public get_cells_serialized_result setE(ClientException e) {
      this.e = e;
      return this;
    }

    public void unsetE() {
      this.e = null;
    }

    /** Returns true if field e is set (has been asigned a value) and false otherwise */
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ByteBuffer)value);
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((ClientException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case E:
        return getE();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_cells_serialized_result)
        return this.equals((get_cells_serialized_result)that);
      return false;
    }

    public boolean equals(get_cells_serialized_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_cells_serialized_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_cells_serialized_result typedOther = (get_cells_serialized_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetE()).compareTo(typedOther.isSetE());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetE()) {
        lastComparison = TBaseHelper.compareTo(this.e, typedOther.e);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.STRING) {
              this.success = iprot.readBinary();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // E
            if (field.type == TType.STRUCT) {
              this.e = new ClientException();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeBinary(this.success);
        oprot.writeFieldEnd();
      } else if (this.isSetE()) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_cells_serialized_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class refresh_shared_mutator_args implements TBase<refresh_shared_mutator_args, refresh_shared_mutator_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("refresh_shared_mutator_args");

    private static final TField NS_FIELD_DESC = new TField("ns", TType.I64, (short)1);
    private static final TField TABLE_NAME_FIELD_DESC = new TField("table_name", TType.STRING, (short)2);
    private static final TField MUTATE_SPEC_FIELD_DESC = new TField("mutate_spec", TType.STRUCT, (short)3);

    public long ns;
    public String table_name;
    public MutateSpec mutate_spec;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      NS((short)1, "ns"),
      TABLE_NAME((short)2, "table_name"),
      MUTATE_SPEC((short)3, "mutate_spec");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // NS
            return NS;
          case 2: // TABLE_NAME
            return TABLE_NAME;
          case 3: // MUTATE_SPEC
            return MUTATE_SPEC;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __NS_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.NS, new FieldMetaData("ns", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64          , "Namespace")));
      tmpMap.put(_Fields.TABLE_NAME, new FieldMetaData("table_name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.MUTATE_SPEC, new FieldMetaData("mutate_spec", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, MutateSpec.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(refresh_shared_mutator_args.class, metaDataMap);
    }

    public refresh_shared_mutator_args() {
    }

    public refresh_shared_mutator_args(
      long ns,
      String table_name,
      MutateSpec mutate_spec)
    {
      this();
      this.ns = ns;
      setNsIsSet(true);
      this.table_name = table_name;
      this.mutate_spec = mutate_spec;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public refresh_shared_mutator_args(refresh_shared_mutator_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.ns = other.ns;
      if (other.isSetTable_name()) {
        this.table_name = other.table_name;
      }
      if (other.isSetMutate_spec()) {
        this.mutate_spec = new MutateSpec(other.mutate_spec);
      }
    }

    public refresh_shared_mutator_args deepCopy() {
      return new refresh_shared_mutator_args(this);
    }

    @Override
    public void clear() {
      setNsIsSet(false);
      this.ns = 0;
      this.table_name = null;
      this.mutate_spec = null;
    }

    public long getNs() {
      return this.ns;
    }

    public refresh_shared_mutator_args setNs(long ns) {
      this.ns = ns;
      setNsIsSet(true);
      return this;
    }

    public void unsetNs() {
      __isset_bit_vector.clear(__NS_ISSET_ID);
    }

    /** Returns true if field ns is set (has been asigned a value) and false otherwise */
    public boolean isSetNs() {
      return __isset_bit_vector.get(__NS_ISSET_ID);
    }

    public void setNsIsSet(boolean value) {
      __isset_bit_vector.set(__NS_ISSET_ID, value);
    }

    public String getTable_name() {
      return this.table_name;
    }

    public refresh_shared_mutator_args setTable_name(String table_name) {
      this.table_name = table_name;
      return this;
    }

    public void unsetTable_name() {
      this.table_name = null;
    }

    /** Returns true if field table_name is set (has been asigned a value) and false otherwise */
    public boolean isSetTable_name() {
      return this.table_name != null;
    }

    public void setTable_nameIsSet(boolean value) {
      if (!value) {
        this.table_name = null;
      }
    }

    public MutateSpec getMutate_spec() {
      return this.mutate_spec;
    }

    public refresh_shared_mutator_args setMutate_spec(MutateSpec mutate_spec) {
      this.mutate_spec = mutate_spec;
      return this;
    }

    public void unsetMutate_spec() {
      this.mutate_spec = null;
    }

    /** Returns true if field mutate_spec is set (has been asigned a value) and false otherwise */
    public boolean isSetMutate_spec() {
      return this.mutate_spec != null;
    }

    public void setMutate_specIsSet(boolean value) {
      if (!value) {
        this.mutate_spec = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case NS:
        if (value == null) {
          unsetNs();
        } else {
          setNs((Long)value);
        }
        break;

      case TABLE_NAME:
        if (value == null) {
          unsetTable_name();
        } else {
          setTable_name((String)value);
        }
        break;

      case MUTATE_SPEC:
        if (value == null) {
          unsetMutate_spec();
        } else {
          setMutate_spec((MutateSpec)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case NS:
        return new Long(getNs());

      case TABLE_NAME:
        return getTable_name();

      case MUTATE_SPEC:
        return getMutate_spec();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case NS:
        return isSetNs();
      case TABLE_NAME:
        return isSetTable_name();
      case MUTATE_SPEC:
        return isSetMutate_spec();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof refresh_shared_mutator_args)
        return this.equals((refresh_shared_mutator_args)that);
      return false;
    }

    public boolean equals(refresh_shared_mutator_args that) {
      if (that == null)
        return false;

      boolean this_present_ns = true;
      boolean that_present_ns = true;
      if (this_present_ns || that_present_ns) {
        if (!(this_present_ns && that_present_ns))
          return false;
        if (this.ns != that.ns)
          return false;
      }

      boolean this_present_table_name = true && this.isSetTable_name();
      boolean that_present_table_name = true && that.isSetTable_name();
      if (this_present_table_name || that_present_table_name) {
        if (!(this_present_table_name && that_present_table_name))
          return false;
        if (!this.table_name.equals(that.table_name))
          return false;
      }

      boolean this_present_mutate_spec = true && this.isSetMutate_spec();
      boolean that_present_mutate_spec = true && that.isSetMutate_spec();
      if (this_present_mutate_spec || that_present_mutate_spec) {
        if (!(this_present_mutate_spec && that_present_mutate_spec))
          return false;
        if (!this.mutate_spec.equals(that.mutate_spec))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(refresh_shared_mutator_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      refresh_shared_mutator_args typedOther = (refresh_shared_mutator_args)other;

      lastComparison = Boolean.valueOf(isSetNs()).compareTo(typedOther.isSetNs());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetNs()) {
        lastComparison = TBaseHelper.compareTo(this.ns, typedOther.ns);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetTable_name()).compareTo(typedOther.isSetTable_name());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTable_name()) {
        lastComparison = TBaseHelper.compareTo(this.table_name, typedOther.table_name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetMutate_spec()).compareTo(typedOther.isSetMutate_spec());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetMutate_spec()) {
        lastComparison = TBaseHelper.compareTo(this.mutate_spec, typedOther.mutate_spec);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // NS
            if (field.type == TType.I64) {
              this.ns = iprot.readI64();
              setNsIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // TABLE_NAME
            if (field.type == TType.STRING) {
              this.table_name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // MUTATE_SPEC
            if (field.type == TType.STRUCT) {
              this.mutate_spec = new MutateSpec();
              this.mutate_spec.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(NS_FIELD_DESC);
      oprot.writeI64(this.ns);
      oprot.writeFieldEnd();
      if (this.table_name != null) {
        oprot.writeFieldBegin(TABLE_NAME_FIELD_DESC);
        oprot.writeString(this.table_name);
        oprot.writeFieldEnd();
      }
      if (this.mutate_spec != null) {
        oprot.writeFieldBegin(MUTATE_SPEC_FIELD_DESC);
        this.mutate_spec.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("refresh_shared_mutator_args(");
      boolean first = true;

      sb.append("ns:");
      sb.append(this.ns);
      first = false;
      if (!first) sb.append(", ");
      sb.append("table_name:");
      if (this.table_name == null) {
        sb.append("null");
      } else {
        sb.append(this.table_name);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("mutate_spec:");
      if (this.mutate_spec == null) {
        sb.append("null");
      } else {
        sb.append(this.mutate_spec);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class refresh_shared_mutator_result implements TBase<refresh_shared_mutator_result, refresh_shared_mutator_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("refresh_shared_mutator_result");

    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public ClientException e;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      E((short)1, "e");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // E
            return E;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(refresh_shared_mutator_result.class, metaDataMap);
    }

    public refresh_shared_mutator_result() {
    }

    public refresh_shared_mutator_result(
      ClientException e)
    {
      this();
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public refresh_shared_mutator_result(refresh_shared_mutator_result other) {
      if (other.isSetE()) {
        this.e = new ClientException(other.e);
      }
    }

    public refresh_shared_mutator_result deepCopy() {
      return new refresh_shared_mutator_result(this);
    }

    @Override
    public void clear() {
      this.e = null;
    }

    public ClientException getE() {
      return this.e;
    }

    public refresh_shared_mutator_result setE(ClientException e) {
      this.e = e;
      return this;
    }

    public void unsetE() {
      this.e = null;
    }

    /** Returns true if field e is set (has been asigned a value) and false otherwise */
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((ClientException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case E:
        return getE();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case E:
        return isSetE();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof refresh_shared_mutator_result)
        return this.equals((refresh_shared_mutator_result)that);
      return false;
    }

    public boolean equals(refresh_shared_mutator_result that) {
      if (that == null)
        return false;

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(refresh_shared_mutator_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      refresh_shared_mutator_result typedOther = (refresh_shared_mutator_result)other;

      lastComparison = Boolean.valueOf(isSetE()).compareTo(typedOther.isSetE());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetE()) {
        lastComparison = TBaseHelper.compareTo(this.e, typedOther.e);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // E
            if (field.type == TType.STRUCT) {
              this.e = new ClientException();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetE()) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("refresh_shared_mutator_result(");
      boolean first = true;

      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class offer_cells_args implements TBase<offer_cells_args, offer_cells_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("offer_cells_args");

    private static final TField NS_FIELD_DESC = new TField("ns", TType.I64, (short)1);
    private static final TField TABLE_NAME_FIELD_DESC = new TField("table_name", TType.STRING, (short)2);
    private static final TField MUTATE_SPEC_FIELD_DESC = new TField("mutate_spec", TType.STRUCT, (short)3);
    private static final TField CELLS_FIELD_DESC = new TField("cells", TType.LIST, (short)4);

    public long ns;
    public String table_name;
    public MutateSpec mutate_spec;
    public List<Cell> cells;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      NS((short)1, "ns"),
      TABLE_NAME((short)2, "table_name"),
      MUTATE_SPEC((short)3, "mutate_spec"),
      CELLS((short)4, "cells");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // NS
            return NS;
          case 2: // TABLE_NAME
            return TABLE_NAME;
          case 3: // MUTATE_SPEC
            return MUTATE_SPEC;
          case 4: // CELLS
            return CELLS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __NS_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.NS, new FieldMetaData("ns", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64          , "Namespace")));
      tmpMap.put(_Fields.TABLE_NAME, new FieldMetaData("table_name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.MUTATE_SPEC, new FieldMetaData("mutate_spec", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, MutateSpec.class)));
      tmpMap.put(_Fields.CELLS, new FieldMetaData("cells", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new StructMetaData(TType.STRUCT, Cell.class))));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(offer_cells_args.class, metaDataMap);
    }

    public offer_cells_args() {
    }

    public offer_cells_args(
      long ns,
      String table_name,
      MutateSpec mutate_spec,
      List<Cell> cells)
    {
      this();
      this.ns = ns;
      setNsIsSet(true);
      this.table_name = table_name;
      this.mutate_spec = mutate_spec;
      this.cells = cells;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public offer_cells_args(offer_cells_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.ns = other.ns;
      if (other.isSetTable_name()) {
        this.table_name = other.table_name;
      }
      if (other.isSetMutate_spec()) {
        this.mutate_spec = new MutateSpec(other.mutate_spec);
      }
      if (other.isSetCells()) {
        List<Cell> __this__cells = new ArrayList<Cell>();
        for (Cell other_element : other.cells) {
          __this__cells.add(new Cell(other_element));
        }
        this.cells = __this__cells;
      }
    }

    public offer_cells_args deepCopy() {
      return new offer_cells_args(this);
    }

    @Override
    public void clear() {
      setNsIsSet(false);
      this.ns = 0;
      this.table_name = null;
      this.mutate_spec = null;
      this.cells = null;
    }

    public long getNs() {
      return this.ns;
    }

    public offer_cells_args setNs(long ns) {
      this.ns = ns;
      setNsIsSet(true);
      return this;
    }

    public void unsetNs() {
      __isset_bit_vector.clear(__NS_ISSET_ID);
    }

    /** Returns true if field ns is set (has been asigned a value) and false otherwise */
    public boolean isSetNs() {
      return __isset_bit_vector.get(__NS_ISSET_ID);
    }

    public void setNsIsSet(boolean value) {
      __isset_bit_vector.set(__NS_ISSET_ID, value);
    }

    public String getTable_name() {
      return this.table_name;
    }

    public offer_cells_args setTable_name(String table_name) {
      this.table_name = table_name;
      return this;
    }

    public void unsetTable_name() {
      this.table_name = null;
    }

    /** Returns true if field table_name is set (has been asigned a value) and false otherwise */
    public boolean isSetTable_name() {
      return this.table_name != null;
    }

    public void setTable_nameIsSet(boolean value) {
      if (!value) {
        this.table_name = null;
      }
    }

    public MutateSpec getMutate_spec() {
      return this.mutate_spec;
    }

    public offer_cells_args setMutate_spec(MutateSpec mutate_spec) {
      this.mutate_spec = mutate_spec;
      return this;
    }

    public void unsetMutate_spec() {
      this.mutate_spec = null;
    }

    /** Returns true if field mutate_spec is set (has been asigned a value) and false otherwise */
    public boolean isSetMutate_spec() {
      return this.mutate_spec != null;
    }

    public void setMutate_specIsSet(boolean value) {
      if (!value) {
        this.mutate_spec = null;
      }
    }

    public int getCellsSize() {
      return (this.cells == null) ? 0 : this.cells.size();
    }

    public java.util.Iterator<Cell> getCellsIterator() {
      return (this.cells == null) ? null : this.cells.iterator();
    }

    public void addToCells(Cell elem) {
      if (this.cells == null) {
        this.cells = new ArrayList<Cell>();
      }
      this.cells.add(elem);
    }

    public List<Cell> getCells() {
      return this.cells;
    }

    public offer_cells_args setCells(List<Cell> cells) {
      this.cells = cells;
      return this;
    }

    public void unsetCells() {
      this.cells = null;
    }

    /** Returns true if field cells is set (has been asigned a value) and false otherwise */
    public boolean isSetCells() {
      return this.cells != null;
    }

    public void setCellsIsSet(boolean value) {
      if (!value) {
        this.cells = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case NS:
        if (value == null) {
          unsetNs();
        } else {
          setNs((Long)value);
        }
        break;

      case TABLE_NAME:
        if (value == null) {
          unsetTable_name();
        } else {
          setTable_name((String)value);
        }
        break;

      case MUTATE_SPEC:
        if (value == null) {
          unsetMutate_spec();
        } else {
          setMutate_spec((MutateSpec)value);
        }
        break;

      case CELLS:
        if (value == null) {
          unsetCells();
        } else {
          setCells((List<Cell>)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case NS:
        return new Long(getNs());

      case TABLE_NAME:
        return getTable_name();

      case MUTATE_SPEC:
        return getMutate_spec();

      case CELLS:
        return getCells();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case NS:
        return isSetNs();
      case TABLE_NAME:
        return isSetTable_name();
      case MUTATE_SPEC:
        return isSetMutate_spec();
      case CELLS:
        return isSetCells();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof offer_cells_args)
        return this.equals((offer_cells_args)that);
      return false;
    }

    public boolean equals(offer_cells_args that) {
      if (that == null)
        return false;

      boolean this_present_ns = true;
      boolean that_present_ns = true;
      if (this_present_ns || that_present_ns) {
        if (!(this_present_ns && that_present_ns))
          return false;
        if (this.ns != that.ns)
          return false;
      }

      boolean this_present_table_name = true && this.isSetTable_name();
      boolean that_present_table_name = true && that.isSetTable_name();
      if (this_present_table_name || that_present_table_name) {
        if (!(this_present_table_name && that_present_table_name))
          return false;
        if (!this.table_name.equals(that.table_name))
          return false;
      }

      boolean this_present_mutate_spec = true && this.isSetMutate_spec();
      boolean that_present_mutate_spec = true && that.isSetMutate_spec();
      if (this_present_mutate_spec || that_present_mutate_spec) {
        if (!(this_present_mutate_spec && that_present_mutate_spec))
          return false;
        if (!this.mutate_spec.equals(that.mutate_spec))
          return false;
      }

      boolean this_present_cells = true && this.isSetCells();
      boolean that_present_cells = true && that.isSetCells();
      if (this_present_cells || that_present_cells) {
        if (!(this_present_cells && that_present_cells))
          return false;
        if (!this.cells.equals(that.cells))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(offer_cells_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      offer_cells_args typedOther = (offer_cells_args)other;

      lastComparison = Boolean.valueOf(isSetNs()).compareTo(typedOther.isSetNs());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetNs()) {
        lastComparison = TBaseHelper.compareTo(this.ns, typedOther.ns);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetTable_name()).compareTo(typedOther.isSetTable_name());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTable_name()) {
        lastComparison = TBaseHelper.compareTo(this.table_name, typedOther.table_name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetMutate_spec()).compareTo(typedOther.isSetMutate_spec());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetMutate_spec()) {
        lastComparison = TBaseHelper.compareTo(this.mutate_spec, typedOther.mutate_spec);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetCells()).compareTo(typedOther.isSetCells());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetCells()) {
        lastComparison = TBaseHelper.compareTo(this.cells, typedOther.cells);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // NS
            if (field.type == TType.I64) {
              this.ns = iprot.readI64();
              setNsIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // TABLE_NAME
            if (field.type == TType.STRING) {
              this.table_name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // MUTATE_SPEC
            if (field.type == TType.STRUCT) {
              this.mutate_spec = new MutateSpec();
              this.mutate_spec.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 4: // CELLS
            if (field.type == TType.LIST) {
              {
                TList _list86 = iprot.readListBegin();
                this.cells = new ArrayList<Cell>(_list86.size);
                for (int _i87 = 0; _i87 < _list86.size; ++_i87)
                {
                  Cell _elem88;
                  _elem88 = new Cell();
                  _elem88.read(iprot);
                  this.cells.add(_elem88);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(NS_FIELD_DESC);
      oprot.writeI64(this.ns);
      oprot.writeFieldEnd();
      if (this.table_name != null) {
        oprot.writeFieldBegin(TABLE_NAME_FIELD_DESC);
        oprot.writeString(this.table_name);
        oprot.writeFieldEnd();
      }
      if (this.mutate_spec != null) {
        oprot.writeFieldBegin(MUTATE_SPEC_FIELD_DESC);
        this.mutate_spec.write(oprot);
        oprot.writeFieldEnd();
      }
      if (this.cells != null) {
        oprot.writeFieldBegin(CELLS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.cells.size()));
          for (Cell _iter89 : this.cells)
          {
            _iter89.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("offer_cells_args(");
      boolean first = true;

      sb.append("ns:");
      sb.append(this.ns);
      first = false;
      if (!first) sb.append(", ");
      sb.append("table_name:");
      if (this.table_name == null) {
        sb.append("null");
      } else {
        sb.append(this.table_name);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("mutate_spec:");
      if (this.mutate_spec == null) {
        sb.append("null");
      } else {
        sb.append(this.mutate_spec);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("cells:");
      if (this.cells == null) {
        sb.append("null");
      } else {
        sb.append(this.cells);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class offer_cells_result implements TBase<offer_cells_result, offer_cells_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("offer_cells_result");

    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public ClientException e;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      E((short)1, "e");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // E
            return E;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(offer_cells_result.class, metaDataMap);
    }

    public offer_cells_result() {
    }

    public offer_cells_result(
      ClientException e)
    {
      this();
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public offer_cells_result(offer_cells_result other) {
      if (other.isSetE()) {
        this.e = new ClientException(other.e);
      }
    }

    public offer_cells_result deepCopy() {
      return new offer_cells_result(this);
    }

    @Override
    public void clear() {
      this.e = null;
    }

    public ClientException getE() {
      return this.e;
    }

    public offer_cells_result setE(ClientException e) {
      this.e = e;
      return this;
    }

    public void unsetE() {
      this.e = null;
    }

    /** Returns true if field e is set (has been asigned a value) and false otherwise */
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((ClientException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case E:
        return getE();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case E:
        return isSetE();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof offer_cells_result)
        return this.equals((offer_cells_result)that);
      return false;
    }

    public boolean equals(offer_cells_result that) {
      if (that == null)
        return false;

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(offer_cells_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      offer_cells_result typedOther = (offer_cells_result)other;

      lastComparison = Boolean.valueOf(isSetE()).compareTo(typedOther.isSetE());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetE()) {
        lastComparison = TBaseHelper.compareTo(this.e, typedOther.e);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // E
            if (field.type == TType.STRUCT) {
              this.e = new ClientException();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetE()) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("offer_cells_result(");
      boolean first = true;

      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class offer_cells_as_arrays_args implements TBase<offer_cells_as_arrays_args, offer_cells_as_arrays_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("offer_cells_as_arrays_args");

    private static final TField NS_FIELD_DESC = new TField("ns", TType.I64, (short)1);
    private static final TField TABLE_NAME_FIELD_DESC = new TField("table_name", TType.STRING, (short)2);
    private static final TField MUTATE_SPEC_FIELD_DESC = new TField("mutate_spec", TType.STRUCT, (short)3);
    private static final TField CELLS_FIELD_DESC = new TField("cells", TType.LIST, (short)4);

    public long ns;
    public String table_name;
    public MutateSpec mutate_spec;
    public List<List<String>> cells;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      NS((short)1, "ns"),
      TABLE_NAME((short)2, "table_name"),
      MUTATE_SPEC((short)3, "mutate_spec"),
      CELLS((short)4, "cells");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // NS
            return NS;
          case 2: // TABLE_NAME
            return TABLE_NAME;
          case 3: // MUTATE_SPEC
            return MUTATE_SPEC;
          case 4: // CELLS
            return CELLS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __NS_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.NS, new FieldMetaData("ns", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64          , "Namespace")));
      tmpMap.put(_Fields.TABLE_NAME, new FieldMetaData("table_name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.MUTATE_SPEC, new FieldMetaData("mutate_spec", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, MutateSpec.class)));
      tmpMap.put(_Fields.CELLS, new FieldMetaData("cells", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.LIST              , "CellAsArray"))));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(offer_cells_as_arrays_args.class, metaDataMap);
    }

    public offer_cells_as_arrays_args() {
    }

    public offer_cells_as_arrays_args(
      long ns,
      String table_name,
      MutateSpec mutate_spec,
      List<List<String>> cells)
    {
      this();
      this.ns = ns;
      setNsIsSet(true);
      this.table_name = table_name;
      this.mutate_spec = mutate_spec;
      this.cells = cells;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public offer_cells_as_arrays_args(offer_cells_as_arrays_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.ns = other.ns;
      if (other.isSetTable_name()) {
        this.table_name = other.table_name;
      }
      if (other.isSetMutate_spec()) {
        this.mutate_spec = new MutateSpec(other.mutate_spec);
      }
      if (other.isSetCells()) {
        List<List<String>> __this__cells = new ArrayList<List<String>>();
        for (List<String> other_element : other.cells) {
          __this__cells.add(other_element);
        }
        this.cells = __this__cells;
      }
    }

    public offer_cells_as_arrays_args deepCopy() {
      return new offer_cells_as_arrays_args(this);
    }

    @Override
    public void clear() {
      setNsIsSet(false);
      this.ns = 0;
      this.table_name = null;
      this.mutate_spec = null;
      this.cells = null;
    }

    public long getNs() {
      return this.ns;
    }

    public offer_cells_as_arrays_args setNs(long ns) {
      this.ns = ns;
      setNsIsSet(true);
      return this;
    }

    public void unsetNs() {
      __isset_bit_vector.clear(__NS_ISSET_ID);
    }

    /** Returns true if field ns is set (has been asigned a value) and false otherwise */
    public boolean isSetNs() {
      return __isset_bit_vector.get(__NS_ISSET_ID);
    }

    public void setNsIsSet(boolean value) {
      __isset_bit_vector.set(__NS_ISSET_ID, value);
    }

    public String getTable_name() {
      return this.table_name;
    }

    public offer_cells_as_arrays_args setTable_name(String table_name) {
      this.table_name = table_name;
      return this;
    }

    public void unsetTable_name() {
      this.table_name = null;
    }

    /** Returns true if field table_name is set (has been asigned a value) and false otherwise */
    public boolean isSetTable_name() {
      return this.table_name != null;
    }

    public void setTable_nameIsSet(boolean value) {
      if (!value) {
        this.table_name = null;
      }
    }

    public MutateSpec getMutate_spec() {
      return this.mutate_spec;
    }

    public offer_cells_as_arrays_args setMutate_spec(MutateSpec mutate_spec) {
      this.mutate_spec = mutate_spec;
      return this;
    }

    public void unsetMutate_spec() {
      this.mutate_spec = null;
    }

    /** Returns true if field mutate_spec is set (has been asigned a value) and false otherwise */
    public boolean isSetMutate_spec() {
      return this.mutate_spec != null;
    }

    public void setMutate_specIsSet(boolean value) {
      if (!value) {
        this.mutate_spec = null;
      }
    }

    public int getCellsSize() {
      return (this.cells == null) ? 0 : this.cells.size();
    }

    public java.util.Iterator<List<String>> getCellsIterator() {
      return (this.cells == null) ? null : this.cells.iterator();
    }

    public void addToCells(List<String> elem) {
      if (this.cells == null) {
        this.cells = new ArrayList<List<String>>();
      }
      this.cells.add(elem);
    }

    public List<List<String>> getCells() {
      return this.cells;
    }

    public offer_cells_as_arrays_args setCells(List<List<String>> cells) {
      this.cells = cells;
      return this;
    }

    public void unsetCells() {
      this.cells = null;
    }

    /** Returns true if field cells is set (has been asigned a value) and false otherwise */
    public boolean isSetCells() {
      return this.cells != null;
    }

    public void setCellsIsSet(boolean value) {
      if (!value) {
        this.cells = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case NS:
        if (value == null) {
          unsetNs();
        } else {
          setNs((Long)value);
        }
        break;

      case TABLE_NAME:
        if (value == null) {
          unsetTable_name();
        } else {
          setTable_name((String)value);
        }
        break;

      case MUTATE_SPEC:
        if (value == null) {
          unsetMutate_spec();
        } else {
          setMutate_spec((MutateSpec)value);
        }
        break;

      case CELLS:
        if (value == null) {
          unsetCells();
        } else {
          setCells((List<List<String>>)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case NS:
        return new Long(getNs());

      case TABLE_NAME:
        return getTable_name();

      case MUTATE_SPEC:
        return getMutate_spec();

      case CELLS:
        return getCells();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case NS:
        return isSetNs();
      case TABLE_NAME:
        return isSetTable_name();
      case MUTATE_SPEC:
        return isSetMutate_spec();
      case CELLS:
        return isSetCells();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof offer_cells_as_arrays_args)
        return this.equals((offer_cells_as_arrays_args)that);
      return false;
    }

    public boolean equals(offer_cells_as_arrays_args that) {
      if (that == null)
        return false;

      boolean this_present_ns = true;
      boolean that_present_ns = true;
      if (this_present_ns || that_present_ns) {
        if (!(this_present_ns && that_present_ns))
          return false;
        if (this.ns != that.ns)
          return false;
      }

      boolean this_present_table_name = true && this.isSetTable_name();
      boolean that_present_table_name = true && that.isSetTable_name();
      if (this_present_table_name || that_present_table_name) {
        if (!(this_present_table_name && that_present_table_name))
          return false;
        if (!this.table_name.equals(that.table_name))
          return false;
      }

      boolean this_present_mutate_spec = true && this.isSetMutate_spec();
      boolean that_present_mutate_spec = true && that.isSetMutate_spec();
      if (this_present_mutate_spec || that_present_mutate_spec) {
        if (!(this_present_mutate_spec && that_present_mutate_spec))
          return false;
        if (!this.mutate_spec.equals(that.mutate_spec))
          return false;
      }

      boolean this_present_cells = true && this.isSetCells();
      boolean that_present_cells = true && that.isSetCells();
      if (this_present_cells || that_present_cells) {
        if (!(this_present_cells && that_present_cells))
          return false;
        if (!this.cells.equals(that.cells))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(offer_cells_as_arrays_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      offer_cells_as_arrays_args typedOther = (offer_cells_as_arrays_args)other;

      lastComparison = Boolean.valueOf(isSetNs()).compareTo(typedOther.isSetNs());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetNs()) {
        lastComparison = TBaseHelper.compareTo(this.ns, typedOther.ns);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetTable_name()).compareTo(typedOther.isSetTable_name());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTable_name()) {
        lastComparison = TBaseHelper.compareTo(this.table_name, typedOther.table_name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetMutate_spec()).compareTo(typedOther.isSetMutate_spec());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetMutate_spec()) {
        lastComparison = TBaseHelper.compareTo(this.mutate_spec, typedOther.mutate_spec);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetCells()).compareTo(typedOther.isSetCells());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetCells()) {
        lastComparison = TBaseHelper.compareTo(this.cells, typedOther.cells);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // NS
            if (field.type == TType.I64) {
              this.ns = iprot.readI64();
              setNsIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // TABLE_NAME
            if (field.type == TType.STRING) {
              this.table_name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // MUTATE_SPEC
            if (field.type == TType.STRUCT) {
              this.mutate_spec = new MutateSpec();
              this.mutate_spec.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 4: // CELLS
            if (field.type == TType.LIST) {
              {
                TList _list90 = iprot.readListBegin();
                this.cells = new ArrayList<List<String>>(_list90.size);
                for (int _i91 = 0; _i91 < _list90.size; ++_i91)
                {
                  List<String> _elem92;
                  {
                    TList _list93 = iprot.readListBegin();
                    _elem92 = new ArrayList<String>(_list93.size);
                    for (int _i94 = 0; _i94 < _list93.size; ++_i94)
                    {
                      String _elem95;
                      _elem95 = iprot.readString();
                      _elem92.add(_elem95);
                    }
                    iprot.readListEnd();
                  }
                  this.cells.add(_elem92);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(NS_FIELD_DESC);
      oprot.writeI64(this.ns);
      oprot.writeFieldEnd();
      if (this.table_name != null) {
        oprot.writeFieldBegin(TABLE_NAME_FIELD_DESC);
        oprot.writeString(this.table_name);
        oprot.writeFieldEnd();
      }
      if (this.mutate_spec != null) {
        oprot.writeFieldBegin(MUTATE_SPEC_FIELD_DESC);
        this.mutate_spec.write(oprot);
        oprot.writeFieldEnd();
      }
      if (this.cells != null) {
        oprot.writeFieldBegin(CELLS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.LIST, this.cells.size()));
          for (List<String> _iter96 : this.cells)
          {
            {
              oprot.writeListBegin(new TList(TType.STRING, _iter96.size()));
              for (String _iter97 : _iter96)
              {
                oprot.writeString(_iter97);
              }
              oprot.writeListEnd();
            }
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("offer_cells_as_arrays_args(");
      boolean first = true;

      sb.append("ns:");
      sb.append(this.ns);
      first = false;
      if (!first) sb.append(", ");
      sb.append("table_name:");
      if (this.table_name == null) {
        sb.append("null");
      } else {
        sb.append(this.table_name);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("mutate_spec:");
      if (this.mutate_spec == null) {
        sb.append("null");
      } else {
        sb.append(this.mutate_spec);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("cells:");
      if (this.cells == null) {
        sb.append("null");
      } else {
        sb.append(this.cells);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class offer_cells_as_arrays_result implements TBase<offer_cells_as_arrays_result, offer_cells_as_arrays_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("offer_cells_as_arrays_result");

    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public ClientException e;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      E((short)1, "e");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // E
            return E;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(offer_cells_as_arrays_result.class, metaDataMap);
    }

    public offer_cells_as_arrays_result() {
    }

    public offer_cells_as_arrays_result(
      ClientException e)
    {
      this();
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public offer_cells_as_arrays_result(offer_cells_as_arrays_result other) {
      if (other.isSetE()) {
        this.e = new ClientException(other.e);
      }
    }

    public offer_cells_as_arrays_result deepCopy() {
      return new offer_cells_as_arrays_result(this);
    }

    @Override
    public void clear() {
      this.e = null;
    }

    public ClientException getE() {
      return this.e;
    }

    public offer_cells_as_arrays_result setE(ClientException e) {
      this.e = e;
      return this;
    }

    public void unsetE() {
      this.e = null;
    }

    /** Returns true if field e is set (has been asigned a value) and false otherwise */
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((ClientException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case E:
        return getE();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case E:
        return isSetE();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof offer_cells_as_arrays_result)
        return this.equals((offer_cells_as_arrays_result)that);
      return false;
    }

    public boolean equals(offer_cells_as_arrays_result that) {
      if (that == null)
        return false;

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(offer_cells_as_arrays_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      offer_cells_as_arrays_result typedOther = (offer_cells_as_arrays_result)other;

      lastComparison = Boolean.valueOf(isSetE()).compareTo(typedOther.isSetE());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetE()) {
        lastComparison = TBaseHelper.compareTo(this.e, typedOther.e);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // E
            if (field.type == TType.STRUCT) {
              this.e = new ClientException();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetE()) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("offer_cells_as_arrays_result(");
      boolean first = true;

      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class offer_cell_args implements TBase<offer_cell_args, offer_cell_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("offer_cell_args");

    private static final TField NS_FIELD_DESC = new TField("ns", TType.I64, (short)1);
    private static final TField TABLE_NAME_FIELD_DESC = new TField("table_name", TType.STRING, (short)2);
    private static final TField MUTATE_SPEC_FIELD_DESC = new TField("mutate_spec", TType.STRUCT, (short)3);
    private static final TField CELL_FIELD_DESC = new TField("cell", TType.STRUCT, (short)4);

    public long ns;
    public String table_name;
    public MutateSpec mutate_spec;
    public Cell cell;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      NS((short)1, "ns"),
      TABLE_NAME((short)2, "table_name"),
      MUTATE_SPEC((short)3, "mutate_spec"),
      CELL((short)4, "cell");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // NS
            return NS;
          case 2: // TABLE_NAME
            return TABLE_NAME;
          case 3: // MUTATE_SPEC
            return MUTATE_SPEC;
          case 4: // CELL
            return CELL;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __NS_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.NS, new FieldMetaData("ns", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64          , "Namespace")));
      tmpMap.put(_Fields.TABLE_NAME, new FieldMetaData("table_name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.MUTATE_SPEC, new FieldMetaData("mutate_spec", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, MutateSpec.class)));
      tmpMap.put(_Fields.CELL, new FieldMetaData("cell", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, Cell.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(offer_cell_args.class, metaDataMap);
    }

    public offer_cell_args() {
    }

    public offer_cell_args(
      long ns,
      String table_name,
      MutateSpec mutate_spec,
      Cell cell)
    {
      this();
      this.ns = ns;
      setNsIsSet(true);
      this.table_name = table_name;
      this.mutate_spec = mutate_spec;
      this.cell = cell;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public offer_cell_args(offer_cell_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.ns = other.ns;
      if (other.isSetTable_name()) {
        this.table_name = other.table_name;
      }
      if (other.isSetMutate_spec()) {
        this.mutate_spec = new MutateSpec(other.mutate_spec);
      }
      if (other.isSetCell()) {
        this.cell = new Cell(other.cell);
      }
    }

    public offer_cell_args deepCopy() {
      return new offer_cell_args(this);
    }

    @Override
    public void clear() {
      setNsIsSet(false);
      this.ns = 0;
      this.table_name = null;
      this.mutate_spec = null;
      this.cell = null;
    }

    public long getNs() {
      return this.ns;
    }

    public offer_cell_args setNs(long ns) {
      this.ns = ns;
      setNsIsSet(true);
      return this;
    }

    public void unsetNs() {
      __isset_bit_vector.clear(__NS_ISSET_ID);
    }

    /** Returns true if field ns is set (has been asigned a value) and false otherwise */
    public boolean isSetNs() {
      return __isset_bit_vector.get(__NS_ISSET_ID);
    }

    public void setNsIsSet(boolean value) {
      __isset_bit_vector.set(__NS_ISSET_ID, value);
    }

    public String getTable_name() {
      return this.table_name;
    }

    public offer_cell_args setTable_name(String table_name) {
      this.table_name = table_name;
      return this;
    }

    public void unsetTable_name() {
      this.table_name = null;
    }

    /** Returns true if field table_name is set (has been asigned a value) and false otherwise */
    public boolean isSetTable_name() {
      return this.table_name != null;
    }

    public void setTable_nameIsSet(boolean value) {
      if (!value) {
        this.table_name = null;
      }
    }

    public MutateSpec getMutate_spec() {
      return this.mutate_spec;
    }

    public offer_cell_args setMutate_spec(MutateSpec mutate_spec) {
      this.mutate_spec = mutate_spec;
      return this;
    }

    public void unsetMutate_spec() {
      this.mutate_spec = null;
    }

    /** Returns true if field mutate_spec is set (has been asigned a value) and false otherwise */
    public boolean isSetMutate_spec() {
      return this.mutate_spec != null;
    }

    public void setMutate_specIsSet(boolean value) {
      if (!value) {
        this.mutate_spec = null;
      }
    }

    public Cell getCell() {
      return this.cell;
    }

    public offer_cell_args setCell(Cell cell) {
      this.cell = cell;
      return this;
    }

    public void unsetCell() {
      this.cell = null;
    }

    /** Returns true if field cell is set (has been asigned a value) and false otherwise */
    public boolean isSetCell() {
      return this.cell != null;
    }

    public void setCellIsSet(boolean value) {
      if (!value) {
        this.cell = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case NS:
        if (value == null) {
          unsetNs();
        } else {
          setNs((Long)value);
        }
        break;

      case TABLE_NAME:
        if (value == null) {
          unsetTable_name();
        } else {
          setTable_name((String)value);
        }
        break;

      case MUTATE_SPEC:
        if (value == null) {
          unsetMutate_spec();
        } else {
          setMutate_spec((MutateSpec)value);
        }
        break;

      case CELL:
        if (value == null) {
          unsetCell();
        } else {
          setCell((Cell)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case NS:
        return new Long(getNs());

      case TABLE_NAME:
        return getTable_name();

      case MUTATE_SPEC:
        return getMutate_spec();

      case CELL:
        return getCell();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case NS:
        return isSetNs();
      case TABLE_NAME:
        return isSetTable_name();
      case MUTATE_SPEC:
        return isSetMutate_spec();
      case CELL:
        return isSetCell();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof offer_cell_args)
        return this.equals((offer_cell_args)that);
      return false;
    }

    public boolean equals(offer_cell_args that) {
      if (that == null)
        return false;

      boolean this_present_ns = true;
      boolean that_present_ns = true;
      if (this_present_ns || that_present_ns) {
        if (!(this_present_ns && that_present_ns))
          return false;
        if (this.ns != that.ns)
          return false;
      }

      boolean this_present_table_name = true && this.isSetTable_name();
      boolean that_present_table_name = true && that.isSetTable_name();
      if (this_present_table_name || that_present_table_name) {
        if (!(this_present_table_name && that_present_table_name))
          return false;
        if (!this.table_name.equals(that.table_name))
          return false;
      }

      boolean this_present_mutate_spec = true && this.isSetMutate_spec();
      boolean that_present_mutate_spec = true && that.isSetMutate_spec();
      if (this_present_mutate_spec || that_present_mutate_spec) {
        if (!(this_present_mutate_spec && that_present_mutate_spec))
          return false;
        if (!this.mutate_spec.equals(that.mutate_spec))
          return false;
      }

      boolean this_present_cell = true && this.isSetCell();
      boolean that_present_cell = true && that.isSetCell();
      if (this_present_cell || that_present_cell) {
        if (!(this_present_cell && that_present_cell))
          return false;
        if (!this.cell.equals(that.cell))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(offer_cell_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      offer_cell_args typedOther = (offer_cell_args)other;

      lastComparison = Boolean.valueOf(isSetNs()).compareTo(typedOther.isSetNs());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetNs()) {
        lastComparison = TBaseHelper.compareTo(this.ns, typedOther.ns);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetTable_name()).compareTo(typedOther.isSetTable_name());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTable_name()) {
        lastComparison = TBaseHelper.compareTo(this.table_name, typedOther.table_name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetMutate_spec()).compareTo(typedOther.isSetMutate_spec());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetMutate_spec()) {
        lastComparison = TBaseHelper.compareTo(this.mutate_spec, typedOther.mutate_spec);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetCell()).compareTo(typedOther.isSetCell());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetCell()) {
        lastComparison = TBaseHelper.compareTo(this.cell, typedOther.cell);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // NS
            if (field.type == TType.I64) {
              this.ns = iprot.readI64();
              setNsIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // TABLE_NAME
            if (field.type == TType.STRING) {
              this.table_name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // MUTATE_SPEC
            if (field.type == TType.STRUCT) {
              this.mutate_spec = new MutateSpec();
              this.mutate_spec.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 4: // CELL
            if (field.type == TType.STRUCT) {
              this.cell = new Cell();
              this.cell.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(NS_FIELD_DESC);
      oprot.writeI64(this.ns);
      oprot.writeFieldEnd();
      if (this.table_name != null) {
        oprot.writeFieldBegin(TABLE_NAME_FIELD_DESC);
        oprot.writeString(this.table_name);
        oprot.writeFieldEnd();
      }
      if (this.mutate_spec != null) {
        oprot.writeFieldBegin(MUTATE_SPEC_FIELD_DESC);
        this.mutate_spec.write(oprot);
        oprot.writeFieldEnd();
      }
      if (this.cell != null) {
        oprot.writeFieldBegin(CELL_FIELD_DESC);
        this.cell.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("offer_cell_args(");
      boolean first = true;

      sb.append("ns:");
      sb.append(this.ns);
      first = false;
      if (!first) sb.append(", ");
      sb.append("table_name:");
      if (this.table_name == null) {
        sb.append("null");
      } else {
        sb.append(this.table_name);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("mutate_spec:");
      if (this.mutate_spec == null) {
        sb.append("null");
      } else {
        sb.append(this.mutate_spec);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("cell:");
      if (this.cell == null) {
        sb.append("null");
      } else {
        sb.append(this.cell);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class offer_cell_result implements TBase<offer_cell_result, offer_cell_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("offer_cell_result");

    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public ClientException e;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      E((short)1, "e");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // E
            return E;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(offer_cell_result.class, metaDataMap);
    }

    public offer_cell_result() {
    }

    public offer_cell_result(
      ClientException e)
    {
      this();
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public offer_cell_result(offer_cell_result other) {
      if (other.isSetE()) {
        this.e = new ClientException(other.e);
      }
    }

    public offer_cell_result deepCopy() {
      return new offer_cell_result(this);
    }

    @Override
    public void clear() {
      this.e = null;
    }

    public ClientException getE() {
      return this.e;
    }

    public offer_cell_result setE(ClientException e) {
      this.e = e;
      return this;
    }

    public void unsetE() {
      this.e = null;
    }

    /** Returns true if field e is set (has been asigned a value) and false otherwise */
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((ClientException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case E:
        return getE();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case E:
        return isSetE();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof offer_cell_result)
        return this.equals((offer_cell_result)that);
      return false;
    }

    public boolean equals(offer_cell_result that) {
      if (that == null)
        return false;

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(offer_cell_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      offer_cell_result typedOther = (offer_cell_result)other;

      lastComparison = Boolean.valueOf(isSetE()).compareTo(typedOther.isSetE());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetE()) {
        lastComparison = TBaseHelper.compareTo(this.e, typedOther.e);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // E
            if (field.type == TType.STRUCT) {
              this.e = new ClientException();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetE()) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("offer_cell_result(");
      boolean first = true;

      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class offer_cell_as_array_args implements TBase<offer_cell_as_array_args, offer_cell_as_array_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("offer_cell_as_array_args");

    private static final TField NS_FIELD_DESC = new TField("ns", TType.I64, (short)1);
    private static final TField TABLE_NAME_FIELD_DESC = new TField("table_name", TType.STRING, (short)2);
    private static final TField MUTATE_SPEC_FIELD_DESC = new TField("mutate_spec", TType.STRUCT, (short)3);
    private static final TField CELL_FIELD_DESC = new TField("cell", TType.LIST, (short)4);

    public long ns;
    public String table_name;
    public MutateSpec mutate_spec;
    public List<String> cell;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      NS((short)1, "ns"),
      TABLE_NAME((short)2, "table_name"),
      MUTATE_SPEC((short)3, "mutate_spec"),
      CELL((short)4, "cell");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // NS
            return NS;
          case 2: // TABLE_NAME
            return TABLE_NAME;
          case 3: // MUTATE_SPEC
            return MUTATE_SPEC;
          case 4: // CELL
            return CELL;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __NS_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.NS, new FieldMetaData("ns", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64          , "Namespace")));
      tmpMap.put(_Fields.TABLE_NAME, new FieldMetaData("table_name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.MUTATE_SPEC, new FieldMetaData("mutate_spec", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, MutateSpec.class)));
      tmpMap.put(_Fields.CELL, new FieldMetaData("cell", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.LIST          , "CellAsArray")));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(offer_cell_as_array_args.class, metaDataMap);
    }

    public offer_cell_as_array_args() {
    }

    public offer_cell_as_array_args(
      long ns,
      String table_name,
      MutateSpec mutate_spec,
      List<String> cell)
    {
      this();
      this.ns = ns;
      setNsIsSet(true);
      this.table_name = table_name;
      this.mutate_spec = mutate_spec;
      this.cell = cell;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public offer_cell_as_array_args(offer_cell_as_array_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.ns = other.ns;
      if (other.isSetTable_name()) {
        this.table_name = other.table_name;
      }
      if (other.isSetMutate_spec()) {
        this.mutate_spec = new MutateSpec(other.mutate_spec);
      }
      if (other.isSetCell()) {
        this.cell = other.cell;
      }
    }

    public offer_cell_as_array_args deepCopy() {
      return new offer_cell_as_array_args(this);
    }

    @Override
    public void clear() {
      setNsIsSet(false);
      this.ns = 0;
      this.table_name = null;
      this.mutate_spec = null;
      this.cell = null;
    }

    public long getNs() {
      return this.ns;
    }

    public offer_cell_as_array_args setNs(long ns) {
      this.ns = ns;
      setNsIsSet(true);
      return this;
    }

    public void unsetNs() {
      __isset_bit_vector.clear(__NS_ISSET_ID);
    }

    /** Returns true if field ns is set (has been asigned a value) and false otherwise */
    public boolean isSetNs() {
      return __isset_bit_vector.get(__NS_ISSET_ID);
    }

    public void setNsIsSet(boolean value) {
      __isset_bit_vector.set(__NS_ISSET_ID, value);
    }

    public String getTable_name() {
      return this.table_name;
    }

    public offer_cell_as_array_args setTable_name(String table_name) {
      this.table_name = table_name;
      return this;
    }

    public void unsetTable_name() {
      this.table_name = null;
    }

    /** Returns true if field table_name is set (has been asigned a value) and false otherwise */
    public boolean isSetTable_name() {
      return this.table_name != null;
    }

    public void setTable_nameIsSet(boolean value) {
      if (!value) {
        this.table_name = null;
      }
    }

    public MutateSpec getMutate_spec() {
      return this.mutate_spec;
    }

    public offer_cell_as_array_args setMutate_spec(MutateSpec mutate_spec) {
      this.mutate_spec = mutate_spec;
      return this;
    }

    public void unsetMutate_spec() {
      this.mutate_spec = null;
    }

    /** Returns true if field mutate_spec is set (has been asigned a value) and false otherwise */
    public boolean isSetMutate_spec() {
      return this.mutate_spec != null;
    }

    public void setMutate_specIsSet(boolean value) {
      if (!value) {
        this.mutate_spec = null;
      }
    }

    public int getCellSize() {
      return (this.cell == null) ? 0 : this.cell.size();
    }

    public java.util.Iterator<String> getCellIterator() {
      return (this.cell == null) ? null : this.cell.iterator();
    }

    public void addToCell(String elem) {
      if (this.cell == null) {
        this.cell = new ArrayList<String>();
      }
      this.cell.add(elem);
    }

    public List<String> getCell() {
      return this.cell;
    }

    public offer_cell_as_array_args setCell(List<String> cell) {
      this.cell = cell;
      return this;
    }

    public void unsetCell() {
      this.cell = null;
    }

    /** Returns true if field cell is set (has been asigned a value) and false otherwise */
    public boolean isSetCell() {
      return this.cell != null;
    }

    public void setCellIsSet(boolean value) {
      if (!value) {
        this.cell = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case NS:
        if (value == null) {
          unsetNs();
        } else {
          setNs((Long)value);
        }
        break;

      case TABLE_NAME:
        if (value == null) {
          unsetTable_name();
        } else {
          setTable_name((String)value);
        }
        break;

      case MUTATE_SPEC:
        if (value == null) {
          unsetMutate_spec();
        } else {
          setMutate_spec((MutateSpec)value);
        }
        break;

      case CELL:
        if (value == null) {
          unsetCell();
        } else {
          setCell((List<String>)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case NS:
        return new Long(getNs());

      case TABLE_NAME:
        return getTable_name();

      case MUTATE_SPEC:
        return getMutate_spec();

      case CELL:
        return getCell();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case NS:
        return isSetNs();
      case TABLE_NAME:
        return isSetTable_name();
      case MUTATE_SPEC:
        return isSetMutate_spec();
      case CELL:
        return isSetCell();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof offer_cell_as_array_args)
        return this.equals((offer_cell_as_array_args)that);
      return false;
    }

    public boolean equals(offer_cell_as_array_args that) {
      if (that == null)
        return false;

      boolean this_present_ns = true;
      boolean that_present_ns = true;
      if (this_present_ns || that_present_ns) {
        if (!(this_present_ns && that_present_ns))
          return false;
        if (this.ns != that.ns)
          return false;
      }

      boolean this_present_table_name = true && this.isSetTable_name();
      boolean that_present_table_name = true && that.isSetTable_name();
      if (this_present_table_name || that_present_table_name) {
        if (!(this_present_table_name && that_present_table_name))
          return false;
        if (!this.table_name.equals(that.table_name))
          return false;
      }

      boolean this_present_mutate_spec = true && this.isSetMutate_spec();
      boolean that_present_mutate_spec = true && that.isSetMutate_spec();
      if (this_present_mutate_spec || that_present_mutate_spec) {
        if (!(this_present_mutate_spec && that_present_mutate_spec))
          return false;
        if (!this.mutate_spec.equals(that.mutate_spec))
          return false;
      }

      boolean this_present_cell = true && this.isSetCell();
      boolean that_present_cell = true && that.isSetCell();
      if (this_present_cell || that_present_cell) {
        if (!(this_present_cell && that_present_cell))
          return false;
        if (!this.cell.equals(that.cell))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(offer_cell_as_array_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      offer_cell_as_array_args typedOther = (offer_cell_as_array_args)other;

      lastComparison = Boolean.valueOf(isSetNs()).compareTo(typedOther.isSetNs());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetNs()) {
        lastComparison = TBaseHelper.compareTo(this.ns, typedOther.ns);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetTable_name()).compareTo(typedOther.isSetTable_name());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTable_name()) {
        lastComparison = TBaseHelper.compareTo(this.table_name, typedOther.table_name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetMutate_spec()).compareTo(typedOther.isSetMutate_spec());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetMutate_spec()) {
        lastComparison = TBaseHelper.compareTo(this.mutate_spec, typedOther.mutate_spec);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetCell()).compareTo(typedOther.isSetCell());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetCell()) {
        lastComparison = TBaseHelper.compareTo(this.cell, typedOther.cell);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // NS
            if (field.type == TType.I64) {
              this.ns = iprot.readI64();
              setNsIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // TABLE_NAME
            if (field.type == TType.STRING) {
              this.table_name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // MUTATE_SPEC
            if (field.type == TType.STRUCT) {
              this.mutate_spec = new MutateSpec();
              this.mutate_spec.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 4: // CELL
            if (field.type == TType.LIST) {
              {
                TList _list98 = iprot.readListBegin();
                this.cell = new ArrayList<String>(_list98.size);
                for (int _i99 = 0; _i99 < _list98.size; ++_i99)
                {
                  String _elem100;
                  _elem100 = iprot.readString();
                  this.cell.add(_elem100);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(NS_FIELD_DESC);
      oprot.writeI64(this.ns);
      oprot.writeFieldEnd();
      if (this.table_name != null) {
        oprot.writeFieldBegin(TABLE_NAME_FIELD_DESC);
        oprot.writeString(this.table_name);
        oprot.writeFieldEnd();
      }
      if (this.mutate_spec != null) {
        oprot.writeFieldBegin(MUTATE_SPEC_FIELD_DESC);
        this.mutate_spec.write(oprot);
        oprot.writeFieldEnd();
      }
      if (this.cell != null) {
        oprot.writeFieldBegin(CELL_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRING, this.cell.size()));
          for (String _iter101 : this.cell)
          {
            oprot.writeString(_iter101);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("offer_cell_as_array_args(");
      boolean first = true;

      sb.append("ns:");
      sb.append(this.ns);
      first = false;
      if (!first) sb.append(", ");
      sb.append("table_name:");
      if (this.table_name == null) {
        sb.append("null");
      } else {
        sb.append(this.table_name);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("mutate_spec:");
      if (this.mutate_spec == null) {
        sb.append("null");
      } else {
        sb.append(this.mutate_spec);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("cell:");
      if (this.cell == null) {
        sb.append("null");
      } else {
        sb.append(this.cell);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class offer_cell_as_array_result implements TBase<offer_cell_as_array_result, offer_cell_as_array_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("offer_cell_as_array_result");

    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public ClientException e;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      E((short)1, "e");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // E
            return E;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(offer_cell_as_array_result.class, metaDataMap);
    }

    public offer_cell_as_array_result() {
    }

    public offer_cell_as_array_result(
      ClientException e)
    {
      this();
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public offer_cell_as_array_result(offer_cell_as_array_result other) {
      if (other.isSetE()) {
        this.e = new ClientException(other.e);
      }
    }

    public offer_cell_as_array_result deepCopy() {
      return new offer_cell_as_array_result(this);
    }

    @Override
    public void clear() {
      this.e = null;
    }

    public ClientException getE() {
      return this.e;
    }

    public offer_cell_as_array_result setE(ClientException e) {
      this.e = e;
      return this;
    }

    public void unsetE() {
      this.e = null;
    }

    /** Returns true if field e is set (has been asigned a value) and false otherwise */
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((ClientException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case E:
        return getE();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case E:
        return isSetE();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof offer_cell_as_array_result)
        return this.equals((offer_cell_as_array_result)that);
      return false;
    }

    public boolean equals(offer_cell_as_array_result that) {
      if (that == null)
        return false;

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(offer_cell_as_array_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      offer_cell_as_array_result typedOther = (offer_cell_as_array_result)other;

      lastComparison = Boolean.valueOf(isSetE()).compareTo(typedOther.isSetE());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetE()) {
        lastComparison = TBaseHelper.compareTo(this.e, typedOther.e);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // E
            if (field.type == TType.STRUCT) {
              this.e = new ClientException();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetE()) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("offer_cell_as_array_result(");
      boolean first = true;

      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class open_mutator_args implements TBase<open_mutator_args, open_mutator_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("open_mutator_args");

    private static final TField NS_FIELD_DESC = new TField("ns", TType.I64, (short)1);
    private static final TField TABLE_NAME_FIELD_DESC = new TField("table_name", TType.STRING, (short)2);
    private static final TField FLAGS_FIELD_DESC = new TField("flags", TType.I32, (short)3);
    private static final TField FLUSH_INTERVAL_FIELD_DESC = new TField("flush_interval", TType.I32, (short)4);

    public long ns;
    public String table_name;
    public int flags;
    public int flush_interval;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      NS((short)1, "ns"),
      TABLE_NAME((short)2, "table_name"),
      FLAGS((short)3, "flags"),
      FLUSH_INTERVAL((short)4, "flush_interval");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // NS
            return NS;
          case 2: // TABLE_NAME
            return TABLE_NAME;
          case 3: // FLAGS
            return FLAGS;
          case 4: // FLUSH_INTERVAL
            return FLUSH_INTERVAL;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __NS_ISSET_ID = 0;
    private static final int __FLAGS_ISSET_ID = 1;
    private static final int __FLUSH_INTERVAL_ISSET_ID = 2;
    private BitSet __isset_bit_vector = new BitSet(3);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.NS, new FieldMetaData("ns", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64          , "Namespace")));
      tmpMap.put(_Fields.TABLE_NAME, new FieldMetaData("table_name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.FLAGS, new FieldMetaData("flags", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I32)));
      tmpMap.put(_Fields.FLUSH_INTERVAL, new FieldMetaData("flush_interval", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I32)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(open_mutator_args.class, metaDataMap);
    }

    public open_mutator_args() {
      this.flags = 0;

      this.flush_interval = 0;

    }

    public open_mutator_args(
      long ns,
      String table_name,
      int flags,
      int flush_interval)
    {
      this();
      this.ns = ns;
      setNsIsSet(true);
      this.table_name = table_name;
      this.flags = flags;
      setFlagsIsSet(true);
      this.flush_interval = flush_interval;
      setFlush_intervalIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public open_mutator_args(open_mutator_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.ns = other.ns;
      if (other.isSetTable_name()) {
        this.table_name = other.table_name;
      }
      this.flags = other.flags;
      this.flush_interval = other.flush_interval;
    }

    public open_mutator_args deepCopy() {
      return new open_mutator_args(this);
    }

    @Override
    public void clear() {
      setNsIsSet(false);
      this.ns = 0;
      this.table_name = null;
      this.flags = 0;

      this.flush_interval = 0;

    }

    public long getNs() {
      return this.ns;
    }

    public open_mutator_args setNs(long ns) {
      this.ns = ns;
      setNsIsSet(true);
      return this;
    }

    public void unsetNs() {
      __isset_bit_vector.clear(__NS_ISSET_ID);
    }

    /** Returns true if field ns is set (has been asigned a value) and false otherwise */
    public boolean isSetNs() {
      return __isset_bit_vector.get(__NS_ISSET_ID);
    }

    public void setNsIsSet(boolean value) {
      __isset_bit_vector.set(__NS_ISSET_ID, value);
    }

    public String getTable_name() {
      return this.table_name;
    }

    public open_mutator_args setTable_name(String table_name) {
      this.table_name = table_name;
      return this;
    }

    public void unsetTable_name() {
      this.table_name = null;
    }

    /** Returns true if field table_name is set (has been asigned a value) and false otherwise */
    public boolean isSetTable_name() {
      return this.table_name != null;
    }

    public void setTable_nameIsSet(boolean value) {
      if (!value) {
        this.table_name = null;
      }
    }

    public int getFlags() {
      return this.flags;
    }

    public open_mutator_args setFlags(int flags) {
      this.flags = flags;
      setFlagsIsSet(true);
      return this;
    }

    public void unsetFlags() {
      __isset_bit_vector.clear(__FLAGS_ISSET_ID);
    }

    /** Returns true if field flags is set (has been asigned a value) and false otherwise */
    public boolean isSetFlags() {
      return __isset_bit_vector.get(__FLAGS_ISSET_ID);
    }

    public void setFlagsIsSet(boolean value) {
      __isset_bit_vector.set(__FLAGS_ISSET_ID, value);
    }

    public int getFlush_interval() {
      return this.flush_interval;
    }

    public open_mutator_args setFlush_interval(int flush_interval) {
      this.flush_interval = flush_interval;
      setFlush_intervalIsSet(true);
      return this;
    }

    public void unsetFlush_interval() {
      __isset_bit_vector.clear(__FLUSH_INTERVAL_ISSET_ID);
    }

    /** Returns true if field flush_interval is set (has been asigned a value) and false otherwise */
    public boolean isSetFlush_interval() {
      return __isset_bit_vector.get(__FLUSH_INTERVAL_ISSET_ID);
    }

    public void setFlush_intervalIsSet(boolean value) {
      __isset_bit_vector.set(__FLUSH_INTERVAL_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case NS:
        if (value == null) {
          unsetNs();
        } else {
          setNs((Long)value);
        }
        break;

      case TABLE_NAME:
        if (value == null) {
          unsetTable_name();
        } else {
          setTable_name((String)value);
        }
        break;

      case FLAGS:
        if (value == null) {
          unsetFlags();
        } else {
          setFlags((Integer)value);
        }
        break;

      case FLUSH_INTERVAL:
        if (value == null) {
          unsetFlush_interval();
        } else {
          setFlush_interval((Integer)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case NS:
        return new Long(getNs());

      case TABLE_NAME:
        return getTable_name();

      case FLAGS:
        return new Integer(getFlags());

      case FLUSH_INTERVAL:
        return new Integer(getFlush_interval());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case NS:
        return isSetNs();
      case TABLE_NAME:
        return isSetTable_name();
      case FLAGS:
        return isSetFlags();
      case FLUSH_INTERVAL:
        return isSetFlush_interval();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof open_mutator_args)
        return this.equals((open_mutator_args)that);
      return false;
    }

    public boolean equals(open_mutator_args that) {
      if (that == null)
        return false;

      boolean this_present_ns = true;
      boolean that_present_ns = true;
      if (this_present_ns || that_present_ns) {
        if (!(this_present_ns && that_present_ns))
          return false;
        if (this.ns != that.ns)
          return false;
      }

      boolean this_present_table_name = true && this.isSetTable_name();
      boolean that_present_table_name = true && that.isSetTable_name();
      if (this_present_table_name || that_present_table_name) {
        if (!(this_present_table_name && that_present_table_name))
          return false;
        if (!this.table_name.equals(that.table_name))
          return false;
      }

      boolean this_present_flags = true;
      boolean that_present_flags = true;
      if (this_present_flags || that_present_flags) {
        if (!(this_present_flags && that_present_flags))
          return false;
        if (this.flags != that.flags)
          return false;
      }

      boolean this_present_flush_interval = true;
      boolean that_present_flush_interval = true;
      if (this_present_flush_interval || that_present_flush_interval) {
        if (!(this_present_flush_interval && that_present_flush_interval))
          return false;
        if (this.flush_interval != that.flush_interval)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(open_mutator_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      open_mutator_args typedOther = (open_mutator_args)other;

      lastComparison = Boolean.valueOf(isSetNs()).compareTo(typedOther.isSetNs());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetNs()) {
        lastComparison = TBaseHelper.compareTo(this.ns, typedOther.ns);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetTable_name()).compareTo(typedOther.isSetTable_name());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTable_name()) {
        lastComparison = TBaseHelper.compareTo(this.table_name, typedOther.table_name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetFlags()).compareTo(typedOther.isSetFlags());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetFlags()) {
        lastComparison = TBaseHelper.compareTo(this.flags, typedOther.flags);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetFlush_interval()).compareTo(typedOther.isSetFlush_interval());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetFlush_interval()) {
        lastComparison = TBaseHelper.compareTo(this.flush_interval, typedOther.flush_interval);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // NS
            if (field.type == TType.I64) {
              this.ns = iprot.readI64();
              setNsIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // TABLE_NAME
            if (field.type == TType.STRING) {
              this.table_name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // FLAGS
            if (field.type == TType.I32) {
              this.flags = iprot.readI32();
              setFlagsIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 4: // FLUSH_INTERVAL
            if (field.type == TType.I32) {
              this.flush_interval = iprot.readI32();
              setFlush_intervalIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(NS_FIELD_DESC);
      oprot.writeI64(this.ns);
      oprot.writeFieldEnd();
      if (this.table_name != null) {
        oprot.writeFieldBegin(TABLE_NAME_FIELD_DESC);
        oprot.writeString(this.table_name);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(FLAGS_FIELD_DESC);
      oprot.writeI32(this.flags);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(FLUSH_INTERVAL_FIELD_DESC);
      oprot.writeI32(this.flush_interval);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("open_mutator_args(");
      boolean first = true;

      sb.append("ns:");
      sb.append(this.ns);
      first = false;
      if (!first) sb.append(", ");
      sb.append("table_name:");
      if (this.table_name == null) {
        sb.append("null");
      } else {
        sb.append(this.table_name);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("flags:");
      sb.append(this.flags);
      first = false;
      if (!first) sb.append(", ");
      sb.append("flush_interval:");
      sb.append(this.flush_interval);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class open_mutator_result implements TBase<open_mutator_result, open_mutator_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("open_mutator_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.I64, (short)0);
    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public long success;
    public ClientException e;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      E((short)1, "e");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // E
            return E;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __SUCCESS_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64          , "Mutator")));
      tmpMap.put(_Fields.E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(open_mutator_result.class, metaDataMap);
    }

    public open_mutator_result() {
    }

    public open_mutator_result(
      long success,
      ClientException e)
    {
      this();
      this.success = success;
      setSuccessIsSet(true);
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public open_mutator_result(open_mutator_result other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.success = other.success;
      if (other.isSetE()) {
        this.e = new ClientException(other.e);
      }
    }

    public open_mutator_result deepCopy() {
      return new open_mutator_result(this);
    }

    @Override
    public void clear() {
      setSuccessIsSet(false);
      this.success = 0;
      this.e = null;
    }

    public long getSuccess() {
      return this.success;
    }

    public open_mutator_result setSuccess(long success) {
      this.success = success;
      setSuccessIsSet(true);
      return this;
    }

    public void unsetSuccess() {
      __isset_bit_vector.clear(__SUCCESS_ISSET_ID);
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return __isset_bit_vector.get(__SUCCESS_ISSET_ID);
    }

    public void setSuccessIsSet(boolean value) {
      __isset_bit_vector.set(__SUCCESS_ISSET_ID, value);
    }

    public ClientException getE() {
      return this.e;
    }

    public open_mutator_result setE(ClientException e) {
      this.e = e;
      return this;
    }

    public void unsetE() {
      this.e = null;
    }

    /** Returns true if field e is set (has been asigned a value) and false otherwise */
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Long)value);
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((ClientException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return new Long(getSuccess());

      case E:
        return getE();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof open_mutator_result)
        return this.equals((open_mutator_result)that);
      return false;
    }

    public boolean equals(open_mutator_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(open_mutator_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      open_mutator_result typedOther = (open_mutator_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetE()).compareTo(typedOther.isSetE());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetE()) {
        lastComparison = TBaseHelper.compareTo(this.e, typedOther.e);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.I64) {
              this.success = iprot.readI64();
              setSuccessIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // E
            if (field.type == TType.STRUCT) {
              this.e = new ClientException();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeI64(this.success);
        oprot.writeFieldEnd();
      } else if (this.isSetE()) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("open_mutator_result(");
      boolean first = true;

      sb.append("success:");
      sb.append(this.success);
      first = false;
      if (!first) sb.append(", ");
      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class close_mutator_args implements TBase<close_mutator_args, close_mutator_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("close_mutator_args");

    private static final TField MUTATOR_FIELD_DESC = new TField("mutator", TType.I64, (short)1);
    private static final TField FLUSH_FIELD_DESC = new TField("flush", TType.BOOL, (short)2);

    public long mutator;
    public boolean flush;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      MUTATOR((short)1, "mutator"),
      FLUSH((short)2, "flush");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // MUTATOR
            return MUTATOR;
          case 2: // FLUSH
            return FLUSH;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __MUTATOR_ISSET_ID = 0;
    private static final int __FLUSH_ISSET_ID = 1;
    private BitSet __isset_bit_vector = new BitSet(2);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.MUTATOR, new FieldMetaData("mutator", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64          , "Mutator")));
      tmpMap.put(_Fields.FLUSH, new FieldMetaData("flush", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.BOOL)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(close_mutator_args.class, metaDataMap);
    }

    public close_mutator_args() {
      this.flush = true;

    }

    public close_mutator_args(
      long mutator,
      boolean flush)
    {
      this();
      this.mutator = mutator;
      setMutatorIsSet(true);
      this.flush = flush;
      setFlushIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public close_mutator_args(close_mutator_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.mutator = other.mutator;
      this.flush = other.flush;
    }

    public close_mutator_args deepCopy() {
      return new close_mutator_args(this);
    }

    @Override
    public void clear() {
      setMutatorIsSet(false);
      this.mutator = 0;
      this.flush = true;

    }

    public long getMutator() {
      return this.mutator;
    }

    public close_mutator_args setMutator(long mutator) {
      this.mutator = mutator;
      setMutatorIsSet(true);
      return this;
    }

    public void unsetMutator() {
      __isset_bit_vector.clear(__MUTATOR_ISSET_ID);
    }

    /** Returns true if field mutator is set (has been asigned a value) and false otherwise */
    public boolean isSetMutator() {
      return __isset_bit_vector.get(__MUTATOR_ISSET_ID);
    }

    public void setMutatorIsSet(boolean value) {
      __isset_bit_vector.set(__MUTATOR_ISSET_ID, value);
    }

    public boolean isFlush() {
      return this.flush;
    }

    public close_mutator_args setFlush(boolean flush) {
      this.flush = flush;
      setFlushIsSet(true);
      return this;
    }

    public void unsetFlush() {
      __isset_bit_vector.clear(__FLUSH_ISSET_ID);
    }

    /** Returns true if field flush is set (has been asigned a value) and false otherwise */
    public boolean isSetFlush() {
      return __isset_bit_vector.get(__FLUSH_ISSET_ID);
    }

    public void setFlushIsSet(boolean value) {
      __isset_bit_vector.set(__FLUSH_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case MUTATOR:
        if (value == null) {
          unsetMutator();
        } else {
          setMutator((Long)value);
        }
        break;

      case FLUSH:
        if (value == null) {
          unsetFlush();
        } else {
          setFlush((Boolean)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case MUTATOR:
        return new Long(getMutator());

      case FLUSH:
        return new Boolean(isFlush());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case MUTATOR:
        return isSetMutator();
      case FLUSH:
        return isSetFlush();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof close_mutator_args)
        return this.equals((close_mutator_args)that);
      return false;
    }

    public boolean equals(close_mutator_args that) {
      if (that == null)
        return false;

      boolean this_present_mutator = true;
      boolean that_present_mutator = true;
      if (this_present_mutator || that_present_mutator) {
        if (!(this_present_mutator && that_present_mutator))
          return false;
        if (this.mutator != that.mutator)
          return false;
      }

      boolean this_present_flush = true;
      boolean that_present_flush = true;
      if (this_present_flush || that_present_flush) {
        if (!(this_present_flush && that_present_flush))
          return false;
        if (this.flush != that.flush)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(close_mutator_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      close_mutator_args typedOther = (close_mutator_args)other;

      lastComparison = Boolean.valueOf(isSetMutator()).compareTo(typedOther.isSetMutator());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetMutator()) {
        lastComparison = TBaseHelper.compareTo(this.mutator, typedOther.mutator);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetFlush()).compareTo(typedOther.isSetFlush());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetFlush()) {
        lastComparison = TBaseHelper.compareTo(this.flush, typedOther.flush);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // MUTATOR
            if (field.type == TType.I64) {
              this.mutator = iprot.readI64();
              setMutatorIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // FLUSH
            if (field.type == TType.BOOL) {
              this.flush = iprot.readBool();
              setFlushIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(MUTATOR_FIELD_DESC);
      oprot.writeI64(this.mutator);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(FLUSH_FIELD_DESC);
      oprot.writeBool(this.flush);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("close_mutator_args(");
      boolean first = true;

      sb.append("mutator:");
      sb.append(this.mutator);
      first = false;
      if (!first) sb.append(", ");
      sb.append("flush:");
      sb.append(this.flush);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class close_mutator_result implements TBase<close_mutator_result, close_mutator_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("close_mutator_result");

    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public ClientException e;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      E((short)1, "e");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // E
            return E;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(close_mutator_result.class, metaDataMap);
    }

    public close_mutator_result() {
    }

    public close_mutator_result(
      ClientException e)
    {
      this();
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public close_mutator_result(close_mutator_result other) {
      if (other.isSetE()) {
        this.e = new ClientException(other.e);
      }
    }

    public close_mutator_result deepCopy() {
      return new close_mutator_result(this);
    }

    @Override
    public void clear() {
      this.e = null;
    }

    public ClientException getE() {
      return this.e;
    }

    public close_mutator_result setE(ClientException e) {
      this.e = e;
      return this;
    }

    public void unsetE() {
      this.e = null;
    }

    /** Returns true if field e is set (has been asigned a value) and false otherwise */
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((ClientException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case E:
        return getE();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case E:
        return isSetE();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof close_mutator_result)
        return this.equals((close_mutator_result)that);
      return false;
    }

    public boolean equals(close_mutator_result that) {
      if (that == null)
        return false;

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(close_mutator_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      close_mutator_result typedOther = (close_mutator_result)other;

      lastComparison = Boolean.valueOf(isSetE()).compareTo(typedOther.isSetE());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetE()) {
        lastComparison = TBaseHelper.compareTo(this.e, typedOther.e);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // E
            if (field.type == TType.STRUCT) {
              this.e = new ClientException();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetE()) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("close_mutator_result(");
      boolean first = true;

      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class set_cell_args implements TBase<set_cell_args, set_cell_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("set_cell_args");

    private static final TField MUTATOR_FIELD_DESC = new TField("mutator", TType.I64, (short)1);
    private static final TField CELL_FIELD_DESC = new TField("cell", TType.STRUCT, (short)2);

    public long mutator;
    public Cell cell;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      MUTATOR((short)1, "mutator"),
      CELL((short)2, "cell");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // MUTATOR
            return MUTATOR;
          case 2: // CELL
            return CELL;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __MUTATOR_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.MUTATOR, new FieldMetaData("mutator", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64          , "Mutator")));
      tmpMap.put(_Fields.CELL, new FieldMetaData("cell", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, Cell.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(set_cell_args.class, metaDataMap);
    }

    public set_cell_args() {
    }

    public set_cell_args(
      long mutator,
      Cell cell)
    {
      this();
      this.mutator = mutator;
      setMutatorIsSet(true);
      this.cell = cell;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public set_cell_args(set_cell_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.mutator = other.mutator;
      if (other.isSetCell()) {
        this.cell = new Cell(other.cell);
      }
    }

    public set_cell_args deepCopy() {
      return new set_cell_args(this);
    }

    @Override
    public void clear() {
      setMutatorIsSet(false);
      this.mutator = 0;
      this.cell = null;
    }

    public long getMutator() {
      return this.mutator;
    }

    public set_cell_args setMutator(long mutator) {
      this.mutator = mutator;
      setMutatorIsSet(true);
      return this;
    }

    public void unsetMutator() {
      __isset_bit_vector.clear(__MUTATOR_ISSET_ID);
    }

    /** Returns true if field mutator is set (has been asigned a value) and false otherwise */
    public boolean isSetMutator() {
      return __isset_bit_vector.get(__MUTATOR_ISSET_ID);
    }

    public void setMutatorIsSet(boolean value) {
      __isset_bit_vector.set(__MUTATOR_ISSET_ID, value);
    }

    public Cell getCell() {
      return this.cell;
    }

    public set_cell_args setCell(Cell cell) {
      this.cell = cell;
      return this;
    }

    public void unsetCell() {
      this.cell = null;
    }

    /** Returns true if field cell is set (has been asigned a value) and false otherwise */
    public boolean isSetCell() {
      return this.cell != null;
    }

    public void setCellIsSet(boolean value) {
      if (!value) {
        this.cell = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case MUTATOR:
        if (value == null) {
          unsetMutator();
        } else {
          setMutator((Long)value);
        }
        break;

      case CELL:
        if (value == null) {
          unsetCell();
        } else {
          setCell((Cell)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case MUTATOR:
        return new Long(getMutator());

      case CELL:
        return getCell();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case MUTATOR:
        return isSetMutator();
      case CELL:
        return isSetCell();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof set_cell_args)
        return this.equals((set_cell_args)that);
      return false;
    }

    public boolean equals(set_cell_args that) {
      if (that == null)
        return false;

      boolean this_present_mutator = true;
      boolean that_present_mutator = true;
      if (this_present_mutator || that_present_mutator) {
        if (!(this_present_mutator && that_present_mutator))
          return false;
        if (this.mutator != that.mutator)
          return false;
      }

      boolean this_present_cell = true && this.isSetCell();
      boolean that_present_cell = true && that.isSetCell();
      if (this_present_cell || that_present_cell) {
        if (!(this_present_cell && that_present_cell))
          return false;
        if (!this.cell.equals(that.cell))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(set_cell_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      set_cell_args typedOther = (set_cell_args)other;

      lastComparison = Boolean.valueOf(isSetMutator()).compareTo(typedOther.isSetMutator());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetMutator()) {
        lastComparison = TBaseHelper.compareTo(this.mutator, typedOther.mutator);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetCell()).compareTo(typedOther.isSetCell());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetCell()) {
        lastComparison = TBaseHelper.compareTo(this.cell, typedOther.cell);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // MUTATOR
            if (field.type == TType.I64) {
              this.mutator = iprot.readI64();
              setMutatorIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // CELL
            if (field.type == TType.STRUCT) {
              this.cell = new Cell();
              this.cell.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(MUTATOR_FIELD_DESC);
      oprot.writeI64(this.mutator);
      oprot.writeFieldEnd();
      if (this.cell != null) {
        oprot.writeFieldBegin(CELL_FIELD_DESC);
        this.cell.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("set_cell_args(");
      boolean first = true;

      sb.append("mutator:");
      sb.append(this.mutator);
      first = false;
      if (!first) sb.append(", ");
      sb.append("cell:");
      if (this.cell == null) {
        sb.append("null");
      } else {
        sb.append(this.cell);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class set_cell_result implements TBase<set_cell_result, set_cell_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("set_cell_result");

    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public ClientException e;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      E((short)1, "e");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // E
            return E;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(set_cell_result.class, metaDataMap);
    }

    public set_cell_result() {
    }

    public set_cell_result(
      ClientException e)
    {
      this();
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public set_cell_result(set_cell_result other) {
      if (other.isSetE()) {
        this.e = new ClientException(other.e);
      }
    }

    public set_cell_result deepCopy() {
      return new set_cell_result(this);
    }

    @Override
    public void clear() {
      this.e = null;
    }

    public ClientException getE() {
      return this.e;
    }

    public set_cell_result setE(ClientException e) {
      this.e = e;
      return this;
    }

    public void unsetE() {
      this.e = null;
    }

    /** Returns true if field e is set (has been asigned a value) and false otherwise */
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((ClientException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case E:
        return getE();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case E:
        return isSetE();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof set_cell_result)
        return this.equals((set_cell_result)that);
      return false;
    }

    public boolean equals(set_cell_result that) {
      if (that == null)
        return false;

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(set_cell_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      set_cell_result typedOther = (set_cell_result)other;

      lastComparison = Boolean.valueOf(isSetE()).compareTo(typedOther.isSetE());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetE()) {
        lastComparison = TBaseHelper.compareTo(this.e, typedOther.e);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // E
            if (field.type == TType.STRUCT) {
              this.e = new ClientException();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetE()) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("set_cell_result(");
      boolean first = true;

      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class set_cell_as_array_args implements TBase<set_cell_as_array_args, set_cell_as_array_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("set_cell_as_array_args");

    private static final TField MUTATOR_FIELD_DESC = new TField("mutator", TType.I64, (short)1);
    private static final TField CELL_FIELD_DESC = new TField("cell", TType.LIST, (short)2);

    public long mutator;
    public List<String> cell;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      MUTATOR((short)1, "mutator"),
      CELL((short)2, "cell");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // MUTATOR
            return MUTATOR;
          case 2: // CELL
            return CELL;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __MUTATOR_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.MUTATOR, new FieldMetaData("mutator", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64          , "Mutator")));
      tmpMap.put(_Fields.CELL, new FieldMetaData("cell", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.LIST          , "CellAsArray")));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(set_cell_as_array_args.class, metaDataMap);
    }

    public set_cell_as_array_args() {
    }

    public set_cell_as_array_args(
      long mutator,
      List<String> cell)
    {
      this();
      this.mutator = mutator;
      setMutatorIsSet(true);
      this.cell = cell;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public set_cell_as_array_args(set_cell_as_array_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.mutator = other.mutator;
      if (other.isSetCell()) {
        this.cell = other.cell;
      }
    }

    public set_cell_as_array_args deepCopy() {
      return new set_cell_as_array_args(this);
    }

    @Override
    public void clear() {
      setMutatorIsSet(false);
      this.mutator = 0;
      this.cell = null;
    }

    public long getMutator() {
      return this.mutator;
    }

    public set_cell_as_array_args setMutator(long mutator) {
      this.mutator = mutator;
      setMutatorIsSet(true);
      return this;
    }

    public void unsetMutator() {
      __isset_bit_vector.clear(__MUTATOR_ISSET_ID);
    }

    /** Returns true if field mutator is set (has been asigned a value) and false otherwise */
    public boolean isSetMutator() {
      return __isset_bit_vector.get(__MUTATOR_ISSET_ID);
    }

    public void setMutatorIsSet(boolean value) {
      __isset_bit_vector.set(__MUTATOR_ISSET_ID, value);
    }

    public int getCellSize() {
      return (this.cell == null) ? 0 : this.cell.size();
    }

    public java.util.Iterator<String> getCellIterator() {
      return (this.cell == null) ? null : this.cell.iterator();
    }

    public void addToCell(String elem) {
      if (this.cell == null) {
        this.cell = new ArrayList<String>();
      }
      this.cell.add(elem);
    }

    public List<String> getCell() {
      return this.cell;
    }

    public set_cell_as_array_args setCell(List<String> cell) {
      this.cell = cell;
      return this;
    }

    public void unsetCell() {
      this.cell = null;
    }

    /** Returns true if field cell is set (has been asigned a value) and false otherwise */
    public boolean isSetCell() {
      return this.cell != null;
    }

    public void setCellIsSet(boolean value) {
      if (!value) {
        this.cell = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case MUTATOR:
        if (value == null) {
          unsetMutator();
        } else {
          setMutator((Long)value);
        }
        break;

      case CELL:
        if (value == null) {
          unsetCell();
        } else {
          setCell((List<String>)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case MUTATOR:
        return new Long(getMutator());

      case CELL:
        return getCell();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case MUTATOR:
        return isSetMutator();
      case CELL:
        return isSetCell();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof set_cell_as_array_args)
        return this.equals((set_cell_as_array_args)that);
      return false;
    }

    public boolean equals(set_cell_as_array_args that) {
      if (that == null)
        return false;

      boolean this_present_mutator = true;
      boolean that_present_mutator = true;
      if (this_present_mutator || that_present_mutator) {
        if (!(this_present_mutator && that_present_mutator))
          return false;
        if (this.mutator != that.mutator)
          return false;
      }

      boolean this_present_cell = true && this.isSetCell();
      boolean that_present_cell = true && that.isSetCell();
      if (this_present_cell || that_present_cell) {
        if (!(this_present_cell && that_present_cell))
          return false;
        if (!this.cell.equals(that.cell))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(set_cell_as_array_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      set_cell_as_array_args typedOther = (set_cell_as_array_args)other;

      lastComparison = Boolean.valueOf(isSetMutator()).compareTo(typedOther.isSetMutator());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetMutator()) {
        lastComparison = TBaseHelper.compareTo(this.mutator, typedOther.mutator);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetCell()).compareTo(typedOther.isSetCell());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetCell()) {
        lastComparison = TBaseHelper.compareTo(this.cell, typedOther.cell);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // MUTATOR
            if (field.type == TType.I64) {
              this.mutator = iprot.readI64();
              setMutatorIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // CELL
            if (field.type == TType.LIST) {
              {
                TList _list102 = iprot.readListBegin();
                this.cell = new ArrayList<String>(_list102.size);
                for (int _i103 = 0; _i103 < _list102.size; ++_i103)
                {
                  String _elem104;
                  _elem104 = iprot.readString();
                  this.cell.add(_elem104);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(MUTATOR_FIELD_DESC);
      oprot.writeI64(this.mutator);
      oprot.writeFieldEnd();
      if (this.cell != null) {
        oprot.writeFieldBegin(CELL_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRING, this.cell.size()));
          for (String _iter105 : this.cell)
          {
            oprot.writeString(_iter105);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("set_cell_as_array_args(");
      boolean first = true;

      sb.append("mutator:");
      sb.append(this.mutator);
      first = false;
      if (!first) sb.append(", ");
      sb.append("cell:");
      if (this.cell == null) {
        sb.append("null");
      } else {
        sb.append(this.cell);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class set_cell_as_array_result implements TBase<set_cell_as_array_result, set_cell_as_array_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("set_cell_as_array_result");

    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public ClientException e;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      E((short)1, "e");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // E
            return E;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(set_cell_as_array_result.class, metaDataMap);
    }

    public set_cell_as_array_result() {
    }

    public set_cell_as_array_result(
      ClientException e)
    {
      this();
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public set_cell_as_array_result(set_cell_as_array_result other) {
      if (other.isSetE()) {
        this.e = new ClientException(other.e);
      }
    }

    public set_cell_as_array_result deepCopy() {
      return new set_cell_as_array_result(this);
    }

    @Override
    public void clear() {
      this.e = null;
    }

    public ClientException getE() {
      return this.e;
    }

    public set_cell_as_array_result setE(ClientException e) {
      this.e = e;
      return this;
    }

    public void unsetE() {
      this.e = null;
    }

    /** Returns true if field e is set (has been asigned a value) and false otherwise */
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((ClientException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case E:
        return getE();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case E:
        return isSetE();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof set_cell_as_array_result)
        return this.equals((set_cell_as_array_result)that);
      return false;
    }

    public boolean equals(set_cell_as_array_result that) {
      if (that == null)
        return false;

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(set_cell_as_array_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      set_cell_as_array_result typedOther = (set_cell_as_array_result)other;

      lastComparison = Boolean.valueOf(isSetE()).compareTo(typedOther.isSetE());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetE()) {
        lastComparison = TBaseHelper.compareTo(this.e, typedOther.e);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // E
            if (field.type == TType.STRUCT) {
              this.e = new ClientException();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetE()) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("set_cell_as_array_result(");
      boolean first = true;

      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class set_cells_args implements TBase<set_cells_args, set_cells_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("set_cells_args");

    private static final TField MUTATOR_FIELD_DESC = new TField("mutator", TType.I64, (short)1);
    private static final TField CELLS_FIELD_DESC = new TField("cells", TType.LIST, (short)2);

    public long mutator;
    public List<Cell> cells;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      MUTATOR((short)1, "mutator"),
      CELLS((short)2, "cells");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // MUTATOR
            return MUTATOR;
          case 2: // CELLS
            return CELLS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __MUTATOR_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.MUTATOR, new FieldMetaData("mutator", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64          , "Mutator")));
      tmpMap.put(_Fields.CELLS, new FieldMetaData("cells", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new StructMetaData(TType.STRUCT, Cell.class))));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(set_cells_args.class, metaDataMap);
    }

    public set_cells_args() {
    }

    public set_cells_args(
      long mutator,
      List<Cell> cells)
    {
      this();
      this.mutator = mutator;
      setMutatorIsSet(true);
      this.cells = cells;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public set_cells_args(set_cells_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.mutator = other.mutator;
      if (other.isSetCells()) {
        List<Cell> __this__cells = new ArrayList<Cell>();
        for (Cell other_element : other.cells) {
          __this__cells.add(new Cell(other_element));
        }
        this.cells = __this__cells;
      }
    }

    public set_cells_args deepCopy() {
      return new set_cells_args(this);
    }

    @Override
    public void clear() {
      setMutatorIsSet(false);
      this.mutator = 0;
      this.cells = null;
    }

    public long getMutator() {
      return this.mutator;
    }

    public set_cells_args setMutator(long mutator) {
      this.mutator = mutator;
      setMutatorIsSet(true);
      return this;
    }

    public void unsetMutator() {
      __isset_bit_vector.clear(__MUTATOR_ISSET_ID);
    }

    /** Returns true if field mutator is set (has been asigned a value) and false otherwise */
    public boolean isSetMutator() {
      return __isset_bit_vector.get(__MUTATOR_ISSET_ID);
    }

    public void setMutatorIsSet(boolean value) {
      __isset_bit_vector.set(__MUTATOR_ISSET_ID, value);
    }

    public int getCellsSize() {
      return (this.cells == null) ? 0 : this.cells.size();
    }

    public java.util.Iterator<Cell> getCellsIterator() {
      return (this.cells == null) ? null : this.cells.iterator();
    }

    public void addToCells(Cell elem) {
      if (this.cells == null) {
        this.cells = new ArrayList<Cell>();
      }
      this.cells.add(elem);
    }

    public List<Cell> getCells() {
      return this.cells;
    }

    public set_cells_args setCells(List<Cell> cells) {
      this.cells = cells;
      return this;
    }

    public void unsetCells() {
      this.cells = null;
    }

    /** Returns true if field cells is set (has been asigned a value) and false otherwise */
    public boolean isSetCells() {
      return this.cells != null;
    }

    public void setCellsIsSet(boolean value) {
      if (!value) {
        this.cells = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case MUTATOR:
        if (value == null) {
          unsetMutator();
        } else {
          setMutator((Long)value);
        }
        break;

      case CELLS:
        if (value == null) {
          unsetCells();
        } else {
          setCells((List<Cell>)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case MUTATOR:
        return new Long(getMutator());

      case CELLS:
        return getCells();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case MUTATOR:
        return isSetMutator();
      case CELLS:
        return isSetCells();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof set_cells_args)
        return this.equals((set_cells_args)that);
      return false;
    }

    public boolean equals(set_cells_args that) {
      if (that == null)
        return false;

      boolean this_present_mutator = true;
      boolean that_present_mutator = true;
      if (this_present_mutator || that_present_mutator) {
        if (!(this_present_mutator && that_present_mutator))
          return false;
        if (this.mutator != that.mutator)
          return false;
      }

      boolean this_present_cells = true && this.isSetCells();
      boolean that_present_cells = true && that.isSetCells();
      if (this_present_cells || that_present_cells) {
        if (!(this_present_cells && that_present_cells))
          return false;
        if (!this.cells.equals(that.cells))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(set_cells_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      set_cells_args typedOther = (set_cells_args)other;

      lastComparison = Boolean.valueOf(isSetMutator()).compareTo(typedOther.isSetMutator());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetMutator()) {
        lastComparison = TBaseHelper.compareTo(this.mutator, typedOther.mutator);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetCells()).compareTo(typedOther.isSetCells());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetCells()) {
        lastComparison = TBaseHelper.compareTo(this.cells, typedOther.cells);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // MUTATOR
            if (field.type == TType.I64) {
              this.mutator = iprot.readI64();
              setMutatorIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // CELLS
            if (field.type == TType.LIST) {
              {
                TList _list106 = iprot.readListBegin();
                this.cells = new ArrayList<Cell>(_list106.size);
                for (int _i107 = 0; _i107 < _list106.size; ++_i107)
                {
                  Cell _elem108;
                  _elem108 = new Cell();
                  _elem108.read(iprot);
                  this.cells.add(_elem108);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(MUTATOR_FIELD_DESC);
      oprot.writeI64(this.mutator);
      oprot.writeFieldEnd();
      if (this.cells != null) {
        oprot.writeFieldBegin(CELLS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.cells.size()));
          for (Cell _iter109 : this.cells)
          {
            _iter109.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("set_cells_args(");
      boolean first = true;

      sb.append("mutator:");
      sb.append(this.mutator);
      first = false;
      if (!first) sb.append(", ");
      sb.append("cells:");
      if (this.cells == null) {
        sb.append("null");
      } else {
        sb.append(this.cells);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class set_cells_result implements TBase<set_cells_result, set_cells_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("set_cells_result");

    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public ClientException e;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      E((short)1, "e");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // E
            return E;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(set_cells_result.class, metaDataMap);
    }

    public set_cells_result() {
    }

    public set_cells_result(
      ClientException e)
    {
      this();
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public set_cells_result(set_cells_result other) {
      if (other.isSetE()) {
        this.e = new ClientException(other.e);
      }
    }

    public set_cells_result deepCopy() {
      return new set_cells_result(this);
    }

    @Override
    public void clear() {
      this.e = null;
    }

    public ClientException getE() {
      return this.e;
    }

    public set_cells_result setE(ClientException e) {
      this.e = e;
      return this;
    }

    public void unsetE() {
      this.e = null;
    }

    /** Returns true if field e is set (has been asigned a value) and false otherwise */
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((ClientException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case E:
        return getE();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case E:
        return isSetE();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof set_cells_result)
        return this.equals((set_cells_result)that);
      return false;
    }

    public boolean equals(set_cells_result that) {
      if (that == null)
        return false;

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(set_cells_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      set_cells_result typedOther = (set_cells_result)other;

      lastComparison = Boolean.valueOf(isSetE()).compareTo(typedOther.isSetE());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetE()) {
        lastComparison = TBaseHelper.compareTo(this.e, typedOther.e);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // E
            if (field.type == TType.STRUCT) {
              this.e = new ClientException();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetE()) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("set_cells_result(");
      boolean first = true;

      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class set_cells_as_arrays_args implements TBase<set_cells_as_arrays_args, set_cells_as_arrays_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("set_cells_as_arrays_args");

    private static final TField MUTATOR_FIELD_DESC = new TField("mutator", TType.I64, (short)1);
    private static final TField CELLS_FIELD_DESC = new TField("cells", TType.LIST, (short)2);

    public long mutator;
    public List<List<String>> cells;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      MUTATOR((short)1, "mutator"),
      CELLS((short)2, "cells");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // MUTATOR
            return MUTATOR;
          case 2: // CELLS
            return CELLS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __MUTATOR_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.MUTATOR, new FieldMetaData("mutator", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64          , "Mutator")));
      tmpMap.put(_Fields.CELLS, new FieldMetaData("cells", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.LIST              , "CellAsArray"))));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(set_cells_as_arrays_args.class, metaDataMap);
    }

    public set_cells_as_arrays_args() {
    }

    public set_cells_as_arrays_args(
      long mutator,
      List<List<String>> cells)
    {
      this();
      this.mutator = mutator;
      setMutatorIsSet(true);
      this.cells = cells;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public set_cells_as_arrays_args(set_cells_as_arrays_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.mutator = other.mutator;
      if (other.isSetCells()) {
        List<List<String>> __this__cells = new ArrayList<List<String>>();
        for (List<String> other_element : other.cells) {
          __this__cells.add(other_element);
        }
        this.cells = __this__cells;
      }
    }

    public set_cells_as_arrays_args deepCopy() {
      return new set_cells_as_arrays_args(this);
    }

    @Override
    public void clear() {
      setMutatorIsSet(false);
      this.mutator = 0;
      this.cells = null;
    }

    public long getMutator() {
      return this.mutator;
    }

    public set_cells_as_arrays_args setMutator(long mutator) {
      this.mutator = mutator;
      setMutatorIsSet(true);
      return this;
    }

    public void unsetMutator() {
      __isset_bit_vector.clear(__MUTATOR_ISSET_ID);
    }

    /** Returns true if field mutator is set (has been asigned a value) and false otherwise */
    public boolean isSetMutator() {
      return __isset_bit_vector.get(__MUTATOR_ISSET_ID);
    }

    public void setMutatorIsSet(boolean value) {
      __isset_bit_vector.set(__MUTATOR_ISSET_ID, value);
    }

    public int getCellsSize() {
      return (this.cells == null) ? 0 : this.cells.size();
    }

    public java.util.Iterator<List<String>> getCellsIterator() {
      return (this.cells == null) ? null : this.cells.iterator();
    }

    public void addToCells(List<String> elem) {
      if (this.cells == null) {
        this.cells = new ArrayList<List<String>>();
      }
      this.cells.add(elem);
    }

    public List<List<String>> getCells() {
      return this.cells;
    }

    public set_cells_as_arrays_args setCells(List<List<String>> cells) {
      this.cells = cells;
      return this;
    }

    public void unsetCells() {
      this.cells = null;
    }

    /** Returns true if field cells is set (has been asigned a value) and false otherwise */
    public boolean isSetCells() {
      return this.cells != null;
    }

    public void setCellsIsSet(boolean value) {
      if (!value) {
        this.cells = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case MUTATOR:
        if (value == null) {
          unsetMutator();
        } else {
          setMutator((Long)value);
        }
        break;

      case CELLS:
        if (value == null) {
          unsetCells();
        } else {
          setCells((List<List<String>>)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case MUTATOR:
        return new Long(getMutator());

      case CELLS:
        return getCells();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case MUTATOR:
        return isSetMutator();
      case CELLS:
        return isSetCells();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof set_cells_as_arrays_args)
        return this.equals((set_cells_as_arrays_args)that);
      return false;
    }

    public boolean equals(set_cells_as_arrays_args that) {
      if (that == null)
        return false;

      boolean this_present_mutator = true;
      boolean that_present_mutator = true;
      if (this_present_mutator || that_present_mutator) {
        if (!(this_present_mutator && that_present_mutator))
          return false;
        if (this.mutator != that.mutator)
          return false;
      }

      boolean this_present_cells = true && this.isSetCells();
      boolean that_present_cells = true && that.isSetCells();
      if (this_present_cells || that_present_cells) {
        if (!(this_present_cells && that_present_cells))
          return false;
        if (!this.cells.equals(that.cells))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(set_cells_as_arrays_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      set_cells_as_arrays_args typedOther = (set_cells_as_arrays_args)other;

      lastComparison = Boolean.valueOf(isSetMutator()).compareTo(typedOther.isSetMutator());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetMutator()) {
        lastComparison = TBaseHelper.compareTo(this.mutator, typedOther.mutator);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetCells()).compareTo(typedOther.isSetCells());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetCells()) {
        lastComparison = TBaseHelper.compareTo(this.cells, typedOther.cells);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // MUTATOR
            if (field.type == TType.I64) {
              this.mutator = iprot.readI64();
              setMutatorIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // CELLS
            if (field.type == TType.LIST) {
              {
                TList _list110 = iprot.readListBegin();
                this.cells = new ArrayList<List<String>>(_list110.size);
                for (int _i111 = 0; _i111 < _list110.size; ++_i111)
                {
                  List<String> _elem112;
                  {
                    TList _list113 = iprot.readListBegin();
                    _elem112 = new ArrayList<String>(_list113.size);
                    for (int _i114 = 0; _i114 < _list113.size; ++_i114)
                    {
                      String _elem115;
                      _elem115 = iprot.readString();
                      _elem112.add(_elem115);
                    }
                    iprot.readListEnd();
                  }
                  this.cells.add(_elem112);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(MUTATOR_FIELD_DESC);
      oprot.writeI64(this.mutator);
      oprot.writeFieldEnd();
      if (this.cells != null) {
        oprot.writeFieldBegin(CELLS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.LIST, this.cells.size()));
          for (List<String> _iter116 : this.cells)
          {
            {
              oprot.writeListBegin(new TList(TType.STRING, _iter116.size()));
              for (String _iter117 : _iter116)
              {
                oprot.writeString(_iter117);
              }
              oprot.writeListEnd();
            }
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("set_cells_as_arrays_args(");
      boolean first = true;

      sb.append("mutator:");
      sb.append(this.mutator);
      first = false;
      if (!first) sb.append(", ");
      sb.append("cells:");
      if (this.cells == null) {
        sb.append("null");
      } else {
        sb.append(this.cells);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class set_cells_as_arrays_result implements TBase<set_cells_as_arrays_result, set_cells_as_arrays_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("set_cells_as_arrays_result");

    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public ClientException e;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      E((short)1, "e");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // E
            return E;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(set_cells_as_arrays_result.class, metaDataMap);
    }

    public set_cells_as_arrays_result() {
    }

    public set_cells_as_arrays_result(
      ClientException e)
    {
      this();
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public set_cells_as_arrays_result(set_cells_as_arrays_result other) {
      if (other.isSetE()) {
        this.e = new ClientException(other.e);
      }
    }

    public set_cells_as_arrays_result deepCopy() {
      return new set_cells_as_arrays_result(this);
    }

    @Override
    public void clear() {
      this.e = null;
    }

    public ClientException getE() {
      return this.e;
    }

    public set_cells_as_arrays_result setE(ClientException e) {
      this.e = e;
      return this;
    }

    public void unsetE() {
      this.e = null;
    }

    /** Returns true if field e is set (has been asigned a value) and false otherwise */
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((ClientException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case E:
        return getE();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case E:
        return isSetE();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof set_cells_as_arrays_result)
        return this.equals((set_cells_as_arrays_result)that);
      return false;
    }

    public boolean equals(set_cells_as_arrays_result that) {
      if (that == null)
        return false;

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(set_cells_as_arrays_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      set_cells_as_arrays_result typedOther = (set_cells_as_arrays_result)other;

      lastComparison = Boolean.valueOf(isSetE()).compareTo(typedOther.isSetE());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetE()) {
        lastComparison = TBaseHelper.compareTo(this.e, typedOther.e);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // E
            if (field.type == TType.STRUCT) {
              this.e = new ClientException();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetE()) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("set_cells_as_arrays_result(");
      boolean first = true;

      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class set_cells_serialized_args implements TBase<set_cells_serialized_args, set_cells_serialized_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("set_cells_serialized_args");

    private static final TField MUTATOR_FIELD_DESC = new TField("mutator", TType.I64, (short)1);
    private static final TField CELLS_FIELD_DESC = new TField("cells", TType.STRING, (short)2);
    private static final TField FLUSH_FIELD_DESC = new TField("flush", TType.BOOL, (short)3);

    public long mutator;
    public ByteBuffer cells;
    public boolean flush;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      MUTATOR((short)1, "mutator"),
      CELLS((short)2, "cells"),
      FLUSH((short)3, "flush");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // MUTATOR
            return MUTATOR;
          case 2: // CELLS
            return CELLS;
          case 3: // FLUSH
            return FLUSH;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __MUTATOR_ISSET_ID = 0;
    private static final int __FLUSH_ISSET_ID = 1;
    private BitSet __isset_bit_vector = new BitSet(2);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.MUTATOR, new FieldMetaData("mutator", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64          , "Mutator")));
      tmpMap.put(_Fields.CELLS, new FieldMetaData("cells", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING          , "CellsSerialized")));
      tmpMap.put(_Fields.FLUSH, new FieldMetaData("flush", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.BOOL)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(set_cells_serialized_args.class, metaDataMap);
    }

    public set_cells_serialized_args() {
      this.flush = false;

    }

    public set_cells_serialized_args(
      long mutator,
      ByteBuffer cells,
      boolean flush)
    {
      this();
      this.mutator = mutator;
      setMutatorIsSet(true);
      this.cells = cells;
      this.flush = flush;
      setFlushIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public set_cells_serialized_args(set_cells_serialized_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.mutator = other.mutator;
      if (other.isSetCells()) {
        this.cells = other.cells;
      }
      this.flush = other.flush;
    }

    public set_cells_serialized_args deepCopy() {
      return new set_cells_serialized_args(this);
    }

    @Override
    public void clear() {
      setMutatorIsSet(false);
      this.mutator = 0;
      this.cells = null;
      this.flush = false;

    }

    public long getMutator() {
      return this.mutator;
    }

    public set_cells_serialized_args setMutator(long mutator) {
      this.mutator = mutator;
      setMutatorIsSet(true);
      return this;
    }

    public void unsetMutator() {
      __isset_bit_vector.clear(__MUTATOR_ISSET_ID);
    }

    /** Returns true if field mutator is set (has been asigned a value) and false otherwise */
    public boolean isSetMutator() {
      return __isset_bit_vector.get(__MUTATOR_ISSET_ID);
    }

    public void setMutatorIsSet(boolean value) {
      __isset_bit_vector.set(__MUTATOR_ISSET_ID, value);
    }

    public byte[] getCells() {
      setCells(TBaseHelper.rightSize(cells));
      return cells.array();
    }

    public ByteBuffer BufferForCells() {
      return cells;
    }

    public set_cells_serialized_args setCells(byte[] cells) {
      setCells(ByteBuffer.wrap(cells));
      return this;
    }

    public set_cells_serialized_args setCells(ByteBuffer cells) {
      this.cells = cells;
      return this;
    }

    public void unsetCells() {
      this.cells = null;
    }

    /** Returns true if field cells is set (has been asigned a value) and false otherwise */
    public boolean isSetCells() {
      return this.cells != null;
    }

    public void setCellsIsSet(boolean value) {
      if (!value) {
        this.cells = null;
      }
    }

    public boolean isFlush() {
      return this.flush;
    }

    public set_cells_serialized_args setFlush(boolean flush) {
      this.flush = flush;
      setFlushIsSet(true);
      return this;
    }

    public void unsetFlush() {
      __isset_bit_vector.clear(__FLUSH_ISSET_ID);
    }

    /** Returns true if field flush is set (has been asigned a value) and false otherwise */
    public boolean isSetFlush() {
      return __isset_bit_vector.get(__FLUSH_ISSET_ID);
    }

    public void setFlushIsSet(boolean value) {
      __isset_bit_vector.set(__FLUSH_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case MUTATOR:
        if (value == null) {
          unsetMutator();
        } else {
          setMutator((Long)value);
        }
        break;

      case CELLS:
        if (value == null) {
          unsetCells();
        } else {
          setCells((ByteBuffer)value);
        }
        break;

      case FLUSH:
        if (value == null) {
          unsetFlush();
        } else {
          setFlush((Boolean)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case MUTATOR:
        return new Long(getMutator());

      case CELLS:
        return getCells();

      case FLUSH:
        return new Boolean(isFlush());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case MUTATOR:
        return isSetMutator();
      case CELLS:
        return isSetCells();
      case FLUSH:
        return isSetFlush();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof set_cells_serialized_args)
        return this.equals((set_cells_serialized_args)that);
      return false;
    }

    public boolean equals(set_cells_serialized_args that) {
      if (that == null)
        return false;

      boolean this_present_mutator = true;
      boolean that_present_mutator = true;
      if (this_present_mutator || that_present_mutator) {
        if (!(this_present_mutator && that_present_mutator))
          return false;
        if (this.mutator != that.mutator)
          return false;
      }

      boolean this_present_cells = true && this.isSetCells();
      boolean that_present_cells = true && that.isSetCells();
      if (this_present_cells || that_present_cells) {
        if (!(this_present_cells && that_present_cells))
          return false;
        if (!this.cells.equals(that.cells))
          return false;
      }

      boolean this_present_flush = true;
      boolean that_present_flush = true;
      if (this_present_flush || that_present_flush) {
        if (!(this_present_flush && that_present_flush))
          return false;
        if (this.flush != that.flush)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(set_cells_serialized_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      set_cells_serialized_args typedOther = (set_cells_serialized_args)other;

      lastComparison = Boolean.valueOf(isSetMutator()).compareTo(typedOther.isSetMutator());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetMutator()) {
        lastComparison = TBaseHelper.compareTo(this.mutator, typedOther.mutator);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetCells()).compareTo(typedOther.isSetCells());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetCells()) {
        lastComparison = TBaseHelper.compareTo(this.cells, typedOther.cells);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetFlush()).compareTo(typedOther.isSetFlush());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetFlush()) {
        lastComparison = TBaseHelper.compareTo(this.flush, typedOther.flush);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // MUTATOR
            if (field.type == TType.I64) {
              this.mutator = iprot.readI64();
              setMutatorIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // CELLS
            if (field.type == TType.STRING) {
              this.cells = iprot.readBinary();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // FLUSH
            if (field.type == TType.BOOL) {
              this.flush = iprot.readBool();
              setFlushIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(MUTATOR_FIELD_DESC);
      oprot.writeI64(this.mutator);
      oprot.writeFieldEnd();
      if (this.cells != null) {
        oprot.writeFieldBegin(CELLS_FIELD_DESC);
        oprot.writeBinary(this.cells);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(FLUSH_FIELD_DESC);
      oprot.writeBool(this.flush);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("set_cells_serialized_args(");
      boolean first = true;

      sb.append("mutator:");
      sb.append(this.mutator);
      first = false;
      if (!first) sb.append(", ");
      sb.append("cells:");
      if (this.cells == null) {
        sb.append("null");
      } else {
        sb.append(this.cells);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("flush:");
      sb.append(this.flush);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class set_cells_serialized_result implements TBase<set_cells_serialized_result, set_cells_serialized_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("set_cells_serialized_result");

    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public ClientException e;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      E((short)1, "e");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // E
            return E;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(set_cells_serialized_result.class, metaDataMap);
    }

    public set_cells_serialized_result() {
    }

    public set_cells_serialized_result(
      ClientException e)
    {
      this();
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public set_cells_serialized_result(set_cells_serialized_result other) {
      if (other.isSetE()) {
        this.e = new ClientException(other.e);
      }
    }

    public set_cells_serialized_result deepCopy() {
      return new set_cells_serialized_result(this);
    }

    @Override
    public void clear() {
      this.e = null;
    }

    public ClientException getE() {
      return this.e;
    }

    public set_cells_serialized_result setE(ClientException e) {
      this.e = e;
      return this;
    }

    public void unsetE() {
      this.e = null;
    }

    /** Returns true if field e is set (has been asigned a value) and false otherwise */
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((ClientException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case E:
        return getE();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case E:
        return isSetE();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof set_cells_serialized_result)
        return this.equals((set_cells_serialized_result)that);
      return false;
    }

    public boolean equals(set_cells_serialized_result that) {
      if (that == null)
        return false;

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(set_cells_serialized_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      set_cells_serialized_result typedOther = (set_cells_serialized_result)other;

      lastComparison = Boolean.valueOf(isSetE()).compareTo(typedOther.isSetE());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetE()) {
        lastComparison = TBaseHelper.compareTo(this.e, typedOther.e);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // E
            if (field.type == TType.STRUCT) {
              this.e = new ClientException();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetE()) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("set_cells_serialized_result(");
      boolean first = true;

      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class flush_mutator_args implements TBase<flush_mutator_args, flush_mutator_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("flush_mutator_args");

    private static final TField MUTATOR_FIELD_DESC = new TField("mutator", TType.I64, (short)1);

    public long mutator;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      MUTATOR((short)1, "mutator");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // MUTATOR
            return MUTATOR;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __MUTATOR_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.MUTATOR, new FieldMetaData("mutator", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64          , "Mutator")));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(flush_mutator_args.class, metaDataMap);
    }

    public flush_mutator_args() {
    }

    public flush_mutator_args(
      long mutator)
    {
      this();
      this.mutator = mutator;
      setMutatorIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public flush_mutator_args(flush_mutator_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.mutator = other.mutator;
    }

    public flush_mutator_args deepCopy() {
      return new flush_mutator_args(this);
    }

    @Override
    public void clear() {
      setMutatorIsSet(false);
      this.mutator = 0;
    }

    public long getMutator() {
      return this.mutator;
    }

    public flush_mutator_args setMutator(long mutator) {
      this.mutator = mutator;
      setMutatorIsSet(true);
      return this;
    }

    public void unsetMutator() {
      __isset_bit_vector.clear(__MUTATOR_ISSET_ID);
    }

    /** Returns true if field mutator is set (has been asigned a value) and false otherwise */
    public boolean isSetMutator() {
      return __isset_bit_vector.get(__MUTATOR_ISSET_ID);
    }

    public void setMutatorIsSet(boolean value) {
      __isset_bit_vector.set(__MUTATOR_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case MUTATOR:
        if (value == null) {
          unsetMutator();
        } else {
          setMutator((Long)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case MUTATOR:
        return new Long(getMutator());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case MUTATOR:
        return isSetMutator();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof flush_mutator_args)
        return this.equals((flush_mutator_args)that);
      return false;
    }

    public boolean equals(flush_mutator_args that) {
      if (that == null)
        return false;

      boolean this_present_mutator = true;
      boolean that_present_mutator = true;
      if (this_present_mutator || that_present_mutator) {
        if (!(this_present_mutator && that_present_mutator))
          return false;
        if (this.mutator != that.mutator)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(flush_mutator_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      flush_mutator_args typedOther = (flush_mutator_args)other;

      lastComparison = Boolean.valueOf(isSetMutator()).compareTo(typedOther.isSetMutator());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetMutator()) {
        lastComparison = TBaseHelper.compareTo(this.mutator, typedOther.mutator);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // MUTATOR
            if (field.type == TType.I64) {
              this.mutator = iprot.readI64();
              setMutatorIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(MUTATOR_FIELD_DESC);
      oprot.writeI64(this.mutator);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("flush_mutator_args(");
      boolean first = true;

      sb.append("mutator:");
      sb.append(this.mutator);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class flush_mutator_result implements TBase<flush_mutator_result, flush_mutator_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("flush_mutator_result");

    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public ClientException e;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      E((short)1, "e");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // E
            return E;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(flush_mutator_result.class, metaDataMap);
    }

    public flush_mutator_result() {
    }

    public flush_mutator_result(
      ClientException e)
    {
      this();
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public flush_mutator_result(flush_mutator_result other) {
      if (other.isSetE()) {
        this.e = new ClientException(other.e);
      }
    }

    public flush_mutator_result deepCopy() {
      return new flush_mutator_result(this);
    }

    @Override
    public void clear() {
      this.e = null;
    }

    public ClientException getE() {
      return this.e;
    }

    public flush_mutator_result setE(ClientException e) {
      this.e = e;
      return this;
    }

    public void unsetE() {
      this.e = null;
    }

    /** Returns true if field e is set (has been asigned a value) and false otherwise */
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((ClientException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case E:
        return getE();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case E:
        return isSetE();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof flush_mutator_result)
        return this.equals((flush_mutator_result)that);
      return false;
    }

    public boolean equals(flush_mutator_result that) {
      if (that == null)
        return false;

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(flush_mutator_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      flush_mutator_result typedOther = (flush_mutator_result)other;

      lastComparison = Boolean.valueOf(isSetE()).compareTo(typedOther.isSetE());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetE()) {
        lastComparison = TBaseHelper.compareTo(this.e, typedOther.e);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // E
            if (field.type == TType.STRUCT) {
              this.e = new ClientException();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetE()) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("flush_mutator_result(");
      boolean first = true;

      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class exists_namespace_args implements TBase<exists_namespace_args, exists_namespace_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("exists_namespace_args");

    private static final TField NS_FIELD_DESC = new TField("ns", TType.STRING, (short)1);

    public String ns;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      NS((short)1, "ns");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // NS
            return NS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.NS, new FieldMetaData("ns", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(exists_namespace_args.class, metaDataMap);
    }

    public exists_namespace_args() {
    }

    public exists_namespace_args(
      String ns)
    {
      this();
      this.ns = ns;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public exists_namespace_args(exists_namespace_args other) {
      if (other.isSetNs()) {
        this.ns = other.ns;
      }
    }

    public exists_namespace_args deepCopy() {
      return new exists_namespace_args(this);
    }

    @Override
    public void clear() {
      this.ns = null;
    }

    public String getNs() {
      return this.ns;
    }

    public exists_namespace_args setNs(String ns) {
      this.ns = ns;
      return this;
    }

    public void unsetNs() {
      this.ns = null;
    }

    /** Returns true if field ns is set (has been asigned a value) and false otherwise */
    public boolean isSetNs() {
      return this.ns != null;
    }

    public void setNsIsSet(boolean value) {
      if (!value) {
        this.ns = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case NS:
        if (value == null) {
          unsetNs();
        } else {
          setNs((String)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case NS:
        return getNs();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case NS:
        return isSetNs();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof exists_namespace_args)
        return this.equals((exists_namespace_args)that);
      return false;
    }

    public boolean equals(exists_namespace_args that) {
      if (that == null)
        return false;

      boolean this_present_ns = true && this.isSetNs();
      boolean that_present_ns = true && that.isSetNs();
      if (this_present_ns || that_present_ns) {
        if (!(this_present_ns && that_present_ns))
          return false;
        if (!this.ns.equals(that.ns))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(exists_namespace_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      exists_namespace_args typedOther = (exists_namespace_args)other;

      lastComparison = Boolean.valueOf(isSetNs()).compareTo(typedOther.isSetNs());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetNs()) {
        lastComparison = TBaseHelper.compareTo(this.ns, typedOther.ns);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // NS
            if (field.type == TType.STRING) {
              this.ns = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.ns != null) {
        oprot.writeFieldBegin(NS_FIELD_DESC);
        oprot.writeString(this.ns);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("exists_namespace_args(");
      boolean first = true;

      sb.append("ns:");
      if (this.ns == null) {
        sb.append("null");
      } else {
        sb.append(this.ns);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class exists_namespace_result implements TBase<exists_namespace_result, exists_namespace_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("exists_namespace_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.BOOL, (short)0);
    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public boolean success;
    public ClientException e;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      E((short)1, "e");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // E
            return E;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __SUCCESS_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.BOOL)));
      tmpMap.put(_Fields.E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(exists_namespace_result.class, metaDataMap);
    }

    public exists_namespace_result() {
    }

    public exists_namespace_result(
      boolean success,
      ClientException e)
    {
      this();
      this.success = success;
      setSuccessIsSet(true);
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public exists_namespace_result(exists_namespace_result other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.success = other.success;
      if (other.isSetE()) {
        this.e = new ClientException(other.e);
      }
    }

    public exists_namespace_result deepCopy() {
      return new exists_namespace_result(this);
    }

    @Override
    public void clear() {
      setSuccessIsSet(false);
      this.success = false;
      this.e = null;
    }

    public boolean isSuccess() {
      return this.success;
    }

    public exists_namespace_result setSuccess(boolean success) {
      this.success = success;
      setSuccessIsSet(true);
      return this;
    }

    public void unsetSuccess() {
      __isset_bit_vector.clear(__SUCCESS_ISSET_ID);
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return __isset_bit_vector.get(__SUCCESS_ISSET_ID);
    }

    public void setSuccessIsSet(boolean value) {
      __isset_bit_vector.set(__SUCCESS_ISSET_ID, value);
    }

    public ClientException getE() {
      return this.e;
    }

    public exists_namespace_result setE(ClientException e) {
      this.e = e;
      return this;
    }

    public void unsetE() {
      this.e = null;
    }

    /** Returns true if field e is set (has been asigned a value) and false otherwise */
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Boolean)value);
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((ClientException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return new Boolean(isSuccess());

      case E:
        return getE();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof exists_namespace_result)
        return this.equals((exists_namespace_result)that);
      return false;
    }

    public boolean equals(exists_namespace_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(exists_namespace_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      exists_namespace_result typedOther = (exists_namespace_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetE()).compareTo(typedOther.isSetE());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetE()) {
        lastComparison = TBaseHelper.compareTo(this.e, typedOther.e);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.BOOL) {
              this.success = iprot.readBool();
              setSuccessIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // E
            if (field.type == TType.STRUCT) {
              this.e = new ClientException();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeBool(this.success);
        oprot.writeFieldEnd();
      } else if (this.isSetE()) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("exists_namespace_result(");
      boolean first = true;

      sb.append("success:");
      sb.append(this.success);
      first = false;
      if (!first) sb.append(", ");
      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class exists_table_args implements TBase<exists_table_args, exists_table_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("exists_table_args");

    private static final TField NS_FIELD_DESC = new TField("ns", TType.I64, (short)1);
    private static final TField NAME_FIELD_DESC = new TField("name", TType.STRING, (short)2);

    public long ns;
    public String name;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      NS((short)1, "ns"),
      NAME((short)2, "name");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // NS
            return NS;
          case 2: // NAME
            return NAME;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __NS_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.NS, new FieldMetaData("ns", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64          , "Namespace")));
      tmpMap.put(_Fields.NAME, new FieldMetaData("name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(exists_table_args.class, metaDataMap);
    }

    public exists_table_args() {
    }

    public exists_table_args(
      long ns,
      String name)
    {
      this();
      this.ns = ns;
      setNsIsSet(true);
      this.name = name;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public exists_table_args(exists_table_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.ns = other.ns;
      if (other.isSetName()) {
        this.name = other.name;
      }
    }

    public exists_table_args deepCopy() {
      return new exists_table_args(this);
    }

    @Override
    public void clear() {
      setNsIsSet(false);
      this.ns = 0;
      this.name = null;
    }

    public long getNs() {
      return this.ns;
    }

    public exists_table_args setNs(long ns) {
      this.ns = ns;
      setNsIsSet(true);
      return this;
    }

    public void unsetNs() {
      __isset_bit_vector.clear(__NS_ISSET_ID);
    }

    /** Returns true if field ns is set (has been asigned a value) and false otherwise */
    public boolean isSetNs() {
      return __isset_bit_vector.get(__NS_ISSET_ID);
    }

    public void setNsIsSet(boolean value) {
      __isset_bit_vector.set(__NS_ISSET_ID, value);
    }

    public String getName() {
      return this.name;
    }

    public exists_table_args setName(String name) {
      this.name = name;
      return this;
    }

    public void unsetName() {
      this.name = null;
    }

    /** Returns true if field name is set (has been asigned a value) and false otherwise */
    public boolean isSetName() {
      return this.name != null;
    }

    public void setNameIsSet(boolean value) {
      if (!value) {
        this.name = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case NS:
        if (value == null) {
          unsetNs();
        } else {
          setNs((Long)value);
        }
        break;

      case NAME:
        if (value == null) {
          unsetName();
        } else {
          setName((String)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case NS:
        return new Long(getNs());

      case NAME:
        return getName();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case NS:
        return isSetNs();
      case NAME:
        return isSetName();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof exists_table_args)
        return this.equals((exists_table_args)that);
      return false;
    }

    public boolean equals(exists_table_args that) {
      if (that == null)
        return false;

      boolean this_present_ns = true;
      boolean that_present_ns = true;
      if (this_present_ns || that_present_ns) {
        if (!(this_present_ns && that_present_ns))
          return false;
        if (this.ns != that.ns)
          return false;
      }

      boolean this_present_name = true && this.isSetName();
      boolean that_present_name = true && that.isSetName();
      if (this_present_name || that_present_name) {
        if (!(this_present_name && that_present_name))
          return false;
        if (!this.name.equals(that.name))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(exists_table_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      exists_table_args typedOther = (exists_table_args)other;

      lastComparison = Boolean.valueOf(isSetNs()).compareTo(typedOther.isSetNs());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetNs()) {
        lastComparison = TBaseHelper.compareTo(this.ns, typedOther.ns);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetName()).compareTo(typedOther.isSetName());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetName()) {
        lastComparison = TBaseHelper.compareTo(this.name, typedOther.name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // NS
            if (field.type == TType.I64) {
              this.ns = iprot.readI64();
              setNsIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // NAME
            if (field.type == TType.STRING) {
              this.name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(NS_FIELD_DESC);
      oprot.writeI64(this.ns);
      oprot.writeFieldEnd();
      if (this.name != null) {
        oprot.writeFieldBegin(NAME_FIELD_DESC);
        oprot.writeString(this.name);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("exists_table_args(");
      boolean first = true;

      sb.append("ns:");
      sb.append(this.ns);
      first = false;
      if (!first) sb.append(", ");
      sb.append("name:");
      if (this.name == null) {
        sb.append("null");
      } else {
        sb.append(this.name);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class exists_table_result implements TBase<exists_table_result, exists_table_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("exists_table_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.BOOL, (short)0);
    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public boolean success;
    public ClientException e;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      E((short)1, "e");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // E
            return E;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __SUCCESS_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.BOOL)));
      tmpMap.put(_Fields.E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(exists_table_result.class, metaDataMap);
    }

    public exists_table_result() {
    }

    public exists_table_result(
      boolean success,
      ClientException e)
    {
      this();
      this.success = success;
      setSuccessIsSet(true);
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public exists_table_result(exists_table_result other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.success = other.success;
      if (other.isSetE()) {
        this.e = new ClientException(other.e);
      }
    }

    public exists_table_result deepCopy() {
      return new exists_table_result(this);
    }

    @Override
    public void clear() {
      setSuccessIsSet(false);
      this.success = false;
      this.e = null;
    }

    public boolean isSuccess() {
      return this.success;
    }

    public exists_table_result setSuccess(boolean success) {
      this.success = success;
      setSuccessIsSet(true);
      return this;
    }

    public void unsetSuccess() {
      __isset_bit_vector.clear(__SUCCESS_ISSET_ID);
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return __isset_bit_vector.get(__SUCCESS_ISSET_ID);
    }

    public void setSuccessIsSet(boolean value) {
      __isset_bit_vector.set(__SUCCESS_ISSET_ID, value);
    }

    public ClientException getE() {
      return this.e;
    }

    public exists_table_result setE(ClientException e) {
      this.e = e;
      return this;
    }

    public void unsetE() {
      this.e = null;
    }

    /** Returns true if field e is set (has been asigned a value) and false otherwise */
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Boolean)value);
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((ClientException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return new Boolean(isSuccess());

      case E:
        return getE();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof exists_table_result)
        return this.equals((exists_table_result)that);
      return false;
    }

    public boolean equals(exists_table_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(exists_table_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      exists_table_result typedOther = (exists_table_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetE()).compareTo(typedOther.isSetE());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetE()) {
        lastComparison = TBaseHelper.compareTo(this.e, typedOther.e);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.BOOL) {
              this.success = iprot.readBool();
              setSuccessIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // E
            if (field.type == TType.STRUCT) {
              this.e = new ClientException();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeBool(this.success);
        oprot.writeFieldEnd();
      } else if (this.isSetE()) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("exists_table_result(");
      boolean first = true;

      sb.append("success:");
      sb.append(this.success);
      first = false;
      if (!first) sb.append(", ");
      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_table_id_args implements TBase<get_table_id_args, get_table_id_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_table_id_args");

    private static final TField NS_FIELD_DESC = new TField("ns", TType.I64, (short)1);
    private static final TField TABLE_NAME_FIELD_DESC = new TField("table_name", TType.STRING, (short)2);

    public long ns;
    public String table_name;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      NS((short)1, "ns"),
      TABLE_NAME((short)2, "table_name");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // NS
            return NS;
          case 2: // TABLE_NAME
            return TABLE_NAME;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __NS_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.NS, new FieldMetaData("ns", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64          , "Namespace")));
      tmpMap.put(_Fields.TABLE_NAME, new FieldMetaData("table_name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(get_table_id_args.class, metaDataMap);
    }

    public get_table_id_args() {
    }

    public get_table_id_args(
      long ns,
      String table_name)
    {
      this();
      this.ns = ns;
      setNsIsSet(true);
      this.table_name = table_name;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_table_id_args(get_table_id_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.ns = other.ns;
      if (other.isSetTable_name()) {
        this.table_name = other.table_name;
      }
    }

    public get_table_id_args deepCopy() {
      return new get_table_id_args(this);
    }

    @Override
    public void clear() {
      setNsIsSet(false);
      this.ns = 0;
      this.table_name = null;
    }

    public long getNs() {
      return this.ns;
    }

    public get_table_id_args setNs(long ns) {
      this.ns = ns;
      setNsIsSet(true);
      return this;
    }

    public void unsetNs() {
      __isset_bit_vector.clear(__NS_ISSET_ID);
    }

    /** Returns true if field ns is set (has been asigned a value) and false otherwise */
    public boolean isSetNs() {
      return __isset_bit_vector.get(__NS_ISSET_ID);
    }

    public void setNsIsSet(boolean value) {
      __isset_bit_vector.set(__NS_ISSET_ID, value);
    }

    public String getTable_name() {
      return this.table_name;
    }

    public get_table_id_args setTable_name(String table_name) {
      this.table_name = table_name;
      return this;
    }

    public void unsetTable_name() {
      this.table_name = null;
    }

    /** Returns true if field table_name is set (has been asigned a value) and false otherwise */
    public boolean isSetTable_name() {
      return this.table_name != null;
    }

    public void setTable_nameIsSet(boolean value) {
      if (!value) {
        this.table_name = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case NS:
        if (value == null) {
          unsetNs();
        } else {
          setNs((Long)value);
        }
        break;

      case TABLE_NAME:
        if (value == null) {
          unsetTable_name();
        } else {
          setTable_name((String)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case NS:
        return new Long(getNs());

      case TABLE_NAME:
        return getTable_name();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case NS:
        return isSetNs();
      case TABLE_NAME:
        return isSetTable_name();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_table_id_args)
        return this.equals((get_table_id_args)that);
      return false;
    }

    public boolean equals(get_table_id_args that) {
      if (that == null)
        return false;

      boolean this_present_ns = true;
      boolean that_present_ns = true;
      if (this_present_ns || that_present_ns) {
        if (!(this_present_ns && that_present_ns))
          return false;
        if (this.ns != that.ns)
          return false;
      }

      boolean this_present_table_name = true && this.isSetTable_name();
      boolean that_present_table_name = true && that.isSetTable_name();
      if (this_present_table_name || that_present_table_name) {
        if (!(this_present_table_name && that_present_table_name))
          return false;
        if (!this.table_name.equals(that.table_name))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_table_id_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_table_id_args typedOther = (get_table_id_args)other;

      lastComparison = Boolean.valueOf(isSetNs()).compareTo(typedOther.isSetNs());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetNs()) {
        lastComparison = TBaseHelper.compareTo(this.ns, typedOther.ns);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetTable_name()).compareTo(typedOther.isSetTable_name());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTable_name()) {
        lastComparison = TBaseHelper.compareTo(this.table_name, typedOther.table_name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // NS
            if (field.type == TType.I64) {
              this.ns = iprot.readI64();
              setNsIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // TABLE_NAME
            if (field.type == TType.STRING) {
              this.table_name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(NS_FIELD_DESC);
      oprot.writeI64(this.ns);
      oprot.writeFieldEnd();
      if (this.table_name != null) {
        oprot.writeFieldBegin(TABLE_NAME_FIELD_DESC);
        oprot.writeString(this.table_name);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_table_id_args(");
      boolean first = true;

      sb.append("ns:");
      sb.append(this.ns);
      first = false;
      if (!first) sb.append(", ");
      sb.append("table_name:");
      if (this.table_name == null) {
        sb.append("null");
      } else {
        sb.append(this.table_name);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_table_id_result implements TBase<get_table_id_result, get_table_id_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_table_id_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRING, (short)0);
    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public String success;
    public ClientException e;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      E((short)1, "e");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // E
            return E;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(get_table_id_result.class, metaDataMap);
    }

    public get_table_id_result() {
    }

    public get_table_id_result(
      String success,
      ClientException e)
    {
      this();
      this.success = success;
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_table_id_result(get_table_id_result other) {
      if (other.isSetSuccess()) {
        this.success = other.success;
      }
      if (other.isSetE()) {
        this.e = new ClientException(other.e);
      }
    }

    public get_table_id_result deepCopy() {
      return new get_table_id_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.e = null;
    }

    public String getSuccess() {
      return this.success;
    }

    public get_table_id_result setSuccess(String success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public ClientException getE() {
      return this.e;
    }

    public get_table_id_result setE(ClientException e) {
      this.e = e;
      return this;
    }

    public void unsetE() {
      this.e = null;
    }

    /** Returns true if field e is set (has been asigned a value) and false otherwise */
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((String)value);
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((ClientException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case E:
        return getE();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_table_id_result)
        return this.equals((get_table_id_result)that);
      return false;
    }

    public boolean equals(get_table_id_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_table_id_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_table_id_result typedOther = (get_table_id_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetE()).compareTo(typedOther.isSetE());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetE()) {
        lastComparison = TBaseHelper.compareTo(this.e, typedOther.e);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.STRING) {
              this.success = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // E
            if (field.type == TType.STRUCT) {
              this.e = new ClientException();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeString(this.success);
        oprot.writeFieldEnd();
      } else if (this.isSetE()) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_table_id_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_schema_str_args implements TBase<get_schema_str_args, get_schema_str_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_schema_str_args");

    private static final TField NS_FIELD_DESC = new TField("ns", TType.I64, (short)1);
    private static final TField TABLE_NAME_FIELD_DESC = new TField("table_name", TType.STRING, (short)2);

    public long ns;
    public String table_name;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      NS((short)1, "ns"),
      TABLE_NAME((short)2, "table_name");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // NS
            return NS;
          case 2: // TABLE_NAME
            return TABLE_NAME;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __NS_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.NS, new FieldMetaData("ns", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64          , "Namespace")));
      tmpMap.put(_Fields.TABLE_NAME, new FieldMetaData("table_name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(get_schema_str_args.class, metaDataMap);
    }

    public get_schema_str_args() {
    }

    public get_schema_str_args(
      long ns,
      String table_name)
    {
      this();
      this.ns = ns;
      setNsIsSet(true);
      this.table_name = table_name;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_schema_str_args(get_schema_str_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.ns = other.ns;
      if (other.isSetTable_name()) {
        this.table_name = other.table_name;
      }
    }

    public get_schema_str_args deepCopy() {
      return new get_schema_str_args(this);
    }

    @Override
    public void clear() {
      setNsIsSet(false);
      this.ns = 0;
      this.table_name = null;
    }

    public long getNs() {
      return this.ns;
    }

    public get_schema_str_args setNs(long ns) {
      this.ns = ns;
      setNsIsSet(true);
      return this;
    }

    public void unsetNs() {
      __isset_bit_vector.clear(__NS_ISSET_ID);
    }

    /** Returns true if field ns is set (has been asigned a value) and false otherwise */
    public boolean isSetNs() {
      return __isset_bit_vector.get(__NS_ISSET_ID);
    }

    public void setNsIsSet(boolean value) {
      __isset_bit_vector.set(__NS_ISSET_ID, value);
    }

    public String getTable_name() {
      return this.table_name;
    }

    public get_schema_str_args setTable_name(String table_name) {
      this.table_name = table_name;
      return this;
    }

    public void unsetTable_name() {
      this.table_name = null;
    }

    /** Returns true if field table_name is set (has been asigned a value) and false otherwise */
    public boolean isSetTable_name() {
      return this.table_name != null;
    }

    public void setTable_nameIsSet(boolean value) {
      if (!value) {
        this.table_name = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case NS:
        if (value == null) {
          unsetNs();
        } else {
          setNs((Long)value);
        }
        break;

      case TABLE_NAME:
        if (value == null) {
          unsetTable_name();
        } else {
          setTable_name((String)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case NS:
        return new Long(getNs());

      case TABLE_NAME:
        return getTable_name();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case NS:
        return isSetNs();
      case TABLE_NAME:
        return isSetTable_name();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_schema_str_args)
        return this.equals((get_schema_str_args)that);
      return false;
    }

    public boolean equals(get_schema_str_args that) {
      if (that == null)
        return false;

      boolean this_present_ns = true;
      boolean that_present_ns = true;
      if (this_present_ns || that_present_ns) {
        if (!(this_present_ns && that_present_ns))
          return false;
        if (this.ns != that.ns)
          return false;
      }

      boolean this_present_table_name = true && this.isSetTable_name();
      boolean that_present_table_name = true && that.isSetTable_name();
      if (this_present_table_name || that_present_table_name) {
        if (!(this_present_table_name && that_present_table_name))
          return false;
        if (!this.table_name.equals(that.table_name))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_schema_str_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_schema_str_args typedOther = (get_schema_str_args)other;

      lastComparison = Boolean.valueOf(isSetNs()).compareTo(typedOther.isSetNs());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetNs()) {
        lastComparison = TBaseHelper.compareTo(this.ns, typedOther.ns);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetTable_name()).compareTo(typedOther.isSetTable_name());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTable_name()) {
        lastComparison = TBaseHelper.compareTo(this.table_name, typedOther.table_name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // NS
            if (field.type == TType.I64) {
              this.ns = iprot.readI64();
              setNsIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // TABLE_NAME
            if (field.type == TType.STRING) {
              this.table_name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(NS_FIELD_DESC);
      oprot.writeI64(this.ns);
      oprot.writeFieldEnd();
      if (this.table_name != null) {
        oprot.writeFieldBegin(TABLE_NAME_FIELD_DESC);
        oprot.writeString(this.table_name);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_schema_str_args(");
      boolean first = true;

      sb.append("ns:");
      sb.append(this.ns);
      first = false;
      if (!first) sb.append(", ");
      sb.append("table_name:");
      if (this.table_name == null) {
        sb.append("null");
      } else {
        sb.append(this.table_name);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_schema_str_result implements TBase<get_schema_str_result, get_schema_str_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_schema_str_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRING, (short)0);
    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public String success;
    public ClientException e;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      E((short)1, "e");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // E
            return E;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(get_schema_str_result.class, metaDataMap);
    }

    public get_schema_str_result() {
    }

    public get_schema_str_result(
      String success,
      ClientException e)
    {
      this();
      this.success = success;
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_schema_str_result(get_schema_str_result other) {
      if (other.isSetSuccess()) {
        this.success = other.success;
      }
      if (other.isSetE()) {
        this.e = new ClientException(other.e);
      }
    }

    public get_schema_str_result deepCopy() {
      return new get_schema_str_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.e = null;
    }

    public String getSuccess() {
      return this.success;
    }

    public get_schema_str_result setSuccess(String success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public ClientException getE() {
      return this.e;
    }

    public get_schema_str_result setE(ClientException e) {
      this.e = e;
      return this;
    }

    public void unsetE() {
      this.e = null;
    }

    /** Returns true if field e is set (has been asigned a value) and false otherwise */
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((String)value);
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((ClientException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case E:
        return getE();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_schema_str_result)
        return this.equals((get_schema_str_result)that);
      return false;
    }

    public boolean equals(get_schema_str_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_schema_str_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_schema_str_result typedOther = (get_schema_str_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetE()).compareTo(typedOther.isSetE());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetE()) {
        lastComparison = TBaseHelper.compareTo(this.e, typedOther.e);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.STRING) {
              this.success = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // E
            if (field.type == TType.STRUCT) {
              this.e = new ClientException();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeString(this.success);
        oprot.writeFieldEnd();
      } else if (this.isSetE()) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_schema_str_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_schema_args implements TBase<get_schema_args, get_schema_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_schema_args");

    private static final TField NS_FIELD_DESC = new TField("ns", TType.I64, (short)1);
    private static final TField TABLE_NAME_FIELD_DESC = new TField("table_name", TType.STRING, (short)2);

    public long ns;
    public String table_name;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      NS((short)1, "ns"),
      TABLE_NAME((short)2, "table_name");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // NS
            return NS;
          case 2: // TABLE_NAME
            return TABLE_NAME;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __NS_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.NS, new FieldMetaData("ns", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64          , "Namespace")));
      tmpMap.put(_Fields.TABLE_NAME, new FieldMetaData("table_name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(get_schema_args.class, metaDataMap);
    }

    public get_schema_args() {
    }

    public get_schema_args(
      long ns,
      String table_name)
    {
      this();
      this.ns = ns;
      setNsIsSet(true);
      this.table_name = table_name;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_schema_args(get_schema_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.ns = other.ns;
      if (other.isSetTable_name()) {
        this.table_name = other.table_name;
      }
    }

    public get_schema_args deepCopy() {
      return new get_schema_args(this);
    }

    @Override
    public void clear() {
      setNsIsSet(false);
      this.ns = 0;
      this.table_name = null;
    }

    public long getNs() {
      return this.ns;
    }

    public get_schema_args setNs(long ns) {
      this.ns = ns;
      setNsIsSet(true);
      return this;
    }

    public void unsetNs() {
      __isset_bit_vector.clear(__NS_ISSET_ID);
    }

    /** Returns true if field ns is set (has been asigned a value) and false otherwise */
    public boolean isSetNs() {
      return __isset_bit_vector.get(__NS_ISSET_ID);
    }

    public void setNsIsSet(boolean value) {
      __isset_bit_vector.set(__NS_ISSET_ID, value);
    }

    public String getTable_name() {
      return this.table_name;
    }

    public get_schema_args setTable_name(String table_name) {
      this.table_name = table_name;
      return this;
    }

    public void unsetTable_name() {
      this.table_name = null;
    }

    /** Returns true if field table_name is set (has been asigned a value) and false otherwise */
    public boolean isSetTable_name() {
      return this.table_name != null;
    }

    public void setTable_nameIsSet(boolean value) {
      if (!value) {
        this.table_name = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case NS:
        if (value == null) {
          unsetNs();
        } else {
          setNs((Long)value);
        }
        break;

      case TABLE_NAME:
        if (value == null) {
          unsetTable_name();
        } else {
          setTable_name((String)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case NS:
        return new Long(getNs());

      case TABLE_NAME:
        return getTable_name();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case NS:
        return isSetNs();
      case TABLE_NAME:
        return isSetTable_name();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_schema_args)
        return this.equals((get_schema_args)that);
      return false;
    }

    public boolean equals(get_schema_args that) {
      if (that == null)
        return false;

      boolean this_present_ns = true;
      boolean that_present_ns = true;
      if (this_present_ns || that_present_ns) {
        if (!(this_present_ns && that_present_ns))
          return false;
        if (this.ns != that.ns)
          return false;
      }

      boolean this_present_table_name = true && this.isSetTable_name();
      boolean that_present_table_name = true && that.isSetTable_name();
      if (this_present_table_name || that_present_table_name) {
        if (!(this_present_table_name && that_present_table_name))
          return false;
        if (!this.table_name.equals(that.table_name))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_schema_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_schema_args typedOther = (get_schema_args)other;

      lastComparison = Boolean.valueOf(isSetNs()).compareTo(typedOther.isSetNs());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetNs()) {
        lastComparison = TBaseHelper.compareTo(this.ns, typedOther.ns);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetTable_name()).compareTo(typedOther.isSetTable_name());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTable_name()) {
        lastComparison = TBaseHelper.compareTo(this.table_name, typedOther.table_name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // NS
            if (field.type == TType.I64) {
              this.ns = iprot.readI64();
              setNsIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // TABLE_NAME
            if (field.type == TType.STRING) {
              this.table_name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(NS_FIELD_DESC);
      oprot.writeI64(this.ns);
      oprot.writeFieldEnd();
      if (this.table_name != null) {
        oprot.writeFieldBegin(TABLE_NAME_FIELD_DESC);
        oprot.writeString(this.table_name);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_schema_args(");
      boolean first = true;

      sb.append("ns:");
      sb.append(this.ns);
      first = false;
      if (!first) sb.append(", ");
      sb.append("table_name:");
      if (this.table_name == null) {
        sb.append("null");
      } else {
        sb.append(this.table_name);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_schema_result implements TBase<get_schema_result, get_schema_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_schema_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);
    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public Schema success;
    public ClientException e;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      E((short)1, "e");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // E
            return E;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, Schema.class)));
      tmpMap.put(_Fields.E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(get_schema_result.class, metaDataMap);
    }

    public get_schema_result() {
    }

    public get_schema_result(
      Schema success,
      ClientException e)
    {
      this();
      this.success = success;
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_schema_result(get_schema_result other) {
      if (other.isSetSuccess()) {
        this.success = new Schema(other.success);
      }
      if (other.isSetE()) {
        this.e = new ClientException(other.e);
      }
    }

    public get_schema_result deepCopy() {
      return new get_schema_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.e = null;
    }

    public Schema getSuccess() {
      return this.success;
    }

    public get_schema_result setSuccess(Schema success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public ClientException getE() {
      return this.e;
    }

    public get_schema_result setE(ClientException e) {
      this.e = e;
      return this;
    }

    public void unsetE() {
      this.e = null;
    }

    /** Returns true if field e is set (has been asigned a value) and false otherwise */
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Schema)value);
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((ClientException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case E:
        return getE();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_schema_result)
        return this.equals((get_schema_result)that);
      return false;
    }

    public boolean equals(get_schema_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_schema_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_schema_result typedOther = (get_schema_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetE()).compareTo(typedOther.isSetE());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetE()) {
        lastComparison = TBaseHelper.compareTo(this.e, typedOther.e);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.STRUCT) {
              this.success = new Schema();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // E
            if (field.type == TType.STRUCT) {
              this.e = new ClientException();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetE()) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_schema_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_tables_args implements TBase<get_tables_args, get_tables_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_tables_args");

    private static final TField NS_FIELD_DESC = new TField("ns", TType.I64, (short)1);

    public long ns;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      NS((short)1, "ns");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // NS
            return NS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __NS_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.NS, new FieldMetaData("ns", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64          , "Namespace")));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(get_tables_args.class, metaDataMap);
    }

    public get_tables_args() {
    }

    public get_tables_args(
      long ns)
    {
      this();
      this.ns = ns;
      setNsIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_tables_args(get_tables_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.ns = other.ns;
    }

    public get_tables_args deepCopy() {
      return new get_tables_args(this);
    }

    @Override
    public void clear() {
      setNsIsSet(false);
      this.ns = 0;
    }

    public long getNs() {
      return this.ns;
    }

    public get_tables_args setNs(long ns) {
      this.ns = ns;
      setNsIsSet(true);
      return this;
    }

    public void unsetNs() {
      __isset_bit_vector.clear(__NS_ISSET_ID);
    }

    /** Returns true if field ns is set (has been asigned a value) and false otherwise */
    public boolean isSetNs() {
      return __isset_bit_vector.get(__NS_ISSET_ID);
    }

    public void setNsIsSet(boolean value) {
      __isset_bit_vector.set(__NS_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case NS:
        if (value == null) {
          unsetNs();
        } else {
          setNs((Long)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case NS:
        return new Long(getNs());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case NS:
        return isSetNs();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_tables_args)
        return this.equals((get_tables_args)that);
      return false;
    }

    public boolean equals(get_tables_args that) {
      if (that == null)
        return false;

      boolean this_present_ns = true;
      boolean that_present_ns = true;
      if (this_present_ns || that_present_ns) {
        if (!(this_present_ns && that_present_ns))
          return false;
        if (this.ns != that.ns)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_tables_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_tables_args typedOther = (get_tables_args)other;

      lastComparison = Boolean.valueOf(isSetNs()).compareTo(typedOther.isSetNs());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetNs()) {
        lastComparison = TBaseHelper.compareTo(this.ns, typedOther.ns);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // NS
            if (field.type == TType.I64) {
              this.ns = iprot.readI64();
              setNsIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(NS_FIELD_DESC);
      oprot.writeI64(this.ns);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_tables_args(");
      boolean first = true;

      sb.append("ns:");
      sb.append(this.ns);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_tables_result implements TBase<get_tables_result, get_tables_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_tables_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public List<String> success;
    public ClientException e;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      E((short)1, "e");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // E
            return E;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.STRING))));
      tmpMap.put(_Fields.E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(get_tables_result.class, metaDataMap);
    }

    public get_tables_result() {
    }

    public get_tables_result(
      List<String> success,
      ClientException e)
    {
      this();
      this.success = success;
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_tables_result(get_tables_result other) {
      if (other.isSetSuccess()) {
        List<String> __this__success = new ArrayList<String>();
        for (String other_element : other.success) {
          __this__success.add(other_element);
        }
        this.success = __this__success;
      }
      if (other.isSetE()) {
        this.e = new ClientException(other.e);
      }
    }

    public get_tables_result deepCopy() {
      return new get_tables_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.e = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<String> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(String elem) {
      if (this.success == null) {
        this.success = new ArrayList<String>();
      }
      this.success.add(elem);
    }

    public List<String> getSuccess() {
      return this.success;
    }

    public get_tables_result setSuccess(List<String> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public ClientException getE() {
      return this.e;
    }

    public get_tables_result setE(ClientException e) {
      this.e = e;
      return this;
    }

    public void unsetE() {
      this.e = null;
    }

    /** Returns true if field e is set (has been asigned a value) and false otherwise */
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<String>)value);
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((ClientException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case E:
        return getE();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_tables_result)
        return this.equals((get_tables_result)that);
      return false;
    }

    public boolean equals(get_tables_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_tables_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_tables_result typedOther = (get_tables_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetE()).compareTo(typedOther.isSetE());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetE()) {
        lastComparison = TBaseHelper.compareTo(this.e, typedOther.e);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.LIST) {
              {
                TList _list118 = iprot.readListBegin();
                this.success = new ArrayList<String>(_list118.size);
                for (int _i119 = 0; _i119 < _list118.size; ++_i119)
                {
                  String _elem120;
                  _elem120 = iprot.readString();
                  this.success.add(_elem120);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // E
            if (field.type == TType.STRUCT) {
              this.e = new ClientException();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRING, this.success.size()));
          for (String _iter121 : this.success)
          {
            oprot.writeString(_iter121);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetE()) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_tables_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_listing_args implements TBase<get_listing_args, get_listing_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_listing_args");

    private static final TField NS_FIELD_DESC = new TField("ns", TType.I64, (short)1);

    public long ns;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      NS((short)1, "ns");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // NS
            return NS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __NS_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.NS, new FieldMetaData("ns", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64          , "Namespace")));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(get_listing_args.class, metaDataMap);
    }

    public get_listing_args() {
    }

    public get_listing_args(
      long ns)
    {
      this();
      this.ns = ns;
      setNsIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_listing_args(get_listing_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.ns = other.ns;
    }

    public get_listing_args deepCopy() {
      return new get_listing_args(this);
    }

    @Override
    public void clear() {
      setNsIsSet(false);
      this.ns = 0;
    }

    public long getNs() {
      return this.ns;
    }

    public get_listing_args setNs(long ns) {
      this.ns = ns;
      setNsIsSet(true);
      return this;
    }

    public void unsetNs() {
      __isset_bit_vector.clear(__NS_ISSET_ID);
    }

    /** Returns true if field ns is set (has been asigned a value) and false otherwise */
    public boolean isSetNs() {
      return __isset_bit_vector.get(__NS_ISSET_ID);
    }

    public void setNsIsSet(boolean value) {
      __isset_bit_vector.set(__NS_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case NS:
        if (value == null) {
          unsetNs();
        } else {
          setNs((Long)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case NS:
        return new Long(getNs());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case NS:
        return isSetNs();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_listing_args)
        return this.equals((get_listing_args)that);
      return false;
    }

    public boolean equals(get_listing_args that) {
      if (that == null)
        return false;

      boolean this_present_ns = true;
      boolean that_present_ns = true;
      if (this_present_ns || that_present_ns) {
        if (!(this_present_ns && that_present_ns))
          return false;
        if (this.ns != that.ns)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_listing_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_listing_args typedOther = (get_listing_args)other;

      lastComparison = Boolean.valueOf(isSetNs()).compareTo(typedOther.isSetNs());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetNs()) {
        lastComparison = TBaseHelper.compareTo(this.ns, typedOther.ns);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // NS
            if (field.type == TType.I64) {
              this.ns = iprot.readI64();
              setNsIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(NS_FIELD_DESC);
      oprot.writeI64(this.ns);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_listing_args(");
      boolean first = true;

      sb.append("ns:");
      sb.append(this.ns);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_listing_result implements TBase<get_listing_result, get_listing_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_listing_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public List<NamespaceListing> success;
    public ClientException e;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      E((short)1, "e");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // E
            return E;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new StructMetaData(TType.STRUCT, NamespaceListing.class))));
      tmpMap.put(_Fields.E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(get_listing_result.class, metaDataMap);
    }

    public get_listing_result() {
    }

    public get_listing_result(
      List<NamespaceListing> success,
      ClientException e)
    {
      this();
      this.success = success;
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_listing_result(get_listing_result other) {
      if (other.isSetSuccess()) {
        List<NamespaceListing> __this__success = new ArrayList<NamespaceListing>();
        for (NamespaceListing other_element : other.success) {
          __this__success.add(new NamespaceListing(other_element));
        }
        this.success = __this__success;
      }
      if (other.isSetE()) {
        this.e = new ClientException(other.e);
      }
    }

    public get_listing_result deepCopy() {
      return new get_listing_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.e = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<NamespaceListing> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(NamespaceListing elem) {
      if (this.success == null) {
        this.success = new ArrayList<NamespaceListing>();
      }
      this.success.add(elem);
    }

    public List<NamespaceListing> getSuccess() {
      return this.success;
    }

    public get_listing_result setSuccess(List<NamespaceListing> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public ClientException getE() {
      return this.e;
    }

    public get_listing_result setE(ClientException e) {
      this.e = e;
      return this;
    }

    public void unsetE() {
      this.e = null;
    }

    /** Returns true if field e is set (has been asigned a value) and false otherwise */
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<NamespaceListing>)value);
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((ClientException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case E:
        return getE();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_listing_result)
        return this.equals((get_listing_result)that);
      return false;
    }

    public boolean equals(get_listing_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_listing_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_listing_result typedOther = (get_listing_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetE()).compareTo(typedOther.isSetE());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetE()) {
        lastComparison = TBaseHelper.compareTo(this.e, typedOther.e);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.LIST) {
              {
                TList _list122 = iprot.readListBegin();
                this.success = new ArrayList<NamespaceListing>(_list122.size);
                for (int _i123 = 0; _i123 < _list122.size; ++_i123)
                {
                  NamespaceListing _elem124;
                  _elem124 = new NamespaceListing();
                  _elem124.read(iprot);
                  this.success.add(_elem124);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // E
            if (field.type == TType.STRUCT) {
              this.e = new ClientException();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
          for (NamespaceListing _iter125 : this.success)
          {
            _iter125.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetE()) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_listing_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_table_splits_args implements TBase<get_table_splits_args, get_table_splits_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_table_splits_args");

    private static final TField NS_FIELD_DESC = new TField("ns", TType.I64, (short)1);
    private static final TField TABLE_NAME_FIELD_DESC = new TField("table_name", TType.STRING, (short)2);

    public long ns;
    public String table_name;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      NS((short)1, "ns"),
      TABLE_NAME((short)2, "table_name");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // NS
            return NS;
          case 2: // TABLE_NAME
            return TABLE_NAME;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __NS_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.NS, new FieldMetaData("ns", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64          , "Namespace")));
      tmpMap.put(_Fields.TABLE_NAME, new FieldMetaData("table_name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(get_table_splits_args.class, metaDataMap);
    }

    public get_table_splits_args() {
    }

    public get_table_splits_args(
      long ns,
      String table_name)
    {
      this();
      this.ns = ns;
      setNsIsSet(true);
      this.table_name = table_name;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_table_splits_args(get_table_splits_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.ns = other.ns;
      if (other.isSetTable_name()) {
        this.table_name = other.table_name;
      }
    }

    public get_table_splits_args deepCopy() {
      return new get_table_splits_args(this);
    }

    @Override
    public void clear() {
      setNsIsSet(false);
      this.ns = 0;
      this.table_name = null;
    }

    public long getNs() {
      return this.ns;
    }

    public get_table_splits_args setNs(long ns) {
      this.ns = ns;
      setNsIsSet(true);
      return this;
    }

    public void unsetNs() {
      __isset_bit_vector.clear(__NS_ISSET_ID);
    }

    /** Returns true if field ns is set (has been asigned a value) and false otherwise */
    public boolean isSetNs() {
      return __isset_bit_vector.get(__NS_ISSET_ID);
    }

    public void setNsIsSet(boolean value) {
      __isset_bit_vector.set(__NS_ISSET_ID, value);
    }

    public String getTable_name() {
      return this.table_name;
    }

    public get_table_splits_args setTable_name(String table_name) {
      this.table_name = table_name;
      return this;
    }

    public void unsetTable_name() {
      this.table_name = null;
    }

    /** Returns true if field table_name is set (has been asigned a value) and false otherwise */
    public boolean isSetTable_name() {
      return this.table_name != null;
    }

    public void setTable_nameIsSet(boolean value) {
      if (!value) {
        this.table_name = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case NS:
        if (value == null) {
          unsetNs();
        } else {
          setNs((Long)value);
        }
        break;

      case TABLE_NAME:
        if (value == null) {
          unsetTable_name();
        } else {
          setTable_name((String)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case NS:
        return new Long(getNs());

      case TABLE_NAME:
        return getTable_name();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case NS:
        return isSetNs();
      case TABLE_NAME:
        return isSetTable_name();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_table_splits_args)
        return this.equals((get_table_splits_args)that);
      return false;
    }

    public boolean equals(get_table_splits_args that) {
      if (that == null)
        return false;

      boolean this_present_ns = true;
      boolean that_present_ns = true;
      if (this_present_ns || that_present_ns) {
        if (!(this_present_ns && that_present_ns))
          return false;
        if (this.ns != that.ns)
          return false;
      }

      boolean this_present_table_name = true && this.isSetTable_name();
      boolean that_present_table_name = true && that.isSetTable_name();
      if (this_present_table_name || that_present_table_name) {
        if (!(this_present_table_name && that_present_table_name))
          return false;
        if (!this.table_name.equals(that.table_name))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_table_splits_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_table_splits_args typedOther = (get_table_splits_args)other;

      lastComparison = Boolean.valueOf(isSetNs()).compareTo(typedOther.isSetNs());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetNs()) {
        lastComparison = TBaseHelper.compareTo(this.ns, typedOther.ns);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetTable_name()).compareTo(typedOther.isSetTable_name());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTable_name()) {
        lastComparison = TBaseHelper.compareTo(this.table_name, typedOther.table_name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // NS
            if (field.type == TType.I64) {
              this.ns = iprot.readI64();
              setNsIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // TABLE_NAME
            if (field.type == TType.STRING) {
              this.table_name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(NS_FIELD_DESC);
      oprot.writeI64(this.ns);
      oprot.writeFieldEnd();
      if (this.table_name != null) {
        oprot.writeFieldBegin(TABLE_NAME_FIELD_DESC);
        oprot.writeString(this.table_name);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_table_splits_args(");
      boolean first = true;

      sb.append("ns:");
      sb.append(this.ns);
      first = false;
      if (!first) sb.append(", ");
      sb.append("table_name:");
      if (this.table_name == null) {
        sb.append("null");
      } else {
        sb.append(this.table_name);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_table_splits_result implements TBase<get_table_splits_result, get_table_splits_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_table_splits_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public List<TableSplit> success;
    public ClientException e;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      E((short)1, "e");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // E
            return E;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new StructMetaData(TType.STRUCT, TableSplit.class))));
      tmpMap.put(_Fields.E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(get_table_splits_result.class, metaDataMap);
    }

    public get_table_splits_result() {
    }

    public get_table_splits_result(
      List<TableSplit> success,
      ClientException e)
    {
      this();
      this.success = success;
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_table_splits_result(get_table_splits_result other) {
      if (other.isSetSuccess()) {
        List<TableSplit> __this__success = new ArrayList<TableSplit>();
        for (TableSplit other_element : other.success) {
          __this__success.add(new TableSplit(other_element));
        }
        this.success = __this__success;
      }
      if (other.isSetE()) {
        this.e = new ClientException(other.e);
      }
    }

    public get_table_splits_result deepCopy() {
      return new get_table_splits_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.e = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<TableSplit> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(TableSplit elem) {
      if (this.success == null) {
        this.success = new ArrayList<TableSplit>();
      }
      this.success.add(elem);
    }

    public List<TableSplit> getSuccess() {
      return this.success;
    }

    public get_table_splits_result setSuccess(List<TableSplit> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public ClientException getE() {
      return this.e;
    }

    public get_table_splits_result setE(ClientException e) {
      this.e = e;
      return this;
    }

    public void unsetE() {
      this.e = null;
    }

    /** Returns true if field e is set (has been asigned a value) and false otherwise */
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<TableSplit>)value);
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((ClientException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case E:
        return getE();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_table_splits_result)
        return this.equals((get_table_splits_result)that);
      return false;
    }

    public boolean equals(get_table_splits_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_table_splits_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_table_splits_result typedOther = (get_table_splits_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetE()).compareTo(typedOther.isSetE());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetE()) {
        lastComparison = TBaseHelper.compareTo(this.e, typedOther.e);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.LIST) {
              {
                TList _list126 = iprot.readListBegin();
                this.success = new ArrayList<TableSplit>(_list126.size);
                for (int _i127 = 0; _i127 < _list126.size; ++_i127)
                {
                  TableSplit _elem128;
                  _elem128 = new TableSplit();
                  _elem128.read(iprot);
                  this.success.add(_elem128);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // E
            if (field.type == TType.STRUCT) {
              this.e = new ClientException();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
          for (TableSplit _iter129 : this.success)
          {
            _iter129.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetE()) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_table_splits_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class drop_namespace_args implements TBase<drop_namespace_args, drop_namespace_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("drop_namespace_args");

    private static final TField NS_FIELD_DESC = new TField("ns", TType.STRING, (short)1);
    private static final TField IF_EXISTS_FIELD_DESC = new TField("if_exists", TType.BOOL, (short)2);

    public String ns;
    public boolean if_exists;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      NS((short)1, "ns"),
      IF_EXISTS((short)2, "if_exists");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // NS
            return NS;
          case 2: // IF_EXISTS
            return IF_EXISTS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __IF_EXISTS_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.NS, new FieldMetaData("ns", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.IF_EXISTS, new FieldMetaData("if_exists", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.BOOL)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(drop_namespace_args.class, metaDataMap);
    }

    public drop_namespace_args() {
      this.if_exists = true;

    }

    public drop_namespace_args(
      String ns,
      boolean if_exists)
    {
      this();
      this.ns = ns;
      this.if_exists = if_exists;
      setIf_existsIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public drop_namespace_args(drop_namespace_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      if (other.isSetNs()) {
        this.ns = other.ns;
      }
      this.if_exists = other.if_exists;
    }

    public drop_namespace_args deepCopy() {
      return new drop_namespace_args(this);
    }

    @Override
    public void clear() {
      this.ns = null;
      this.if_exists = true;

    }

    public String getNs() {
      return this.ns;
    }

    public drop_namespace_args setNs(String ns) {
      this.ns = ns;
      return this;
    }

    public void unsetNs() {
      this.ns = null;
    }

    /** Returns true if field ns is set (has been asigned a value) and false otherwise */
    public boolean isSetNs() {
      return this.ns != null;
    }

    public void setNsIsSet(boolean value) {
      if (!value) {
        this.ns = null;
      }
    }

    public boolean isIf_exists() {
      return this.if_exists;
    }

    public drop_namespace_args setIf_exists(boolean if_exists) {
      this.if_exists = if_exists;
      setIf_existsIsSet(true);
      return this;
    }

    public void unsetIf_exists() {
      __isset_bit_vector.clear(__IF_EXISTS_ISSET_ID);
    }

    /** Returns true if field if_exists is set (has been asigned a value) and false otherwise */
    public boolean isSetIf_exists() {
      return __isset_bit_vector.get(__IF_EXISTS_ISSET_ID);
    }

    public void setIf_existsIsSet(boolean value) {
      __isset_bit_vector.set(__IF_EXISTS_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case NS:
        if (value == null) {
          unsetNs();
        } else {
          setNs((String)value);
        }
        break;

      case IF_EXISTS:
        if (value == null) {
          unsetIf_exists();
        } else {
          setIf_exists((Boolean)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case NS:
        return getNs();

      case IF_EXISTS:
        return new Boolean(isIf_exists());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case NS:
        return isSetNs();
      case IF_EXISTS:
        return isSetIf_exists();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof drop_namespace_args)
        return this.equals((drop_namespace_args)that);
      return false;
    }

    public boolean equals(drop_namespace_args that) {
      if (that == null)
        return false;

      boolean this_present_ns = true && this.isSetNs();
      boolean that_present_ns = true && that.isSetNs();
      if (this_present_ns || that_present_ns) {
        if (!(this_present_ns && that_present_ns))
          return false;
        if (!this.ns.equals(that.ns))
          return false;
      }

      boolean this_present_if_exists = true;
      boolean that_present_if_exists = true;
      if (this_present_if_exists || that_present_if_exists) {
        if (!(this_present_if_exists && that_present_if_exists))
          return false;
        if (this.if_exists != that.if_exists)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(drop_namespace_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      drop_namespace_args typedOther = (drop_namespace_args)other;

      lastComparison = Boolean.valueOf(isSetNs()).compareTo(typedOther.isSetNs());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetNs()) {
        lastComparison = TBaseHelper.compareTo(this.ns, typedOther.ns);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetIf_exists()).compareTo(typedOther.isSetIf_exists());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetIf_exists()) {
        lastComparison = TBaseHelper.compareTo(this.if_exists, typedOther.if_exists);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // NS
            if (field.type == TType.STRING) {
              this.ns = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // IF_EXISTS
            if (field.type == TType.BOOL) {
              this.if_exists = iprot.readBool();
              setIf_existsIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.ns != null) {
        oprot.writeFieldBegin(NS_FIELD_DESC);
        oprot.writeString(this.ns);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(IF_EXISTS_FIELD_DESC);
      oprot.writeBool(this.if_exists);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("drop_namespace_args(");
      boolean first = true;

      sb.append("ns:");
      if (this.ns == null) {
        sb.append("null");
      } else {
        sb.append(this.ns);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("if_exists:");
      sb.append(this.if_exists);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class drop_namespace_result implements TBase<drop_namespace_result, drop_namespace_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("drop_namespace_result");

    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public ClientException e;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      E((short)1, "e");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // E
            return E;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(drop_namespace_result.class, metaDataMap);
    }

    public drop_namespace_result() {
    }

    public drop_namespace_result(
      ClientException e)
    {
      this();
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public drop_namespace_result(drop_namespace_result other) {
      if (other.isSetE()) {
        this.e = new ClientException(other.e);
      }
    }

    public drop_namespace_result deepCopy() {
      return new drop_namespace_result(this);
    }

    @Override
    public void clear() {
      this.e = null;
    }

    public ClientException getE() {
      return this.e;
    }

    public drop_namespace_result setE(ClientException e) {
      this.e = e;
      return this;
    }

    public void unsetE() {
      this.e = null;
    }

    /** Returns true if field e is set (has been asigned a value) and false otherwise */
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((ClientException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case E:
        return getE();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case E:
        return isSetE();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof drop_namespace_result)
        return this.equals((drop_namespace_result)that);
      return false;
    }

    public boolean equals(drop_namespace_result that) {
      if (that == null)
        return false;

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(drop_namespace_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      drop_namespace_result typedOther = (drop_namespace_result)other;

      lastComparison = Boolean.valueOf(isSetE()).compareTo(typedOther.isSetE());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetE()) {
        lastComparison = TBaseHelper.compareTo(this.e, typedOther.e);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // E
            if (field.type == TType.STRUCT) {
              this.e = new ClientException();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetE()) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("drop_namespace_result(");
      boolean first = true;

      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class rename_table_args implements TBase<rename_table_args, rename_table_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("rename_table_args");

    private static final TField NS_FIELD_DESC = new TField("ns", TType.I64, (short)1);
    private static final TField NAME_FIELD_DESC = new TField("name", TType.STRING, (short)2);
    private static final TField NEW_NAME_FIELD_DESC = new TField("new_name", TType.STRING, (short)3);

    public long ns;
    public String name;
    public String new_name;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      NS((short)1, "ns"),
      NAME((short)2, "name"),
      NEW_NAME((short)3, "new_name");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // NS
            return NS;
          case 2: // NAME
            return NAME;
          case 3: // NEW_NAME
            return NEW_NAME;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __NS_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.NS, new FieldMetaData("ns", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64          , "Namespace")));
      tmpMap.put(_Fields.NAME, new FieldMetaData("name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.NEW_NAME, new FieldMetaData("new_name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(rename_table_args.class, metaDataMap);
    }

    public rename_table_args() {
    }

    public rename_table_args(
      long ns,
      String name,
      String new_name)
    {
      this();
      this.ns = ns;
      setNsIsSet(true);
      this.name = name;
      this.new_name = new_name;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public rename_table_args(rename_table_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.ns = other.ns;
      if (other.isSetName()) {
        this.name = other.name;
      }
      if (other.isSetNew_name()) {
        this.new_name = other.new_name;
      }
    }

    public rename_table_args deepCopy() {
      return new rename_table_args(this);
    }

    @Override
    public void clear() {
      setNsIsSet(false);
      this.ns = 0;
      this.name = null;
      this.new_name = null;
    }

    public long getNs() {
      return this.ns;
    }

    public rename_table_args setNs(long ns) {
      this.ns = ns;
      setNsIsSet(true);
      return this;
    }

    public void unsetNs() {
      __isset_bit_vector.clear(__NS_ISSET_ID);
    }

    /** Returns true if field ns is set (has been asigned a value) and false otherwise */
    public boolean isSetNs() {
      return __isset_bit_vector.get(__NS_ISSET_ID);
    }

    public void setNsIsSet(boolean value) {
      __isset_bit_vector.set(__NS_ISSET_ID, value);
    }

    public String getName() {
      return this.name;
    }

    public rename_table_args setName(String name) {
      this.name = name;
      return this;
    }

    public void unsetName() {
      this.name = null;
    }

    /** Returns true if field name is set (has been asigned a value) and false otherwise */
    public boolean isSetName() {
      return this.name != null;
    }

    public void setNameIsSet(boolean value) {
      if (!value) {
        this.name = null;
      }
    }

    public String getNew_name() {
      return this.new_name;
    }

    public rename_table_args setNew_name(String new_name) {
      this.new_name = new_name;
      return this;
    }

    public void unsetNew_name() {
      this.new_name = null;
    }

    /** Returns true if field new_name is set (has been asigned a value) and false otherwise */
    public boolean isSetNew_name() {
      return this.new_name != null;
    }

    public void setNew_nameIsSet(boolean value) {
      if (!value) {
        this.new_name = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case NS:
        if (value == null) {
          unsetNs();
        } else {
          setNs((Long)value);
        }
        break;

      case NAME:
        if (value == null) {
          unsetName();
        } else {
          setName((String)value);
        }
        break;

      case NEW_NAME:
        if (value == null) {
          unsetNew_name();
        } else {
          setNew_name((String)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case NS:
        return new Long(getNs());

      case NAME:
        return getName();

      case NEW_NAME:
        return getNew_name();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case NS:
        return isSetNs();
      case NAME:
        return isSetName();
      case NEW_NAME:
        return isSetNew_name();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof rename_table_args)
        return this.equals((rename_table_args)that);
      return false;
    }

    public boolean equals(rename_table_args that) {
      if (that == null)
        return false;

      boolean this_present_ns = true;
      boolean that_present_ns = true;
      if (this_present_ns || that_present_ns) {
        if (!(this_present_ns && that_present_ns))
          return false;
        if (this.ns != that.ns)
          return false;
      }

      boolean this_present_name = true && this.isSetName();
      boolean that_present_name = true && that.isSetName();
      if (this_present_name || that_present_name) {
        if (!(this_present_name && that_present_name))
          return false;
        if (!this.name.equals(that.name))
          return false;
      }

      boolean this_present_new_name = true && this.isSetNew_name();
      boolean that_present_new_name = true && that.isSetNew_name();
      if (this_present_new_name || that_present_new_name) {
        if (!(this_present_new_name && that_present_new_name))
          return false;
        if (!this.new_name.equals(that.new_name))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(rename_table_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      rename_table_args typedOther = (rename_table_args)other;

      lastComparison = Boolean.valueOf(isSetNs()).compareTo(typedOther.isSetNs());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetNs()) {
        lastComparison = TBaseHelper.compareTo(this.ns, typedOther.ns);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetName()).compareTo(typedOther.isSetName());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetName()) {
        lastComparison = TBaseHelper.compareTo(this.name, typedOther.name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetNew_name()).compareTo(typedOther.isSetNew_name());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetNew_name()) {
        lastComparison = TBaseHelper.compareTo(this.new_name, typedOther.new_name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // NS
            if (field.type == TType.I64) {
              this.ns = iprot.readI64();
              setNsIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // NAME
            if (field.type == TType.STRING) {
              this.name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // NEW_NAME
            if (field.type == TType.STRING) {
              this.new_name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(NS_FIELD_DESC);
      oprot.writeI64(this.ns);
      oprot.writeFieldEnd();
      if (this.name != null) {
        oprot.writeFieldBegin(NAME_FIELD_DESC);
        oprot.writeString(this.name);
        oprot.writeFieldEnd();
      }
      if (this.new_name != null) {
        oprot.writeFieldBegin(NEW_NAME_FIELD_DESC);
        oprot.writeString(this.new_name);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("rename_table_args(");
      boolean first = true;

      sb.append("ns:");
      sb.append(this.ns);
      first = false;
      if (!first) sb.append(", ");
      sb.append("name:");
      if (this.name == null) {
        sb.append("null");
      } else {
        sb.append(this.name);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("new_name:");
      if (this.new_name == null) {
        sb.append("null");
      } else {
        sb.append(this.new_name);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class rename_table_result implements TBase<rename_table_result, rename_table_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("rename_table_result");

    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public ClientException e;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      E((short)1, "e");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // E
            return E;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(rename_table_result.class, metaDataMap);
    }

    public rename_table_result() {
    }

    public rename_table_result(
      ClientException e)
    {
      this();
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public rename_table_result(rename_table_result other) {
      if (other.isSetE()) {
        this.e = new ClientException(other.e);
      }
    }

    public rename_table_result deepCopy() {
      return new rename_table_result(this);
    }

    @Override
    public void clear() {
      this.e = null;
    }

    public ClientException getE() {
      return this.e;
    }

    public rename_table_result setE(ClientException e) {
      this.e = e;
      return this;
    }

    public void unsetE() {
      this.e = null;
    }

    /** Returns true if field e is set (has been asigned a value) and false otherwise */
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((ClientException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case E:
        return getE();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case E:
        return isSetE();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof rename_table_result)
        return this.equals((rename_table_result)that);
      return false;
    }

    public boolean equals(rename_table_result that) {
      if (that == null)
        return false;

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(rename_table_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      rename_table_result typedOther = (rename_table_result)other;

      lastComparison = Boolean.valueOf(isSetE()).compareTo(typedOther.isSetE());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetE()) {
        lastComparison = TBaseHelper.compareTo(this.e, typedOther.e);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // E
            if (field.type == TType.STRUCT) {
              this.e = new ClientException();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetE()) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("rename_table_result(");
      boolean first = true;

      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class drop_table_args implements TBase<drop_table_args, drop_table_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("drop_table_args");

    private static final TField NS_FIELD_DESC = new TField("ns", TType.I64, (short)1);
    private static final TField NAME_FIELD_DESC = new TField("name", TType.STRING, (short)2);
    private static final TField IF_EXISTS_FIELD_DESC = new TField("if_exists", TType.BOOL, (short)3);

    public long ns;
    public String name;
    public boolean if_exists;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      NS((short)1, "ns"),
      NAME((short)2, "name"),
      IF_EXISTS((short)3, "if_exists");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // NS
            return NS;
          case 2: // NAME
            return NAME;
          case 3: // IF_EXISTS
            return IF_EXISTS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __NS_ISSET_ID = 0;
    private static final int __IF_EXISTS_ISSET_ID = 1;
    private BitSet __isset_bit_vector = new BitSet(2);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.NS, new FieldMetaData("ns", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64          , "Namespace")));
      tmpMap.put(_Fields.NAME, new FieldMetaData("name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.IF_EXISTS, new FieldMetaData("if_exists", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.BOOL)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(drop_table_args.class, metaDataMap);
    }

    public drop_table_args() {
      this.if_exists = true;

    }

    public drop_table_args(
      long ns,
      String name,
      boolean if_exists)
    {
      this();
      this.ns = ns;
      setNsIsSet(true);
      this.name = name;
      this.if_exists = if_exists;
      setIf_existsIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public drop_table_args(drop_table_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.ns = other.ns;
      if (other.isSetName()) {
        this.name = other.name;
      }
      this.if_exists = other.if_exists;
    }

    public drop_table_args deepCopy() {
      return new drop_table_args(this);
    }

    @Override
    public void clear() {
      setNsIsSet(false);
      this.ns = 0;
      this.name = null;
      this.if_exists = true;

    }

    public long getNs() {
      return this.ns;
    }

    public drop_table_args setNs(long ns) {
      this.ns = ns;
      setNsIsSet(true);
      return this;
    }

    public void unsetNs() {
      __isset_bit_vector.clear(__NS_ISSET_ID);
    }

    /** Returns true if field ns is set (has been asigned a value) and false otherwise */
    public boolean isSetNs() {
      return __isset_bit_vector.get(__NS_ISSET_ID);
    }

    public void setNsIsSet(boolean value) {
      __isset_bit_vector.set(__NS_ISSET_ID, value);
    }

    public String getName() {
      return this.name;
    }

    public drop_table_args setName(String name) {
      this.name = name;
      return this;
    }

    public void unsetName() {
      this.name = null;
    }

    /** Returns true if field name is set (has been asigned a value) and false otherwise */
    public boolean isSetName() {
      return this.name != null;
    }

    public void setNameIsSet(boolean value) {
      if (!value) {
        this.name = null;
      }
    }

    public boolean isIf_exists() {
      return this.if_exists;
    }

    public drop_table_args setIf_exists(boolean if_exists) {
      this.if_exists = if_exists;
      setIf_existsIsSet(true);
      return this;
    }

    public void unsetIf_exists() {
      __isset_bit_vector.clear(__IF_EXISTS_ISSET_ID);
    }

    /** Returns true if field if_exists is set (has been asigned a value) and false otherwise */
    public boolean isSetIf_exists() {
      return __isset_bit_vector.get(__IF_EXISTS_ISSET_ID);
    }

    public void setIf_existsIsSet(boolean value) {
      __isset_bit_vector.set(__IF_EXISTS_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case NS:
        if (value == null) {
          unsetNs();
        } else {
          setNs((Long)value);
        }
        break;

      case NAME:
        if (value == null) {
          unsetName();
        } else {
          setName((String)value);
        }
        break;

      case IF_EXISTS:
        if (value == null) {
          unsetIf_exists();
        } else {
          setIf_exists((Boolean)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case NS:
        return new Long(getNs());

      case NAME:
        return getName();

      case IF_EXISTS:
        return new Boolean(isIf_exists());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case NS:
        return isSetNs();
      case NAME:
        return isSetName();
      case IF_EXISTS:
        return isSetIf_exists();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof drop_table_args)
        return this.equals((drop_table_args)that);
      return false;
    }

    public boolean equals(drop_table_args that) {
      if (that == null)
        return false;

      boolean this_present_ns = true;
      boolean that_present_ns = true;
      if (this_present_ns || that_present_ns) {
        if (!(this_present_ns && that_present_ns))
          return false;
        if (this.ns != that.ns)
          return false;
      }

      boolean this_present_name = true && this.isSetName();
      boolean that_present_name = true && that.isSetName();
      if (this_present_name || that_present_name) {
        if (!(this_present_name && that_present_name))
          return false;
        if (!this.name.equals(that.name))
          return false;
      }

      boolean this_present_if_exists = true;
      boolean that_present_if_exists = true;
      if (this_present_if_exists || that_present_if_exists) {
        if (!(this_present_if_exists && that_present_if_exists))
          return false;
        if (this.if_exists != that.if_exists)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(drop_table_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      drop_table_args typedOther = (drop_table_args)other;

      lastComparison = Boolean.valueOf(isSetNs()).compareTo(typedOther.isSetNs());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetNs()) {
        lastComparison = TBaseHelper.compareTo(this.ns, typedOther.ns);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetName()).compareTo(typedOther.isSetName());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetName()) {
        lastComparison = TBaseHelper.compareTo(this.name, typedOther.name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetIf_exists()).compareTo(typedOther.isSetIf_exists());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetIf_exists()) {
        lastComparison = TBaseHelper.compareTo(this.if_exists, typedOther.if_exists);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // NS
            if (field.type == TType.I64) {
              this.ns = iprot.readI64();
              setNsIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // NAME
            if (field.type == TType.STRING) {
              this.name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // IF_EXISTS
            if (field.type == TType.BOOL) {
              this.if_exists = iprot.readBool();
              setIf_existsIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(NS_FIELD_DESC);
      oprot.writeI64(this.ns);
      oprot.writeFieldEnd();
      if (this.name != null) {
        oprot.writeFieldBegin(NAME_FIELD_DESC);
        oprot.writeString(this.name);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(IF_EXISTS_FIELD_DESC);
      oprot.writeBool(this.if_exists);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("drop_table_args(");
      boolean first = true;

      sb.append("ns:");
      sb.append(this.ns);
      first = false;
      if (!first) sb.append(", ");
      sb.append("name:");
      if (this.name == null) {
        sb.append("null");
      } else {
        sb.append(this.name);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("if_exists:");
      sb.append(this.if_exists);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class drop_table_result implements TBase<drop_table_result, drop_table_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("drop_table_result");

    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public ClientException e;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      E((short)1, "e");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // E
            return E;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(drop_table_result.class, metaDataMap);
    }

    public drop_table_result() {
    }

    public drop_table_result(
      ClientException e)
    {
      this();
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public drop_table_result(drop_table_result other) {
      if (other.isSetE()) {
        this.e = new ClientException(other.e);
      }
    }

    public drop_table_result deepCopy() {
      return new drop_table_result(this);
    }

    @Override
    public void clear() {
      this.e = null;
    }

    public ClientException getE() {
      return this.e;
    }

    public drop_table_result setE(ClientException e) {
      this.e = e;
      return this;
    }

    public void unsetE() {
      this.e = null;
    }

    /** Returns true if field e is set (has been asigned a value) and false otherwise */
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((ClientException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case E:
        return getE();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case E:
        return isSetE();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof drop_table_result)
        return this.equals((drop_table_result)that);
      return false;
    }

    public boolean equals(drop_table_result that) {
      if (that == null)
        return false;

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(drop_table_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      drop_table_result typedOther = (drop_table_result)other;

      lastComparison = Boolean.valueOf(isSetE()).compareTo(typedOther.isSetE());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetE()) {
        lastComparison = TBaseHelper.compareTo(this.e, typedOther.e);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // E
            if (field.type == TType.STRUCT) {
              this.e = new ClientException();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetE()) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("drop_table_result(");
      boolean first = true;

      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

}
